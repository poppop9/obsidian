# 顺序执行多条命令
## 简单顺序执行
>简单的顺序执行使用 `;` 

```bash
sudo apt-get update
sudo apt-get install some-tool
some-tool

# 以上三条命令可以简化成
sudo apt-get update;sudo apt-get install some-tool;some-tool
```

>[!hint] 如果简单顺序执行命令时，前面的命令执行不成功，而后面的命令又依赖于上一条命令的结果，那么就无法直观的判断结果是否正确，所以我们有了<u>选择执行</u>

## 选择执行
>- `&&`，如果 `&&` 前面的命令执行成功，则执行 `&&` 后面的命令
>- `||`，如果 `||` 前面的命令执行失败，则执行 `||` 后面的命令

```bash
# 没有安装cowsay时，什么也不发生
which cowsay>/dev/null && cowsay -f head-in ohch~
```

```bash
# which cowsay>/dev/null成功，则执行echo "exist"，echo "exist"失败，则echo "not exist"
# which cowsay>/dev/null失败，则执行echo "not exist"
which cowsay>/dev/null && echo "exist" || echo "not exist"
```

# 管道
> 管道是将上一个进程的输出，作为下一个进程的输入

---

- 管道
	- **匿名管道** `|`：使用一些过滤程序时用到
	- **具名管道**：通常只在源程序中用到

---

```bash
# 不使用管道就必须把输出写到一个文件中，再去查看文件
ls -al /etc > output.txt
less output.txt

# 使用ls查看目录，并把输出的内容作为了less命令的输入
ls -al /etc | less
```

## cut
- `cut` 打印每一行中的特定的部分
	- `-d '分隔符'` 按照分隔符将每一行分成多个字段
	- `-f 字段1，……字段n` 选取指定的字段
	- `-c 字符数/字符范围` 选取指定的字符

```bash
# 打印 `/etc/passwd` 文件中以 `:` 为分隔符的第 1 个字段（用户名）和第 6 个字段（用户的home目录）
cut /etc/passwd -d ':' -f 1,6
```

```bash
# 打印 `/etc/passwd` 文件中每一行的前 N 个字符
# 打印第五个字符
cut /etc/passwd -c 5

# 前五个（包含第5个）
cut /etc/passwd -c -5

# 打印五个之后的字符（包含第五个）
cut /etc/passwd -c 5-

# 2 到 5 之间的（包含第二个，第五个）
cut /etc/passwd -c 2-5
```

## grep
`grep` 结合<u>正则表达式</u>实现了复杂，高效的匹配和查找

- `grep 正则表达式 [文件]……`
	- `-r` 递归搜索子目录文件
	- `-n` 打印被匹配到目标的行号
	- `-I` 忽略二进制文件 

```bash
# 搜索`/home/shiyanlou`目录下所有包含"shiyanlou"字符的文本文件，并显示该字符出现在文本文件中的行号
grep -rnI "shiyanlou" ~
```

```bash
# 查看环境变量中以 "yanlou" 结尾的字符串
# "."表示任何字符
# "*"表示前面的字符可以出现任意次
# "$"表示字符串的结束
export | grep ".*yanlou$"
```

## wc
- `wc 文件` 统计并输出一个文件中<u>行</u>，<u>单词</u>，<u>字节</u>的数目
	- `-l` 只统计输出行数
	- `-w` 只统计输出单词数
	- `-c` 只统计输出字节数
	- `-m` 只统计输出字符数
	- `-L` 只统计输出最长一行的字节数

```bash
# 输出 `/etc/passwd` 文件的行数，单词数，字节数
wc /etc/passwd
  36   55 1914 /etc/passwd
```

```bash
# 统计行数
wc -l /etc/passwd
```

```bash
# 统计 /etc/ 下所有目录数
ls -dl /etc/*/ | wc -l
```

## sort
- `sort` 将输入按照一定方式排序【默认字典排序】，然后再输出
	- `-r` 反转排序
	- `-t '字段'` 指定字段的分隔符
	- `-k 字段号` 指定对第几个字段进行排序
	- `-n` 按照数字排序

按月份排序，随机排序……

```bash
cat /etc/passwd | sort

cat /etc/passwd | sort -r

cat /etc/passwd | sort -t':' -k 3

# 注意看第三个字段，是按照数字排序的
cat /etc/passwd | sort -t':' -k 3 -n
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
```

## uniq
- `uniq` 可以过滤重复行，或者输出重复行

### 过滤重复行
我们可以使用 `history` 命令查看最近执行过的命令（实际为读取 `${SHELL}_history` 文件，如我们环境中的 `.zsh_history` 文件），不过你可能只想查看使用了哪个命令而不需要知道具体干了什么，那么你可能就会要想去掉命令后面的参数然后去掉重复的命令：

```bash
history | cut -c 8- | cut -d ' ' -f 1 | uniq
```

然后经过层层过滤，你会发现确是只输出了执行的命令那一列，不过去重效果好像不明显，仔细看你会发现它确实去重了，只是不那么明显，之所以不明显是因为 `uniq` 命令只能去连续重复的行，不是全文去重，所以要达到预期效果，我们先排序：

```bash
history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq
# 或者
history | cut -c 8- | cut -d ' ' -f 1 | sort -u
```

这就是 Linux/UNIX 哲学吸引人的地方，大繁至简，一个命令只干一件事却能干到最好。

### 输出重复行
```bash
# 输出重复过的行（重复的只输出一个）及重复次数
history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -dc
# 输出所有重复的行
history | cut -c 8- | cut -d ' ' -f 1 | sort | uniq -D
```

文本处理命令还有很多，下一节将继续介绍一些常用的文本处理的命令。

#### 轻松一下

使用以前介绍过的方法，安装`aview`和`imagemagick`，然后用`asciiview`命令显示图片，使用方法可以用 man 命令查看。

Linus 大神的照片地址 [https://labfile.oss.aliyuncs.com/courses/1/Linus.png](https://labfile.oss.aliyuncs.com/courses/1/Linus.png)

![1](https://doc.shiyanlou.com/linux_base/linus.png)

执行以下命令安装工具包并下载图片：

```bash
sudo apt update

sudo apt install -y aview imagemagick

wget https://labfile.oss-internal.aliyuncs.com/courses/1/Linus.png
```

执行 `asciiview [图片文件名]` 即可打开图片：

![图片描述](https://dn-simplecloud.shiyanlou.com/uid/dcb2ea4c3df440da669e05ba35dbe75d/1550043520959.png)

































































