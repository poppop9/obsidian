# 查看容量
## df
- `df` 查看磁盘容量【~~disk filesystem~~】
	- `-h` 以易读方式查看

```bash
df -h
```

## du
- `du [目录]` 查看指定目录及其子目录的容量，如果不指定则查看当前目录及其子目录的容量【~~disk usage~~】
	- `-h` 以易读方式查看
	- `-b` 以文件中的字节大小来显示文件容量
	- `-a` 查看所有文件【包括隐藏文件】
	- `-d *` 指定查看目录的深度
	- `-s` 只查看当前目录【也就是深度为 0】

```bash
du -sh

# 只查看0级目录的信息【只查看目录本身】
du -hd 0 ~
```

# 磁盘管理
## dd 复制
>[!hint] `cp` 与 `dd` 对比，不能复制哪些文件 ？
>`cp` 只复制文件内容，不能复制：
>
>- 元数据【创建时间，修改时间……】
>- 硬链接和软链接【快捷方式】【~~`cp` 只能复制快捷方式背后的文件~~】
>- <u>设备文件</u>【设备文件是对系统中物理设备（硬盘，键盘，鼠标……）的抽象】
>- 文件权限和所有权
>- 磁盘的引导扇区和分区表
>- 按照指定的块大小直接复制磁盘的原始内容

>[!warning] `dd` 的命令行选项格式为 `选项=值`，而不是 `-选项 值` 

### 输入源，输出源
- `dd` 从标准输入【键盘】中读取数据，并将数据写入到标准输出【屏幕】【**默认**】【~~data description~~】
	- `if=输入文件` 从文件中读取数据
	- `of=输出文件` 写入数据到指定文件

```bash
# 从键盘读取的数据写入到 "test" 文件中，只读取和写入一次，一次是10字节
dd of=test bs=10 count=1

dd if=/dev/stdin of=/dev/stdout bs=10 count=1
```

### 复制时处理数据
- `dd` 
	- `conv=值` 转换字节序，在 ASCII 与 EBCDIC 编码间互换……
		- `lcase` 将英文字符转为小写
		- `ucase` 将英文字符转为大写
		- `ascii` 将 EBCDIC 编码转为 ASCII 编码

```bash
# 将英文字符转换为大写再写入test文件
dd of=test bs=10 count=1 conv=ucase
```

### 创建虚拟磁盘镜像
- 创建空的虚拟磁盘镜像
```bash
# 从 `/dev/zero` 设备创建一个容量为 256M 的内容全是零字节的文件
dd if=/dev/zero of=virtual.img bs=1M count=256

du -h virtual.img
256M    virtual.img
```

---

- 使用 `mkfs` 【~~make filesystem~~】将虚拟磁盘镜像格式化【将<u>文件系统</u>写入到虚拟磁盘镜像中】
```bash
# 将 "virtual.img" 文件格式化为 ext4 文件系统
mkfs -t ext4 virtual.img
```

---

>[!hint] 挂载
>- 在 Linux 中，所有的文件和目录都是从根目录 `/` 开始的<u>一颗大树</u>【文件系统】，它们都必须挂载到这颗树上的<u>某个节点</u>【目录】才能被访问
> 
>- 根目录 `/` 在系统启动时自动挂载
>
>- 当我们插入一个 USB，或其他可移动存储设备时，操作系统会自动执行 `mount`，把这个设备挂载到文件系统的某个目录下，让我们可以访问这个设备中的文件

- 将磁盘挂载到目录树
	- `mount` 查看主机已经挂载的文件系统
	- `mount 参数 源 目录`

```bash
# 查看主机已经挂载的文件系统
mount

---
# 输出结果：最前面是设备名，on 后面是挂载点，type 后面是文件系统类型，最后面是挂载选项【在挂载时设定以只读方式挂载……】
tmpfs on /sys/firmware type tmpfs (ro,relatime)
```

```bash
mount [options] [source] [directory]

mount [-o [操作选项]] [-t 文件系统类型] [-w|--rw|--ro] [文件系统源] [挂载点]
```

**注意：由于实验楼的环境限制，mount 命令挂载及 umount 卸载都无法进行操作，可以简单了解这些步骤。**

现在直接来挂载我们创建的虚拟磁盘镜像到 `/mnt` 目录：

```bash
mount -o loop -t ext4 virtual.img /mnt
# 也可以省略挂载类型，很多时候 mount 会自动识别

# 以只读方式挂载
mount -o loop --ro virtual.img /mnt
# 或者 mount -o loop,ro virtual.img /mnt
```

#### 使用 umount 命令卸载已挂载磁盘

**注意：由于实验楼的环境限制，mount 命令挂载及 umount 卸载都无法进行操作，可以简单了解这些步骤。**

```bash
# 命令格式 sudo umount 已挂载设备名或者挂载点，如：
sudo umount /mnt
```

不过遗憾的是，由于我们环境的问题（环境中使用的 Linux 内核在编译时没有添加对 Loop device 的支持），所以你将无法挂载成功：

![此处输入图片的描述](https://doc.shiyanlou.com/document-uid600404labid6122timestamp1523925358180.png)

另外关于 loop 设备，你可能会有诸多疑问，那么请看下面来自维基百科 [/dev/loop](http://zh.wikipedia.org/wiki//dev/loop)的说明：

> 在类 UNIX 系统中，/dev/loop（或称 vnd （vnode disk）、lofi（循环文件接口））是一种伪设备，这种设备使得文件可以如同块设备一般被访问。
> 
> 在使用之前，循环设备必须与现存文件系统上的文件相关联。这种关联将提供给用户一个应用程序接口，接口将允许文件视为块特殊文件（参见设备文件系统）使用。因此，如果文件中包含一个完整的文件系统，那么这个文件就能如同磁盘设备一般被挂载。
> 
> 这种设备文件经常被用于光盘或是磁盘镜像。通过循环挂载来挂载包含文件系统的文件，便使处在这个文件系统中的文件得以被访问。这些文件将出现在挂载点目录。如果挂载目录中本身有文件，这些文件在挂载后将被禁止使用。

#### 使用 fdisk 为磁盘分区

（关于分区的一些概念不清楚的用户请参看 [主引导记录](http://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95)）

**注意：由于实验楼的环境限制，fdisk 命令无法进行操作，可以简单了解这些步骤。**

同样因为环境中没有物理磁盘，也无法创建虚拟磁盘的原因我们就无法实验练习使用该命令了，下面我将以我的物理主机为例讲解如何为磁盘分区。

```bash
# 查看硬盘分区表信息
sudo fdisk -l
```

![1](https://doc.shiyanlou.com/linux_base/7-12.png)

输出结果中开头显示了我主机上的磁盘的一些信息，包括容量扇区数，扇区大小，I/O 大小等信息。

我们重点看一下中间的分区信息，`/dev/sda1`，`/dev/sda2` 为主分区分别安装了 Windows 和 Linux 操作系统，`/dev/sda3` 为交换分区（可以理解为虚拟内存），`/dev/sda4` 为扩展分区其中包含 `/dev/sda5`，`/dev/sda6`，`/dev/sda7`，`/dev/sda8` 四个逻辑分区，因为主机上有几个分区之间有空隙，没有对齐边界扇区，所以分区之间不是完全连续的。

```bash
# 进入磁盘分区模式
sudo fdisk virtual.img
```

![1](https://doc.shiyanlou.com/linux_base/7-13.png)

在进行操作前我们首先应先规划好我们的分区方案，这里我将在使用 128M（可用 127M 左右）的虚拟磁盘镜像创建一个 30M 的主分区剩余部分为扩展分区包含 2 个大约 45M 的逻辑分区。

操作完成后输入 `p` 查看结果如下:

![1](https://doc.shiyanlou.com/linux_base/7-14.png)

最后不要忘记输入 `w` 写入分区表。

#### 使用 losetup 命令建立镜像与回环设备的关联

**注意：由于实验楼的环境限制，losetup 命令无法进行操作，可以简单了解这些步骤。**

同样因为环境原因中没有物理磁盘，也没有 loop device 的原因我们就无法实验练习使用该命令了，下面我将以我的物理主机为例讲解。

```bash
sudo losetup /dev/loop0 virtual.img
# 如果提示设备忙你也可以使用其它的回环设备，"ls /dev/loop*"参看所有回环设备

# 解除设备关联
sudo losetup -d /dev/loop0
```

然后再使用 `mkfs` 格式化各分区（前面我们是格式化整个虚拟磁盘镜像文件或磁盘），不过格式化之前，我们还要为各分区建立虚拟设备的映射，用到 `kpartx` 工具，需要先安装：

```bash
sudo apt-get install kpartx
sudo kpartx -av /dev/loop0

# 取消映射
sudo kpartx -dv /dev/loop0
```

![pic](https://doc.shiyanlou.com/linux_base/7-15.png)

接着再是格式化，我们将其全部格式化为 ext4：

```bash
sudo mkfs.ext4 -q /dev/mapper/loop0p1
sudo mkfs.ext4 -q /dev/mapper/loop0p5
sudo mkfs.ext4 -q /dev/mapper/loop0p6
```

格式化完成后在 `/media` 目录下新建四个空目录用于挂载虚拟磁盘：

```bash
mkdir -p /media/virtualdisk_{1..3}
```

```bash
# 挂载磁盘分区
sudo mount /dev/mapper/loop0p1 /media/virtualdisk_1
sudo mount /dev/mapper/loop0p5 /media/virtualdisk_2
sudo mount /dev/mapper/loop0p6 /media/virtualdisk_3

# 卸载磁盘分区
sudo umount /dev/mapper/loop0p1
sudo umount /dev/mapper/loop0p5
sudo umount /dev/mapper/loop0p6
```

然后：

```bash
df -h
```

![pic](https://doc.shiyanlou.com/linux_base/7-16.png)

#### 轻松一下

`cowsay` 命令，可以让你在终端里以一种动物说话的形式打印出一段话。

```bash
# 更新软件包
sudo apt update

# 安装
sudo apt install -y cowsay

# 默认是一只牛
cowsay hello shiyanlou

# 加上'-l'参数打印所有支持的动物（其实不只是动物）种类
cowsay -l

# 使用'-f'参数选择动物种类
cowsay -f elephant hello shiyanlou

# 安装 fortune-zh
sudo apt-get install fortune-zh

# 此外它还可以结合我们之前的作业讲过的 fortune 命令一起使用
/usr/games/fortune | cowsay -f daemon
```

![此处输入图片的描述](https://doc.shiyanlou.com/document-uid735639labid62timestamp1532339794389.png)























