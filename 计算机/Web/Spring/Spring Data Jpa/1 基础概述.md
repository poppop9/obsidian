
>[!quote] JPA 
>JPA 【~~Java Persistence API~~】是一种规范，可以看作是 JDBC 的升级版。JPA 封装了 Hibernate，Hibernate 通过 ORM 将 Java 对象映射到表，再通过 SQL 来操作表

```xml
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```


# 层次结构
![](https://s21.ax1x.com/2024/08/26/pAkPLWV.png)


# Entity
- **实体类注解**
	- `@Entity` 标记为实体
	- `@Table` 配置表
		- `name` 指定表名

---

- **属性注解**
	- `@Id` 指定主键
	- `@GeneratedValue` 指定某个字段的值是如何生成的
		- `strategy` 
			- `GenerationType.IDENTITY` 让数据库自己自增
			- `GenerationType.SEQUENCE` 使用数据库的序列来生成主键值
			- `GenerationType.UUID` 根据 UUID 生成主键值
	- `@Column` 配置列
		- `name` 指定列名

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "tb_customer")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "no")
    private Long no;
    @Column(name = "cust_name")
    private String custName;
    @Column(name = "cust_address")
    private String custAddress;
}

```

# ❤️ JpaRepository
JpaRepository 中有许多默认方法，**也可以在继承了 JpaRepository 的接口中自定义方法，这些方法会根据方法名自动生成相应条件的 SQL 语句，无需额外配置**

```java
// JpaRepository<实体名，主键的数据类型>
public interface CustomerRepository extends JpaRepository<Customer, Long> {

    Customer save(Customer customer);

    /**
     * 查询接口
     */
    Optional<Customer> findById(Long id);

    List<Customer> findByCustName(String custName);
}
```

>[!hint] 如果你定义了一个继承自 `Repository` 接口的自定义接口，Spring 容器会自动为你创建这个接口的实例，并注入到 IOC 容器中，也就是不需要加 `@Repository` 

## 💛 新增，修改
- `save(实体对象)` 增改，但是会等待一个事务的提交，其才会影响到数据库
- `saveAll(集合)` 批量增改
- `saveAndFlush(实体对象)` 增改，并立即提交这个操作
- `saveAllAndFlush(集合)` 

```java
// 不带主键，就是新增
customerRepository.save(new Customer(null, 33L, "nelson", "France"));

// 带主键，就是修改
customerRepository.save(new Customer(1L, 2L, "Kite", "Japen"));
```

```java
customerRepository.saveAllAndFlush(
		List.of(
				new Customer(null, 33L, "nelson", "France"),
				new Customer(null, 33L, "nelson", "France")
		)
);
```

## 💛 查
- **查一个**
	- `findOne(Example 条件对象)` **如果有多个匹配项，会报错**
- **查多个**
	- `findAll()` 无条件查
	- `findAll(Example 条件对象)` 
	- `findAll(Sort 排序对象)` 
	- `findAll(条件对象, 排序对象)` 
	- `findAllById(id集合)` 
	- 分页查
		- `findAll(Pageable 分页参数)` 
		- `findAll(Example 条件对象，Pageable 分页参数)` 

```java
/**
	条件 + 排序查
**/
// 构造条件
Example<Customer> example1 = Example.of(new Customer(null, 33L, null, null));  
// 构造排序规则
Sort sort = Sort.by("custName").descending();
customerRepository.findAll(example1, sort)  
        .forEach(System.out::println);
```

```java
/**
	分页查
**/
// 查第一页，每一页4条数据
Page<Customer> all = customerRepository.findAll(PageRequest.of(0, 4));
all.getContent().forEach(System.out::println);

---
Customer(id=1, no=2, custName=Kite, custAddress=Japen)
Customer(id=3, no=2, custName=David, custAddress=Hong Kong)
Customer(id=4, no=33, custName=nelson, custAddress=France)
Customer(id=5, no=33, custName=hoan, custAddress=Korea)
```

## 💛 其他方法
<u>判断是否存在</u> ：
- `Boolean existsById(id)` 看对应 id 的数据是否存在
- `Boolean exists(Example 条件对象)` 复杂条件查询数据是否存在

```java
System.out.println(customerRepository.existsById(1L));  
```

```java
// 构建条件，id为1，并且name为Kite的数据
Example<Customer> example = Example.of(new Customer(1L, null, "Kite", null));  

System.out.println(customerRepository.exists(example));  
```

---

<u>判断数量</u> ：
- `count()` 
- `count(Example 条件对象)`

```java
long count = customerRepository.count();
System.out.println(count);
```




当你在定义 `@Bean` 注解的方法参数中使用 Repository 接口时，Spring 会自动注入相应的 Repository 实例，你不需要手动进行依赖注入


---

# ❤️ 高级特性
## 基接口 Repository
使用基接口 Repository 可以复用方法名

- 定义基接口
```java
@NoRepositoryBean
public interface BaseRepository<T> {
    List<T> findAllByCustName(String name);
}
```
- 继承
```java
public interface CustomerRepository extends BaseRepository<Customer>, JpaRepository<Customer, Long> {
}
```



---

高级特性，如动态查询、多表查询、嵌套查询、存储过程和函数调用等。例如，可以通过使用 @Query 注解来手动编写查询语句，或者使用 Spring Data JPA 提供的命名约定来自动生成查询语句。使用 Specification 对象来实现动态查询

在 Spring Data JPA 中，可以使用 Spring Cache 来实现缓存配置，使用 HikariCP 来实现1数据库连接池配置等
















