
>[!hint] 理论要结合实际，要在实际场景下聊设计模式，有些设计模式是互斥的

---

>[!quote] 单一职责原则
>一个类应该只有一个职责，每个类应该专注于完成一项具体的任务，从而使类更加可维护和可扩展

>[!quote] 开放封闭原则
>>对于某一个特殊的功能要求，软件实体（类、模块、函数 ……）应该对扩展开放的，对修改封闭。~~但是这是对于一个已开发完成的 SDK 来说，如果一个项目是自己开发的，软件实体里就那一点点东西，还不完善，那就修改就好了，不要往下继承扩展了~~
>
>**实际场景**：
>A 用户，B 用户，D 用户都要使用一个功能类 C，但是只有 B 需要某个属性值为 2，那就不要在原有的 C 上修改来修改去，让 B 继承 C 之后再扩展。~~如果大家都共性地要求某个功能，那就修改 C，不要扩展~~

>[!quote] 里氏替换原则
>>子类对象必须能够替换掉父类对象，而不影响程序的正确性和预期行为。~~比如 B 子类重写了 A 父类的某个方法，破坏了 A 的行为，那如果后续 A 做了功能迭代，B 就不能马上进行适配了，这就不好~~
>
>违反了里氏替换原则的例子【~~子类 Ostrich，已经违反了父类 Bird 会飞行的行为了~~】：
>
> ```java
> // Bird类
> public class Bird {
>     public void fly() {
>         System.out.println("飞行");
>     }
> }
> 
> // Ostrich类
> public class Ostrich extends Bird {
>     public void fly() {
>         System.out.println("鸵鸟不会飞");
>     }
> }
> ```





---



3. 接口隔离原则（Interface Segregation Principle，ISP）：客户端不应该强迫依赖于它们不使用的接口。该原则鼓励将接口分割为更小、更具体的部分，以便客户端只需了解和依赖于它们需要使用的接口。这样可以避免接口的臃肿和不必要的依赖关系，提高系统的灵活性和可维护性。
4. 依赖倒置原则（Dependency Inversion Principle，DIP）：高层模块不应该依赖于低层模块，它们都应该依赖于抽象。抽象不应该依赖于具体实现细节，而具体实现应该依赖于抽象。这意味着应该通过接口或抽象类来定义模块之间的依赖关系，而不是直接依赖于具体的实现类。这样可以减少模块间的耦合度，提高系统的灵活性和可维护性。












