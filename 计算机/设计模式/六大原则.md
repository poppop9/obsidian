
>[!hint] 理论要结合实际，要在实际场景下聊设计模式，有些设计模式是互斥的

---

>[!quote] 单一职责原则
>一个类应该只有一个职责，每个类应该专注于完成一项具体的任务，从而使类更加可维护和可扩展

>[!quote] 开放封闭原则
>>对于某一个特殊的功能要求，软件实体（类、模块、函数 ……）应该对扩展开放的，对修改封闭。~~但是这是对于一个已开发完成的 SDK 来说，如果一个项目是自己开发的，软件实体里就那一点点东西，还不完善，那就修改就好了，不要往下继承扩展了~~
>
>**实际场景**：
>A 用户，B 用户，D 用户都要使用一个功能类 C，但是只有 B 需要某个属性值为 2，那就不要在原有的 C 上修改来修改去，让 B 继承 C 之后再扩展。~~如果大家都共性地要求某个功能，那就修改 C，不要扩展~~

>[!quote] 里氏替换原则
>>子类对象必须能够替换掉父类对象，而不影响程序的正确性和预期行为。~~比如 B 子类重写了 A 父类的某个方法，破坏了 A 的行为，那如果后续 A 做了功能迭代，B 就不能马上进行适配了，这就不好~~
>
>违反了里氏替换原则的例子【~~子类 Ostrich，已经违反了父类 Bird 会飞行的行为了~~】：
>
> ```java
> // Bird类
> public class Bird {
>     public void fly() {
>         System.out.println("飞行");
>     }
> }
> 
> // Ostrich类
> public class Ostrich extends Bird {
>     public void fly() {
>         System.out.println("鸵鸟不会飞");
>     }
> }
> ```

>[!quote] 迪米特原则
>>一个对象应该对其他对象有尽可能少的了解，最好只与一个对象的一个接口进行交互，而避免与其他对象 / 细节发生耦合
>
>违反迪米特原则例子：

```java
// Order订单，Customer客户，Product产品

❌
public class Order {
    private Customer customer;

    public Product getProduct() {
        return customer.getProduct();
    }
}

✔️
public class Order {
    private Product product;

    public Product getProduct() {
        return product;
    }
}
```

1. 每个对象都应该有尽可能少的了解其他对象的内部信息。对象只应该与它的成员变量、方法的参数、方法内部创建的对象以及与它直接关联的对象发生交互。
2. 对象之间的耦合应该最小化。一个对象只应该知道与它相互作用的对象的一些公共接口，而不需要了解这些对象的具体实现细节。
3. 不要给无关的对象发送消息。在调用一个对象的方法时，尽量避免调用该对象的成员变量所属对象的方法。

通过遵循迪米特原则，可以提高系统的灵活性和可维护性，减少对象之间的依赖关系，降低系统的耦合度，同时也有利于对象的复用和扩展。

迪米特原则可以应用于各种软件开发场景，包括面向对象的设计、模块化设计、系统架构等。它强调了对象之间的松耦合设计，有助于构建更加可靠、可扩展和可维护的软件系统。

---



3. 接口隔离原则（Interface Segregation Principle，ISP）：客户端不应该强迫依赖于它们不使用的接口。该原则鼓励将接口分割为更小、更具体的部分，以便客户端只需了解和依赖于它们需要使用的接口。这样可以避免接口的臃肿和不必要的依赖关系，提高系统的灵活性和可维护性。
4. 依赖倒置原则（Dependency Inversion Principle，DIP）：高层模块不应该依赖于低层模块，它们都应该依赖于抽象。抽象不应该依赖于具体实现细节，而具体实现应该依赖于抽象。这意味着应该通过接口或抽象类来定义模块之间的依赖关系，而不是直接依赖于具体的实现类。这样可以减少模块间的耦合度，提高系统的灵活性和可维护性。












