
>[!quote] OO 原则 【~~Object-Oriented~~】
>>面向对象设计原则 是一组指导原则，用于帮助开发者设计出灵活、可维护和可扩展的面向对象系统
>
><u>OO 原则</u> = <u>SOLID 原则</u> + <u>其他原则</u> +抽象 + 封装 + 继承 + 多态 + ……

# 六大原则 / SOLID 原则
>[!quote] 六大原则 / SOLID 原则
>SOLID 原则是 OO 原则的一个子集，它们是面向对象编程中更具体的指导原则

## 单一职责原则
>[!quote] 单一职责原则
>一个类应该只有一个职责，每个类应该专注于完成一项具体的任务，从而使类更加可维护和可扩展

## 开放封闭原则
>[!quote] 开放封闭原则
>>对于某一个特殊的功能要求，软件实体（类、模块、函数 ……）应该对扩展开放的，对修改封闭。~~但是这是对于一个已开发完成的 SDK 来说，如果一个项目是自己开发的，软件实体里就那一点点东西，还不完善，那就修改就好了，不要往下继承扩展了~~
>
>**实际场景**：
>A 用户，B 用户，D 用户都要使用一个功能类 C，但是只有 B 需要某个属性值为 2，那就不要在原有的 C 上修改来修改去，让 B 继承 C 之后再扩展。~~如果大家都共性地要求某个功能，那就修改 C，不要扩展~~

## 里氏替换原则
>[!quote] 里氏替换原则
>>子类对象必须能够替换掉父类对象，而不影响程序的正确性和预期行为。~~比如 B 子类重写了 A 父类的某个方法，破坏了 A 的行为，那如果后续 A 做了功能迭代，B 就不能马上进行适配了，这就不好~~
>
>违反了里氏替换原则的例子【~~子类 Ostrich，已经违反了父类 Bird 会飞行的行为了~~】：
>
> ```java
> // Bird类
> public class Bird {
>     public void fly() {
>         System.out.println("飞行");
>     }
> }
> 
> // Ostrich类
> public class Ostrich extends Bird {
>     public void fly() {
>         System.out.println("鸵鸟不会飞");
>     }
> }
> ```

## 迪米特原则
>[!quote] 迪米特原则
>>一个对象应该对其他对象有尽可能少的了解，最好只与一个对象的一个接口进行交互，而避免与其他对象 / 细节发生耦合
>
>有 A，B，C 三个类，A 类需要到 B 类和 C 类的功能，B 类需要到 C 类的功能，那么就把 A 中需要到 C 的功能放到 B 中，让 A 只依赖于 B，而 B 只依赖于 C
>

## 接口隔离原则
>[!quote] 接口隔离原则
>鼓励将接口设计的更小，更具体，更精确和专注，以便客户端只需了解和依赖于它们需要使用的接口。~~在 Spring 源码中可以看到，很多接口里就只有一个方法，就是遵循的这个原则，如果一个接口中有多个方法，那有可能有的实现类不需要某个方法，但是它又不得不实现一个空方法，这就容易造成混乱~~

## 依赖倒置原则
>[!quote] 依赖倒置原则
>高层模块不应该依赖于低层模块，它们都应该依赖于抽象【~~应该通过接口或抽象类来定义模块之间的依赖关系，而不是直接依赖于具体的实现类~~】，后续如果低层模块需要变动，直接换接口的实现类就好了
> ```java
> // --------------现在低层模块和高层模块都依赖于具体的实现类
> // 低层模块
> public class Worker
> {
>     public void Work() { // 工作的具体实现 }
> }
> 
> // 高层模块
> public class Manager
> {
>     private Worker _worker;
> 
>     public Manager() { _worker = new Worker(); // 直接依赖于具体类 }
> 
>     public void Manage() { _worker.Work(); // 调用低层模块的方法 }
> }
> 
> // --------------现在低层模块和高层模块都依赖于抽象层
> // 抽象层
> public interface IWorker { void Work(); }
> 
> // 低层模块
> public class Worker implements IWorker {
>     public void Work() { // 工作的具体实现 }
> }
> 
> // 高层模块
> public class Manager {
>     private IWorker _worker;
> 
>     public Manager(IWorker worker) { _worker = worker; }
> 
>     public void Manage() { _worker.Work(); // 调用抽象层的方法 }
> }				  		
> ```

# 其他原则
>[!quote] 组合复用原则
>尽量使用对象的组合来实现代码复用，<u>而不是通过继承</u>

>[!quote] 单独封装变化
>如果每次有新的需求，某方面的代码就要变，那么这个变化的行为就要抽离出来，与其他不变的代码分离，这样你就可以修改扩展这个部分的时候，不会影响其他不变的代码
> - 不变的代码使用继承，因为继承的优点就是代码复用
> - 变化的代码使用接口，因为行为总是要变化的，我们可以利用多态来动态指定行为

























