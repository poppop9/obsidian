>[!quote] 泛型
>泛型提供了编译时<u>类型安全检测机制</u>，该机制允许程序员在编译时检测到非法的类型

>[!warning] 泛型类型参数只能是引用类型【`Integer`……】，不能是基本类型【`int`……】

# 泛型类，泛型方法，泛型接口
## 泛型类
- 实现了<u>一个类中不同类型的成员变量</u>

```java
class Generic<T> {               //泛型类
	private T t;         // T 可以指代任何类型
   
	public T getT() {return t;}  
  
	public void setT(T t) {this.t = t;}        //泛型方法
}
```

```java
public static void main(String[] args) {  
	Generic<Integer> gr = new Generic<Integer>();  
	gr.setT(123);  
	System.out.println(gr.getT());  
  
	Generic<String> grr = new Generic<String>();  
	grr.setT("Java");  
	System.out.println(grr.getT());  
}

---
123
Java
```

## 泛型方法
- 实现了<u>同一个方法可以容纳不同的数据类型</u>【方法重载虽然也可以，但代码冗余】

```java
public class demo {  
	public <T> void printArray(T[] inputArray) {  
	    // 输出数组元素  
	    for (T element : inputArray) {  
	        System.out.printf("%s ", element);  
	    }  
	}
}
```

## 泛型接口
```java
public interface Generic<T> {  
	void show(T t);  
}
```
```java
public class GenericImp<T> implements Generic<T> {  
	public void show(T t) {  
		System.out.println(t);  
	}  
}
```
```java
public class Demo1 {  
	public static void main(String[] args) {  
		Generic gr = new GenericImp();    //多态
		gr.show(123);  
		gr.show("Java");  
	}  
}

---
123
Java
```


**java 中泛型标记符：**
- **E** - Element (在集合中使用，因为集合中存放的是元素)
- **T** - Type（Java 类）
- **K** - Key（键）
- **V** - Value（值）
- **N** - Number（数值类型）
- **？** - 表示不确定的 java 类型

有界的类型参数：
可能有时候，你会想限制那些被允许传递到一个类型参数的类型种类范围。例如，一个操作数字的方法可能只希望接受Number或者Number子类的实例。这就是有界类型参数的目的。

要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。

# 创建集合时最好加上泛型
## 不加入泛型
如果没有设置泛型，集合的默认类型是 `Object`， 当 `l.add` 添加的是 int 时，程序不会编译错误，但是在遍历强转时会报错【因为无法将 Integer 类型强转为 String 类型，***当然，如果你使用*** `Object o = it.next()` 就可以解决，但是不推荐】

```java
public static void main(String[] args) {  
    List l = new ArrayList();  
    l.add("你");  
    l.add("123");  
  
    Iterator it = l.iterator();  
    while (it.hasNext()) {  
        String s = (String) it.next();  
        System.out.println(s);  
    }  
}

---
java.lang.ClassCastException
```

```java
public static void main(String[] args) {
	List l = new ArrayList();
	l.add("你");
	l.add(123);

	Iterator it = l.iterator();
	while (it.hasNext()) {
		Object o = it.next();
		System.out.print(o);
	}
}

---
你123
```
## 加入泛型
>如果设置了泛型，在编译期间 `add` 一个其他类型的数据就会报错


# 类型通配符
>`?`

```java
public static void main(String[] args) {  
	//继承关系：Integer extends Number extends Object
    List<?> list1 = new ArrayList<Object>();  
    List<?> list2 = new ArrayList<Number>();  
    List<?> list3 = new ArrayList<Integer>();  

	//extends Number表示上限是Number类
    List<? extends Number> list4 = new ArrayList<Object>();  //报错，不能为Object类
    List<? extends Number> list5 = new ArrayList<Number>();  
    List<? extends Number> list6 = new ArrayList<Integer>();  

	//super Number表示下限是Number类
    List<? super Number> list7 = new ArrayList<Object>();  
    List<? super Number> list8 = new ArrayList<Number>();  
    List<? super Number> list9 = new ArrayList<Integer>();  //报错，不能为Integer类
}
```

# 可变参数
```java
public class Demo2 {  
    public static void main(String[] args) {  
        System.out.println(sum(1, 2, 3));  
    }  
  
    public static int sum(int... a) {      //可变参数，这个a其实是个数组
        int sum = 0;  
        for (int i : a) {  
            sum = sum + i;  
        }  
        return sum;  
    }  
}


6
```
***如果不用可变参数，那就要写三个方法【每个方法设置不同的参数】***

>[!attention]
>如果你的方法里既要有固定参数又要有可变参数的话，要把可变参数写在后面。***如果写在前面，编译器会认为你传的参数全部都是可变参数，那么固定参数就传不进来了***


