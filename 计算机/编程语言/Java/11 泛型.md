>[!quote] 泛型
>泛型提供了编译时<u>类型安全检测机制</u>，该机制允许程序员在编译时检测到非法的类型

# 创建集合时最好加上泛型
## 不加入泛型
如果没有设置泛型，集合的默认类型是 `Object`， 当 `l.add` 添加的是 int 时，程序不会编译错误，但是在遍历强转时会报错【因为无法将 Integer 类型强转为 String 类型，***当然，如果你使用*** `Object o = it.next()` 就可以解决，但是不推荐】

```java
public static void main(String[] args) {  
    List l = new ArrayList();  
    l.add("你");  
    l.add("123");  
  
    Iterator it = l.iterator();  
    while (it.hasNext()) {  
        String s = (String) it.next();  
        System.out.println(s);  
    }  
}

---
java.lang.ClassCastException
```

```java
public static void main(String[] args) {
	List l = new ArrayList();
	l.add("你");
	l.add(123);

	Iterator it = l.iterator();
	while (it.hasNext()) {
		Object o = it.next();
		System.out.print(o);
	}
}

---
你123
```
## 加入泛型
>如果设置了泛型，在编译期间 `add` 一个其他类型的数据就会报错

# 泛型类，泛型方法，泛型接口
## 泛型类，泛型方法
- 实现了<u>一个类中不同类型的成员变量</u>
- 实现了<u>同一个方法可以容纳不同的数据类型</u>【方法重载虽然也可以，但代码冗余】

```java
class Generic<T> {               //泛型类
	private T t;         // T 可以指代任何类型
   
	public T getT() {return t;}  
  
	public void setT(T t) {this.t = t;}        //泛型方法
}
```

```java
public static void main(String[] args) {  
	Generic<Integer> gr = new Generic<Integer>();  
	gr.setT(123);  
	System.out.println(gr.getT());  
  
	Generic<String> grr = new Generic<String>();  
	grr.setT("Java");  
	System.out.println(grr.getT());  
}

---
123
Java
```

## 泛型接口
```java
public interface Generic<T> {  
	void show(T t);  
}
```
```java
public class GenericImp<T> implements Generic<T> {  
	public void show(T t) {  
		System.out.println(t);  
	}  
}
```
```java
public class Demo1 {  
	public static void main(String[] args) {  
		Generic gr = new GenericImp();    //多态
		gr.show(123);  
		gr.show("Java");  
	}  
}

---
123
Java
```


- 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的 \<E>）

**java 中泛型标记符：**
- **E** - Element (在集合中使用，因为集合中存放的是元素)
- **T** - Type（Java 类）
- **K** - Key（键）
- **V** - Value（值）
- **N** - Number（数值类型）
- **？** - 表示不确定的 java 类型


# 类型通配符
>`?`

```java
public static void main(String[] args) {  
	//继承关系：Integer extends Number extends Object
    List<?> list1 = new ArrayList<Object>();  
    List<?> list2 = new ArrayList<Number>();  
    List<?> list3 = new ArrayList<Integer>();  

	//extends Number表示上限是Number类
    List<? extends Number> list4 = new ArrayList<Object>();  //报错，不能为Object类
    List<? extends Number> list5 = new ArrayList<Number>();  
    List<? extends Number> list6 = new ArrayList<Integer>();  

	//super Number表示下限是Number类
    List<? super Number> list7 = new ArrayList<Object>();  
    List<? super Number> list8 = new ArrayList<Number>();  
    List<? super Number> list9 = new ArrayList<Integer>();  //报错，不能为Integer类
}
```

# 可变参数
```java
public class Demo2 {  
    public static void main(String[] args) {  
        System.out.println(sum(1, 2, 3));  
    }  
  
    public static int sum(int... a) {      //可变参数，这个a其实是个数组
        int sum = 0;  
        for (int i : a) {  
            sum = sum + i;  
        }  
        return sum;  
    }  
}


6
```
***如果不用可变参数，那就要写三个方法【每个方法设置不同的参数】***

>[!attention]
>如果你的方法里既要有固定参数又要有可变参数的话，要把可变参数写在后面。***如果写在前面，编译器会认为你传的参数全部都是可变参数，那么固定参数就传不进来了***


