# 概述
>继承可以使子类具有<u>父类</u>【基类，超类】的属性和方法，还可以在<u>子类</u>【派生类】中***重新定义***，追加属性和方法

```
public class 父类 {……}

public class 子类 extends 父类 {……}
```

>[!hint] 什么时候使用继承 ？
>当 A 和 B 两个类有包含关系时

>[!hint] 作用
>- 提高代码的复用性
>- 提高了代码的<u>维护性</u>【修改一处可变多处】
>- 削弱了子类的独立性

# 继承中的特点
- ***在访问子类的构造方法之前，会先访问父类的无参构造方法***
- 方法重写
```java
public class fu{                  //父类
	public void winbee(){
		System.out.println("123");
	}
}
```
```java
public class zi extends fu {         //子类
	public void winbee(){                     //子类重写了winbee()方法
		super.winbee();                       //调用父类的winbee()方法
		System.out.println("456");
	}
}
```

- 父类的私有方法，子类是不能重写的
- 方法重写里子类方法的访问权限不能比父类低（public>默认>private）
- ***无法多继承，但可以多层继承（子extends父，父extends爷）***

>[!attention] 为什么Java不允许多继承 ？
>因为会出现”致命方块“问题
>![400](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202403201513574.png)
>***如果有一个eat()方法，从动物类一直继承到了马类，驴类。那当骡子类调用eat()方法的时候，那是调用马的还是驴的？***

# 两个关键字
## this
>`this` 表示的是当前类

```java
public class student {
    private int age;

    public void setAge(int a) {
		this.age = a;  // 当前类的 age
    }
}
```
## super
>表示的是父类

```java
public class student extends fu{
    private int age;

    public void setAge(int a) {
		super.age = a;  // 父类的 age
    }
}
```

# 拓展和应用
## 多态
```java
animal a = new cat();
```

### 使用前提
- 有继承或实现关系
- 有方法重写
- 有父类引用指向子类对象： `animal a = new cat();`

### 如何使用
- 多态对象的变量看引用名【父类】
- 多态对象的方法，**编译看引用名，运行看 new 出来的对象**
```java
public class fu {          //父类
    int age = 1;  
  
    public void winbee() {  
        System.out.println("123");  
    }  
}
```

```java
public class zi extends fu {           //子类
    int age = 2;  
  
    public void winbee() {         //子类重写了winbee()方法  
        System.out.println("456");  
    }  
}
```

```java
public class demo {         //测试类
    public static void main(String[] args) {  
        fu fz = new zi();  
        System.out.println(fz.age);     //访问的是父类的age，输出父类的age
        fz.winbee();      //访问的是父类的winbee()方法，输出的是子类的winbee()方法
    }                     
}

---
1
456
```

>[!hint] 编译器根据引用类型【animal】来判断有哪些方法可以调用，而不是对象实体【cat】

### 向下转型
>向下转型，可以访问父类中没有，子类中有的方法
```java
public static void main(String[] args) {  
    animal a = new cat(); 
    cat c = (cat) a;  // 向下转型
    c.play();
}
```

### 作用
#### 让结构更加清晰
我们来写一个俄罗斯方块游戏：
- 首先我们知道，我们需要一个房子，这个房子里有方块，方块接触到地面或者碰到其他方块会停下来
- 然后房子上会出现另一个方块，在下落的过程中你可以翻转，如果好的话，可以减少几行
- 方块有 6 种，它们的形态各异

>[!hint] 解决办法 1
>我们可以在一个方块类中写上 6 种方块的翻转方法，但是**你可能要在一个方块类中写上几千行代码，这明显不好**

>[!hint] 解决办法 2
>我们也可以一个方块类中写上一个空的翻转方法，然后在 6 个子类中重写翻转方法，这样**结构清晰，子类长条方块也是方块，子类正方形方块也是方块。而且方块类中可能有各种方块的共有参数**


#### 类元素数组
```java
Animal animals = new Animal[3];     //数组里是animal的子类对象
animals[0] = new Dog();
animals[1] = new Cat();
animals[2] = new Wolf();

for(animal a : animals){
	a.eat();
	a.play();
}
```

## 抽象类
>没有方法体的方法叫 “抽象方法”，有抽象方法的类叫 “抽象类”【要使用 `abstract` 声明】

```java
public abstract class animal {    //抽象类
	public abstract void eat();     //抽象方法
}
```

### 特点
- 子类继承抽象类时，必须重写该抽象方法
- 抽象类不能实例化，**但是可以通过一个非抽象的子类来间接实例化**

### 作用
- 抽象方法的意义在于**定义一个接口或协议，之后的子类必须实现这些抽象方法，这个协议可以确保所有的子类都具有某种同类型的特征**

- 结构清晰【当别人看到一个类是抽象类时，就会很关心它的抽象方法。也会知道一定会有子类去重写这个抽象方法。而且会去找引用，一定有多态的体现】
>根据多态的俄罗斯方块例子我们知道，方块类里的翻转方法并不重要【因为它一定会被重写】。那竟然是空方法的话，我们就可以把它写成抽象方法，把方块类写成抽象类

- 引起重视
>把那些像东西一样差不多的类写成抽象类，而像水杯一样的类就会不抽象，前后形成反差，引起重视

- 顺应继承的逻辑
>如果不用抽象类，继续用普通类的多态。那么我们就可以实例化出一个方块类对象，**但是根据继承的逻辑来说，”方块是方块“，这就很奇怪，所以我们让方块类抽象化（让它不能被实例化）**


























