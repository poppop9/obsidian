
# 线程池
>[!quote] 线程池
>线程池 是一种利用池化技术思想来实现的线程管理技术，是将提前创建好的线程对象放入到一个池子，任务来了可以直接获取，
>
>- 解耦了线程的创建和任务的执行
>- 不用频繁地创建和销毁进程
>- 便于统一管理线程对象
>- 可以控制最大的并发数

```mermaid
graph LR;
	subgraph 线程池
		a[线程对象1]
		b[线程对象2]
		c[线程对象3]
	end

	d[任务1]--获取-->a
	e[任务2]--获取-->b
	f[任务3]--获取-->c

	subgraph 任务等待队列
		h[任务5]
		g[任务4]
	end

	任务等待队列-.-等待获取-.->线程池
```



# 线程安全
>[!quote] 线程安全
>线程安全 指的是允许多个执行线程能够安全访问同一内存区域，无需担心并发执行时，各个线程操作相互干扰

- 互斥锁 / 悲观锁：当线程 1 拿到某个数据时，将这个数据上锁，此时线程 2 更改数据就要等待锁释放才行，

锁的获取和释放是有一定开销的

- CAS / 乐观锁：


---

>[!quote] 乐观锁
>>乐观锁 就是<u>假设多个线程在同一数据上的操作通常不冲突</u>【~~所以叫乐观~~】，所以不对数据加锁，而是在提交更新时，会检查数据在读取后是否被其他线程修改过，如果当前线程在修改数据后发现该数据被其他线程修改过，则当前进程所做的操作无效【~~数据是 a，线程 A 将数据修改为 b，在提交时发现数据被修改为 c，那此时回滚线程 A 的操作，所以最后数据会是 c~~】，<u>可能某些系统会重新执行修改操作</u>
>
>- 乐观锁通常使用版本号或者时间戳来检测数据是否在读取和更新之间发生了变化
>- **所以乐观锁适合在冲突不频繁的系统环境中**

>[!quote] 悲观锁
>悲观锁 就是假设多个线程在同一数据上会发生冲突，所以对数据进行加锁，直到锁释放，才允许其他线程 <u>读取 / 修改</u>
>
>- **悲观锁更适合冲突较频繁，或数据一致性要求高的系统环境中**

在高并发的情况下，因为有很多事务可能在同一时间点上尝试获取同一个资源的锁，所以使用悲观锁可能导致性能问题


