# 接口
> [!quote] 接口
>>接口就是一种公共的规范标准，只要符合规范，大家通用，***接口默认是抽象类***
>
> ```
> public interface jumping {
> 	……
> }
> ```

## 接口的使用
> 用 `implements`，而不是 extends

```
public class cat implements jumping {  
	……
}
```
## 特点
- 接口中的变量都被final修饰
>可以提高程序性能（因为常量在编译时就已经确定了）

- 接口中的变量都被static修饰
>被static修饰表明了接口就是公共的规范标准

- 类与接口之间的关系是实现，可以多实现

- 接口之间的关系是继承，***而且可以多继承***
```
public interface inter1 extends inter2,inter3 {
	……
}
```

> [!hint] 为什么 `public` 在接口中是冗余的
> 因为在接口中，方法和属性默认就是 `public` 的【因为接口的目的是定义行为和规范，而不是实现细节】

## 作用
>可以在不改变整体继承结构的前提下，实现对类的统一管理

例如有个 `animal` 类，马、猫、狗、`猴子继承了animal` 类。现在要增加一个宠物的行为，我们有三种办法：
- 在 `animal` 里定义宠物 `method()`，但是马、猴子不是宠物，但是还是继承到了宠物方法，这样不好
- 在猫类里定义一个宠物 `method()`，在狗类里也定义一个宠物 `method()`，但是这样就没有统一管理了
- 重新定义一个宠物接口，让猫、狗都实现它

# 内部类
```java
public class out {
	public class in {
	}
}
```

- 内部类可以直接访问外部类的成员【**包括私有**】
- 外部类不能直接访问内部类的成员【需要创建对象】

## 成员内部类
>成员内部类 在外部类的方法外

```java
public class OutClass {
	public void test() {
		……
	}

	class InnerClass {
		……
	}
}
```

>[!hint] 成员内部类不能包含静态成员【变量，方法】
>成员内部类是依赖于外部类的实例的，所以成员内部类中的属性和行为也是依赖于外部类的实例的。
>
>但是，如果将成员内部类中的属性和方法声明为静态，那又是不依赖于外部类实例的。
>
>这就产生了矛盾。


在成员内部类的上下文中，它无法直接访问外部类的静态成员。这是因为静态成员不依赖于外部类的实例，可以在没有外部类对象的情况下访问。

另外，成员内部类的实例保存了对外部类对象的隐式引用。如果允许成员内部类包含静态成员，那么这些静态成员将与外部类对象无关，无法确定它们应该与哪个外部类实例关联。这会导致潜在的混乱和不一致性。

总结一下，成员内部类由于与外部类对象相关联，不能包含静态成员。如果需要在内部类中使用静态成员，应该将内部类声明为静态内部类。静态内部类与外部类对象无关，可以包含静态成员，并且不持有对外部类对象的引用。


## 局部内部类
>在外部类的方法中


## 匿名内部类









































