# 接口
> [!quote] 接口
>>接口就是一种公共的规范标准，只要符合规范，大家通用，***接口默认是抽象类***
>
> ```
> public interface jumping {
> 	……
> }
> ```

## 接口的使用
> 用 `implements`，而不是 extends

```
public class cat implements jumping {  
	……
}
```
## 特点
- 接口中的变量都被final修饰
>可以提高程序性能（因为常量在编译时就已经确定了）

- 接口中的变量都被static修饰
>被static修饰表明了接口就是公共的规范标准

- 类与接口之间的关系是实现，可以多实现

- 接口之间的关系是继承，***而且可以多继承***
```
public interface inter1 extends inter2,inter3 {
	……
}
```

> [!hint] 为什么 `public` 在接口中是冗余的
> 因为在接口中，方法和属性默认就是 `public` 的【因为接口的目的是定义行为和规范，而不是实现细节】

## 作用
>可以在不改变整体继承结构的前提下，实现对类的统一管理

例如有个 `animal` 类，马、猫、狗、`猴子继承了animal` 类。现在要增加一个宠物的行为，我们有三种办法：
- 在 `animal` 里定义宠物 `method()`，但是马、猴子不是宠物，但是还是继承到了宠物方法，这样不好
- 在猫类里定义一个宠物 `method()`，在狗类里也定义一个宠物 `method()`，但是这样就没有统一管理了
- 重新定义一个宠物接口，让猫、狗都实现它

# 内部类
```java
public class out {
	public class in {
	}
}
```

- 内部类可以直接访问外部类的成员【**包括私有**】
- 外部类不能直接访问内部类的成员【需要创建对象】

## 成员内部类
>成员内部类 在外部类的方法外

```java
public class OutClass {
	public void test() {
		……
	}

	class InnerClass {
		……
	}
}
```

>[!hint] 非静态的成员内部类 不能包含 静态成员【变量，方法】
>成员内部类是依赖于外部类的实例的，所以成员内部类中的属性和行为也是依赖于外部类的实例的。
>
>但是，如果将成员内部类中的属性和方法声明为静态，那又是不依赖于外部类实例的。
>
>这就产生了矛盾。

## 局部内部类
>局部内部类在外部类的方法中

```java
public class Animal {
	public static void bellow() {
		final class Dog {
			……
		}
	}
}
```

>[!hint] 局部内部类 不能被 权限修饰符修饰

## 匿名内部类









































