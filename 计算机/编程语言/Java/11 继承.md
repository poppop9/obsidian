#计算机/编程语言/Java 
# 🌕什么是继承？
```
public class 子类 extends 父类 {……}
```
>子类也叫***派生类***，父类也叫***基类***或***超类***

>继承可以使子类具有***父类***的属性和方法，还可以在子类中***重新定义***，追加属性和方法

# 🌕什么时候用？
>当 A 和 B 两个类有包含关系时

# 🌕作用
- [x] 提高代码的复用性
- [x] 提高了代码的维护性[^1]
- [x] 削弱了子类的独立性

[^1]:修改一处可变多处

# 🌕继承中的特点
- [x]  ***在访问子类的构造方法之前，会先访问父类的无参构造方法***
- [x]  方法重写
```java
public class fu{                  //父类
	public void winbee(){
		System.out.println("123");
	}
}
```
```java
public class zi extends fu {         //子类
	public void winbee(){                     //子类重写了winbee()方法
		super.winbee();                       //调用父类的winbee()方法
		System.out.println("456");
	}
}
```

- [x]  父类的私有方法，子类是不能重写的
- [x]  方法重写里子类方法的访问权限不能比父类低（public>默认>private）
- [x]  ***无法多继承，但可以多层继承（子extends父，父extends爷）***
>[!attention] 为什么Java不允许多继承？
>因为会出现”致命方块“问题
>![[Excalidraw/计算机/编程语言/Java/继承 Draw.md#^group=H19KgXiC632xzXJSj-aZe|350]]
>***如果有一个eat()方法，从动物类一直继承到了马类，驴类。那当骡子类调用eat()方法的时候，那是调用马的还是驴的？***


# 🌕拓展和应用
## 🌗多态
```
animal a = new cat();
```

#####🌑使用前提
- [x] 有继承或实现关系
- [x] 有方法重写
- [x] 有父类引用指向子类对象

#####🌑如何使用？
- [x] 多态对象的变量看引用名（父类）
- [x] 多态对象的方法，***编译看引用名，运行看new出来的对象***
```java
public class fu {          //父类
    int age = 1;  
  
    public void winbee() {  
        System.out.println("123");  
    }  
}
```
```java
public class zi extends fu {           //子类
    int age = 2;  
  
    public void winbee() {         //子类重写了winbee()方法  
        System.out.println("456");  
    }  
}
```
```java
public class demo {         //测试类
    public static void main(String[] args) {  
        fu fz = new zi();  
        System.out.println(fz.age);     //访问的是父类的age，输出父类的age
        fz.winbee();      //访问的是父类的winbee()方法，输出的是子类的winbee()方法
    }                     
}


1
456
```

#####🌑向下转型
>访问animal中没有，而cat中有的方法
```java
public static void main(String[] args) {  
    animal a = new cat(); 
    cat c = (cat) a;
    c.play();
}
```
***编译器根据引用类型（animal）来判断有哪些方法可以调用，而不是对象实体（cat）***

#####🌑作用
- [x] 让结构更加清晰
>[!example]
>我们来写一个俄罗斯方块游戏！
>- 首先我们知道，我们需要一个房子，这个房子里有方块，方块接触到地面或者碰到其他方块会停下来
>- 然后房子上会出现另一个方块，在下落的过程中你可以翻转，如果好的话，可以减少几行
>- 方块有 6 种，它们的形态各异
>
>>我们可以在一个方块类中写上 6 种方块的翻转方法
>>>***你可能要在一个方块类中写上几千行代码，这明显不好***
>
>>我们也可以一个方块类中写上一个空的翻转方法，然后在 6 个子类中重写翻转方法
>>>***结构清晰，子类长条方块也是方块，子类正方形方块也是方块。而且方法类中可能有各种方块的共有参数***

- [x] 类元素数组
```java
Animal animals = new Animal[3];     //数组里是animal的子类对象
animals[0] = new Dog();
animals[1] = new Cat();
animals[2] = new Wolf();

for(animal a:animals){
	a.eat();
	a.play();
}
```


## 🌗抽象类
```
public abstract class animal {    //抽象类
	public abstract void eat();     //抽象方法
}
```

#####🌑特点
- [x] 子类继承抽象类时，必须重写该抽象方法
- [x] 抽象类不能实例化，***但是可以通过一个非抽象的子类来间接实例化***

#####🌑作用
- [x] 抽象方法的意义在于定义一个接口或协议，之后的子类必须实现这些抽象方法，这个协议可以确保所有的子类都具有某种同类型的特征

- [x] 结构清晰（当别人看到一个类是抽象类时，就会很关心它的抽象方法。也会知道一定会有子类去重写这个抽象方法。而且会去找引用，一定有多态的体现。）
>根据多态的俄罗斯方块例子我们知道，方块类里的翻转方法并不重要（因为它一定会被重写）。那竟然是空方法的话，我们就可以把它写成抽象方法，把方块类写成抽象类

- [x] 引起重视
>把那些像东西一样差不多的类写成抽象类，而像水杯一样的类就会不抽象，前后形成反差，引起重视

- [x] 顺应继承的逻辑
>如果不用抽象类，继续用多态。那么我们就可以实例化出一个方块类对象，***但是根据继承的逻辑来说，”方块是方块“，这就很奇怪，所以我们让方块类抽象化（让它不能被实例化）***


























