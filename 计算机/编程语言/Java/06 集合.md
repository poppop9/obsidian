---
tags:
  - 计算机/编程语言/Java
---
> [!warning] 为什么要引入集合?
> 数组的长度无法改变,所以我们用到了集合
# Collection
```
public interface Collection<E> extends Iterable<E>
```

> [!summary]
> `add("hello");`    添加元素
> `remove("hello");`    删除元素
> `clear();`    清空集合中的元素
> `contains("hello");`    判断集合中是否有指定元素
> `isEmpty();`    判断集合是否为空
> `size();`     判断集合中元素的个数

>[!hint] 创建Collection对象并使用
> ```java
> public class collection {  
>     public static void main(String[] args) {  
>         Collection\<String> c1 = new ArrayList\<>();  
>   
>         String s1 = "绿坦";  
>         String s2 = "kite";  
>   
>         c1.add(s1);  
>         c1.add(s2);  
>   
>         System.out.println(c1);  
>     }  
> }
> 
> ---
> [绿坦, kite]
> ```


>[!hint] Collection集合的遍历
>- Iterator迭代器
>> `next();`  返回迭代中的下一个元素
>> `hasNext();`   判断next()之后是否还有元素
> ```java
> public static void main(String[] args) {  
> 	Collection\<String> c1 = new ArrayList<>();  
>   
> 	String s1 = "绿坦";  
> 	String s2 = "kite";  
>   
> 	c1.add(s1);  
> 	c1.add(s2);  
>   
> 	Iterator\<String> i1 = c1.iterator();  
>   
> 	while (i1.hasNext()) {  
> 		String s = i1.next();  
> 		System.out.println(s);  
> 	}  
> }
> 
> --
> 绿坦
> kite
> ```
> ---
> - 增强for【***内部原理也是一个迭代器***】
> ```java
> int arr[] = {1, 2, 3};  
> for (int i : arr) {  
>     System.out.println(i);  
> }
> 
> --
> 1
> 2
> 3
> ```



## List
>[!hint] List集合的特点就是索引

```
public interface List<E> extends Collection<E>
```

>[!summary]
>`add(索引,数值);`   在集合中指定位置添加元素
>`get(索引);`   返回指定元素
>`set(索引,数值);`   修改指定索引处的元素

```java
List<String> list = new ArrayList<>();  
  
list.add(0, "李白");  
  
list.set(0, "杜甫");  
String s1 = list.get(0);  
  
System.out.println(s1);

---
杜甫
```

>[!hint] 向集合中一次性添加多个元素
> ```java
> psvm {
> 	List\<String> list = List.of("hello","world","!!!");
> }
> ```
> >用 `List.of(……)` 生成的集合不能添加，修改，删除元素

- ListIterator迭代器
```
public interface ListIterator<E> extends Iterator<E>
```

>[!summary]
>[hasPrevious](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ListIterator.html#hasPrevious())()   判断previous()是否遍历完成
>[previous](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ListIterator.html#previous())()   从后向前一个一个遍历

```java
public static void main(String[] args) {  
	List<String> list = new ArrayList<>();  

	list.add("李白");  
	list.add("杜甫");  
	list.add("王维");  

	ListIterator lstitrt = list.listIterator();  

	while (lstitrt.hasNext()) {  
		System.out.print(lstitrt.next());  
	}  

	System.out.println("");  
	System.out.println(" ");  

	while (lstitrt.hasPrevious()) {  
		System.out.print(lstitrt.previous());  
	}  
}  

---
李白杜甫王维
王维杜甫李白
```

>[!hint] 如果不使用next()方法，直接使用previous()方法，会导致什么也不打印。因为实现遍历的背后原理是指针。没有向后遍历的基础，向前遍历指针指向集合的最开始，所以不会有结果

```java
public static void main(String[] args) {  
    List<String> list = new ArrayList<>();  
  
    list.add("李白");  
    list.add("杜甫");  
    list.add("王维");  
  
    ListIterator lstitrt = list.listIterator();  
  
    while (lstitrt.hasPrevious()) {  
        System.out.print(lstitrt.previous());  
    }  
}

---
NULL
```

***以下代码会报出异常，这是由于在迭代时使用List集合的`add`方法改变集合导致的（因为这样不好定义迭代结果），如果一定要在迭代时改变集合元素，请使用ListIterator的`add`方法***
```java
public static void main(String[] args) {  
    List<String> list = new ArrayList<>();  
  
    list.add("李白");  
    list.add("杜甫");  
  
    ListIterator<String> lstitrt = list.listIterator();  
  
    while (lstitrt.hasNext()) {  
        String s = lstitrt.next();  
        if (s.equals("杜甫")) {  
            list.add("王安石");  
        }  
    }  
}

---
Exception in thread "main" java.util.ConcurrentModificationException
```

### ArrayList
>基于动态数组实现的List

```
public class ArrayList<E> extends AbstractList<E>
implements List<E>, RandomAccess, Cloneable, Serializable
```

### LinkedList
>基于链表实现的List

```
public class LinkedList<E> extends AbstractSequentialList<E>
implements List<E>, Deque<E>, Cloneable, Serializable
```

>[!summary]
>`addFirst(e)`   在该列表的开头插入e元素
>`addLast(e)`   在该列表的末尾插入e元素
>`getFirst()`   返回此列表中的第一个元素
>`getLast()`   返回此列表中的最后一个元素
>`removeFirst()`   删除并返回第一个元素
>`removeLast()`   删除并返回最后一个元素
### Vector
>Vector是一个线程安全集合。不过我们需要线程安全时也不常使用它，我们一般使用synchronizedList()方法

```
public class ArrayList<E> extends AbstractList<E> 
implements List<E>, RandomAccess, Cloneable, Serializable
```

```
List<String> list=Collections.synchronizedList(new ArrayList<>());
```

## Set
```
public interface Set<E> extends Collection<E>
```

### HashSet
```
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, Serializable
```

- HashSet对集合的迭代顺序没有保证
	```java
	public static void main(String[] args) {  
	    HashSet<String> hxs = new HashSet<>();  
	  
	    hxs.add("李白");  
	    hxs.add("杜甫");  
	    hxs.add("辛弃疾");  
	  
	    for (String s : hxs) {  
	        System.out.println(s);  
	    }  
	}


	辛弃疾
	李白
	杜甫
	```


- HashSet的底层数据结构是哈希表
	- 什么是哈希值？

		>在java及大多数面向对象的语言中，每一个对象都有属于自己的***hashcode***，<mark style="background: #D2B3FFA6;">这个hashcode是区分不同对象的重要标识</mark>，无论对象自身的类型是什么，它们的hashcode都是一个***整型变量***,需要注意的是<mark style="background: #D2B3FFA6;">hashcode不是内存地址</mark> #哈希值

		>hashcode()是定义在Object类里的方法（意味着所有的类都可以调用），它将返回一个整型值
		
	- 什么是Hash容器？
		>Hash容器[^1]可以根据Hashcode定位到相应的对象（即hashcode不同，两个对象不同）
	```java
	public static void main(String[] args) {  
	    students s1 = new students("李白");    
	    students s2 = new students("李白");    
	    students s3 = new students("辛弃疾");    
	  
	    System.out.println(s1.hashCode());  //2093631819  
	    System.out.println(s2.hashCode());  //2074407503  
	    System.out.println(s3.hashCode());  //999966131  
	    System.out.println("重地".hashCode());  //1179395  
	    System.out.println("通话".hashCode());  //1179395  
	  
	    System.out.println("java".hashCode());  //3254818  
	    System.out.println("hello".hashCode());  //99162322  
	    System.out.println("java".hashCode());  //3254818  
	}
	```
	这两个是***哈希冲突*** 
	```java
	System.out.println("重地".hashCode());  //1179395  
	System.out.println("通话".hashCode());  //1179395
	```

[^1]:Hash容器：HashSet，HashMap，HashTable, ConcurrentHashMap

- 为什么HashSet集合可以保证元素的唯一性？
	>![700](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202403201515043.png)

- 比较对象时，需要重写hashcode()和equals()方法
	- 没有重写时
	```java
	public static void main(String[] args) {  
	    HashSet<students> hs = new HashSet<students>();  
	  
	    students s1 = new students(12, "吴彦祖");  
	    students s2 = new students(12, "陈冠希");  
	    students s3 = new students(12, "吴彦祖");  
	    students s4 = new students(23, "刘德华");  
	  
	    hs.add(s1);  
	    hs.add(s2);  
	    hs.add(s3);  
	    hs.add(s4);  
	  
	    for (students s : hs) {  
	        System.out.println(s.getAge() + s.getName());  
	    }  
	}
	
	
	23刘德华
	12吴彦祖
	12吴彦祖          //打印了两个吴彦祖，说明哈希表认为s1和s3是不同对象
	12陈冠希
	```

	- 重写后
	```java
	public class students {  
	    private int age;  
	    private String name;  
	  
	    public students(int age, String name) {  
	        this.age = age;  
	        this.name = name;  
	    }  
	  
	    public int getAge() {  
	        return age;  
	    }  
	    public void setAge(int age) {  
	        this.age = age;  
	    }  
	    public String getName() {  
	        return name;  
	    }  
	    public void setName(String name) {  
	        this.name = name;  
	    }  
	  
	    @Override  
	    public boolean equals(Object o) {  
	        if (this == o) return true;  
	        if (o == null || getClass() != o.getClass()) return false;  
	  
	        students students = (students) o;  
	  
	        if (age != students.age) return false;  
	        return name != null ? name.equals(students.name) : students.name == null;  
	    }  
	  
	    @Override  
	    public int hashCode() {  
	        int result = age;  
	        result = 31 * result + (name != null ? name.hashCode() : 0);  
	        return result;  
	    }  
	}
	```
	```java
	public class collection {  
	    public static void main(String[] args) {  
	        HashSet<students> hs = new HashSet<students>();  
	  
	        students s1 = new students(12, "吴彦祖");  
	        students s2 = new students(12, "陈冠希");  
	        students s3 = new students(12, "吴彦祖");  
	        students s4 = new students(23, "刘德华");  
	  
	        hs.add(s1);  
	        hs.add(s2);  
	        hs.add(s3);  
	        hs.add(s4);  
	  
	        for (students s : hs) {  
	            System.out.println(s.getAge() + s.getName());  
	        }  
	    }  
	}
	
	
	12吴彦祖
	12陈冠希
	23刘德华
	```



#### LinkedHashSet
```
public class LinkedHashSet<E> extends HashSet<E>
implements Set<E>, Cloneable, Serializable
```
>底层是哈希表和链表

- LinkedHashSet可以预测迭代顺序



### TreeSet
>TreeSet是一种有序集合，因此它要求集合中的元素必须是可比较的。所以TreeSet中的元素必须***实现Comparable接口***或者***在创建TreeSet时提供一个Comparator比较器对象***

```
public class TreeSet<E> extends AbstractSet<E>
implements NavigableSet<E>,Cloneable,Serializable
```

>[!summary]
>`TreeSet()`   无参构造，***元素按照自然排序***
>`TreeSet(Comparator c)`   带参构造，***根据指定的比较器进行排序***

- 实现Comparable接口的无参构造
	- 元素为Integer
		```java
		public static void main(String[] args) {  
		    TreeSet<Integer> ts = new TreeSet<Integer>();  //这里的元素用了Integer，而不是int
		                                            //是因为Integer实现了Comparable接口，int没有
		    ts.add(190);  
		    ts.add(33);  
		    ts.add(77);  
		  
		    for (Integer i : ts) {  
		        System.out.println(i);  
		    }  
		}
		
		
		33
		77
		190
		```
	- 元素为students，return 0;
		```java
		public class students implements Comparable<students>{  
		    private int age;  
		    private String name;  
		  
		    public students(int age, String name) {  
		        this.age = age;  
		        this.name = name;  
		    }  
		  
		    public int getAge() {return age;}  
		    public void setAge(int age) {this.age = age;}  
		    public String getName() {return name;}  
		    public void setName(String name) {this.name = name;}  
		  
		    @Override  
		    public int compareTo(students o) {  
		        return 0;  //首先添加s1，添加s2的时候返回0（表示s2的元素和s1相同），不存储
		    }  
		}
		```
		```java
		public class collection {  
		    public static void main(String[] args) {  
		        TreeSet<students> ts = new TreeSet<students>();  
		  
		        students s1 = new students(12, "吴彦祖");  
		        students s2 = new students(23, "陈冠希");  
		        students s3 = new students(42, "刘德华");  
		        students s4 = new students(12, "吴彦祖");  
		  
		        ts.add(s1);  
		        ts.add(s2);  
		        ts.add(s3);  
		        ts.add(s4);  
		  
		        for (students s : ts) {  
		            System.out.println(s.getAge() + s.getName());  
		        }  
		    }  
		}


		12吴彦祖
		```
	- 元素为students，return 1;
		```java
		public class students implements Comparable<students>{  
		    private int age;  
		    private String name;  
		  
		    public students(int age, String name) {  
		        this.age = age;  
		        this.name = name;  
		    }  
		  
		    public int getAge() {return age;}  
		    public void setAge(int age) {this.age = age;}  
		    public String getName() {return name;}  
		    public void setName(String name) {this.name = name;}  
		  
		    @Override  
		    public int compareTo(students o) {  
		        return 1;  //首先存s1，存s2时返回1（表示s2大于s1），s2存在s1之后
		    }  
		}


		12吴彦祖
		23陈冠希
		42刘德华
		12吴彦祖
		```
	- 元素是students，灵活return;
		```java
		public class students implements Comparable<students>{  
			private int age;  
			private String name;  
		  
			public students(int age, String name) {  
				this.age = age;  
				this.name = name;  
			}  
		  
			public int getAge() {return age;}  
			public void setAge(int age) {this.age = age;}  
			public String getName() {return name;}  
			public void setName(String name) {this.name = name;}  
		  
			@Override  
			public int compareTo(students o) {  
				int i = this.age - o.age;  
				return i;
			}  
		}
		
		
		12吴彦祖
		23陈冠希
		42刘德华
		```

- 提供Comparator比较器对象的带参构造
	```java
	public class collection {  
	    public static void main(String[] args) {  
	        TreeSet<students> ts = new TreeSet<students>(new Comparator<students>() {  
	            @Override  
	            public int compare(students o1, students o2) {  
	                int sum = o1.getAge() - o2.getAge();  
	                return sum;  
	            }  
	        });                        //此处为匿名内部类，是Comparator接口的实现类对象
	  
	        students s1 = new students(12, "吴彦祖");  
	        students s2 = new students(23, "陈冠希");  
	        students s3 = new students(42, "刘德华");  
	        students s4 = new students(12, "吴彦祖");  
	  
	        ts.add(s1);  
	        ts.add(s2);  
	        ts.add(s3);  
	        ts.add(s4);  
	  
	        for (students s : ts) {  
	            System.out.println(s.getAge() + s.getName());  
	        }  
	    }  
	}
	
	
	12吴彦祖
	23陈冠希
	42刘德华
	```


# Map
```
public interface Map<K,V>
```
K表示key，V表示value
***不能有重复的key，每个key最多映射到一个值***

>[!summary]
>`put(K key,V value)`   添加元素
>`remove(Object key)`   根据键删除键值对元素
>`clear()`   移除所有键值对元素
>
>`boolean containsKey(Object key)`   判断集合是否包含指定的键
>`boolean containsValue(Object value)`   判断集合是否包含指定的值
>`boolean isEmpty()`   判断集合是否为空
>
>`int size()`   返回集合的长度
>
>`V get(Object key)`   根据键获取值
>`keySet()`   返回一个所有键的Set集合
>`values()`   返回一个所有值的Collection集合
>`entrySet()`   返回一个 Set 集合，这个集合的元素是 Map 集合，Set\<Map.Entry\<String, Integer>>

- 获取方法的具体实现
	```java
	public static void main(String[] args) {  
	    Map<Integer, String> m = new HashMap<Integer, String>();  
	    m.put(12, "吴彦祖");  
	    m.put(23, "彭于晏");  
	    m.put(12, "郭富城");  
	  
	    System.out.println(m.get(12));  
	    System.out.println(m.get(34));  
	    System.out.println(m.keySet());  
	    System.out.println(m.values());  
	    System.out.println(m.entrySet());  
	}
	
	
	郭富城
	null
	[23, 12]
	[彭于晏, 郭富城]
	[23=彭于晏, 12=郭富城]
	```

- 遍历的具体实现
	- 遍历所有key，再根据key找到对应的value
		```java
		public static void main(String[] args) {  
		    Map<Integer, String> m = new HashMap<Integer, String>();  
		    m.put(12, "吴彦祖");  
		    m.put(23, "彭于晏");  
		    m.put(34, "郭富城");  
		  
		    Set<Integer> set = m.keySet();  
		    for (int key : set) {  
		        String value = m.get(key);  
		        System.out.println(key + ":" + value);  
		    }  
		}
		
		
		34:郭富城
		23:彭于晏
		12:吴彦祖
		```

	- 获取所有键值对的对象集合，然后遍历集合里的每个对象
		```java
		public static void main(String[] args) {  
		    Map<Integer, String> m = new HashMap<Integer, String>();  
		    m.put(12, "吴彦祖");  
		    m.put(23, "彭于晏");  
		    m.put(34, "郭富城");  
		  
		    Set<Map.Entry<Integer, String>> set = m.entrySet();  
		    for (Map.Entry<Integer, String> me : set) {  
		        System.out.println(me);  
		    }  
		}
		
		
		34=郭富城
		23=彭于晏
		12=吴彦祖
		```


## HashMap
```
public class HashMap<K,V> extends AbstractMap<K,V>
implements Map<K,V>,Cloneable,Serializable
```

```java
HashMap<Integer, String> m = new HashMap<Integer, String>();  
m.put(12, "吴彦祖");  
m.put(23, "彭于晏");  
m.put(34, "郭富城");  
  
System.out.println(m);


{34=郭富城, 23=彭于晏, 12=吴彦祖}
```


## TreeMap
```
public class TreeMap<K,V> extends AbstractMap<K,V>
implements NavigableMap<K,V>,Cloneable,Serializable
```
***可以对key进行排序***


## HashTable
>是线程安全集合

- ***不过我们需要线程安全时一般使用 synchronizedMap()方法***
	```java
	Map<Object,Object> map=Collections.synchronizedMap(new HashMap<>());
	```
	>现在这个map集合就是线程安全集合了


# Collections工具
```
public class Collections extends Object
```

>[!summary]
>`sort()`   将指定的列表升序排列
>`reverse()`   反转指定列表中的元素顺序
>`shuffle()`   把集合里的元素顺序重新随机排列

```java
public static void main(String[] args) {  
    List list = new ArrayList();  
    list.add(30);  
    list.add(10);  
    list.add(100);  
    list.add(70);  
  
    System.out.println(list);  
      
    Collections.sort(list);  
    System.out.println(list);  
      
    Collections.reverse(list);  
    System.out.println(list);  
      
    Collections.shuffle(list);  
    System.out.println(list);  
}


[30, 10, 100, 70]
[10, 30, 70, 100]
[100, 70, 30, 10]
[30, 70, 10, 100]
```


































