# 类
>[!quote] 类
>>类 是具有相同属性和行为的<u>一组对象的集合</u>，是 Java 的基本组成单位
>
>类的组成：
> - 属性：通过**成员变量**【类中方法外的变量，描述类的属性】来体现
> - 行为：通过**成员方法**【描述类的行为的一种方法】来体现

>[!hint] 深入理解类
>类是非常抽象的，需要在其他类中实例化成对象，才能调用其方法【除了静态方法】
>
>**类的实质是一种引用数据类型**，类似于 `byte`，`short`，`int`，`long` 等基本数类。不同的是，他是一种复杂的数据类型（**由于它是数据类型，不是数据，所以不存在于内存中，不能直接被操作，只有被实例化成对象，才变得可操作**）

>[!hint] 判断某个对象是否是某个类的实例
>>使用 `instanceof` 
>
>`if(event instanceof ApplicationReadyEvent)` 检查当前的 `event` 对象是否是  `ApplicationReadyEvent` 类的实例，如果是则返回 `true` ，如果不是则返回 `false`

# 构造方法
>方法名是类名的方法，是用来***创建对象***的

```java
public class Rectangle {  
    private static int width;  
    private static int height;  
    
    //无参构造方法
    public Rectangle(){      
	    //当用无参构造方法创建对象时，就会执行这条语句                     
        System.out.println("我是无参构造方法");      
    }  

	//带参构造方法
    public Rectangle(int width, int height) {         
        this.width = width;  
        this.height = height;  
    }   
}

public class Demo{
	public static void main(String[] args) {  
		// 创建对象，使用对象，()指创建Rectangle类型的对象后，自动调用Rectangle类中的构造方法，来进行成员变量的初始化
		Rectangle r1 = new Rectangle();      //用无参构造方法创建对象
	    Rectangle r2 = new Rectangle(2, 3);    //用带参构造方法创建对象
	    System.out.println(r2.getArea());  
	}
}

---
我是无参构造方法
6
```

## 对象与引用
```java
Rectangle r1 = new Rectangle(); 
```

`new` 出一个对象之后，会把这个对象在内存中的地址返回，通过这个地址就可以找到这个对象，那么我们上面的写法，`Rectangle r1 = new Rectangle(); `，把这个对象在内存中的地址赋值给变量 `r1`，这个 `r1` 就叫做***引用***，或者叫引用变量。而 `new` 出来的东西才是对象

---

>[!hint] 构造方法 发生在<u>实例对象</u>赋值给<u>引用变</u>量之前

>[!hint] 最好把对象的初始化设置在构造函数中，不要设置在构造函数之外的方法里，防止用户忘记调用方法初始化。总的来说，就是不要让用户在没有初始化的情况下取得对象

# 特殊数据类型
>类 其实就是一种数据类型，只不过比较特殊

- 类作为形参，返回值
```java
public void useCat(cat c) {
	c.eat();
}

public cat getCat() {
	cat c = new cat();
	return c;
}
```

>[!hint] 抽象类，接口 都可以作为参数和返回值


# 封装
>将成员变量用 `private` 修饰，使得成员变量只能在本类被<u>直接使用</u>【其他类需要使用，需要本类提供 `get`，`set` 方法】

>[!question] 为什么要多此一举呢？
>因为这样可以有个方法对变量的赋值做判断【比如给年龄赋值不可能是负数，那就可以在 `set` 方法里用 if 条件进行判断】

>[!warning] `get`，`set` 方法的方法名是 <u>“get/set”+首字母大写的变量名</u>

```java
public class student {
    String name;
    private int age;

    public void setAge(int a) {
        if (a < 0 | a > 100) {
            this.age = a;
        } else {
            System.out.println("你输入的年龄有误");
        }
    }

    public String getAge(){
        String a=age+"";       //把int转成String
        System.out.println(a);
        return a;
    }
}
```

```java
public class studentTest {
    public static void main(String[] args){
        student s=new student();
        s.name="大绿坦";
        s.setAge(30);
        s.getAge();
	}
}

---
30
```

>[!hint] 优点
> - 通过方法来控制成员变量的操作，提高了代码的安全性
> - 把对象的实现细节隐藏起来，提高代码的可维护性

# 方法
>[!hint] 方法不能嵌套

## 方法的参数
### 形参
>方法定义中的参数

```
public static void isEven(int number){        //此处的number就是形参
	number++;                        
}  
```
### 实参
>方法调用中的参数

```
isEven(10);        //此处的10就是实参
```

>[!hint] 当我们将 ***基本数据类型*** 作为函数参数传递时，形参的改变不影响实参
>因为基本数据类型在传递过程中是通过值传递的，函数会创建一个形参的副本来进行操作，而不是直接操作原始的实参

>[!hint] 当我们将 ***引用数据类型*** 作为函数参数传递时，形参的改变会影响实参
>因为引用数据类型在传递过程中是通过引用传递的，函数操作的是实参的引用，所以对形参的修改会直接反映在原始的实参

## 方法的定义，调用
```java
// 定义方法
权限修饰符 状态修饰符 返回值 方法名(……方法参数) {
	// 方法体
}

public static void isEvenNumber(int i) {
	// 方法体
}

public static int isEvenNumber1(int i) {
	// 方法体
	return i+1;
}

// 调用方法
方法名(方法参数);

psvm {
	isEvenNumber(1);
}
```


## 方法重载
>在***同一个类中***，有多个具有<u>不同参数</u>【不同类型，或不同数量】，***相同方法名***的方法

```java
public static int sum(int a, int b) {  
    return a + b;  
}  
  
public static double sum(double a, double b) {  
    return a + b;  
}
```






























