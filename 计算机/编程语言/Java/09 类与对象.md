# 类
>具有相同属性和行为的<u>一组对象的集合</u>，是Java的基本组成单位
## 类的组成
### 属性
>通过***成员变量***【类中方法外的变量，描述类的属性】来体现
### 行为
>通过***成员方法***【描述类的行为的一种方法】来体现

>[!hint] 深入理解类
>类是非常抽象的，需要在其他类中实例化成对象，才能调用其方法【除了静态方法】
>
>***类的实质是一种引用数据类型***，类似于 `byte`，`short`，`int`，`long` 等基本数类。不同的是，他是一种复杂的数据类型（***由于它是数据类型，不是数据，所以不存在于内存中，不能直接被操作，只有被实例化成对象，才变得可操作***）
# 构造方法
>方法名是类名的方法，是用来***创建对象***的

```java
public class Rectangle {  
    private static int width;  
    private static int height;  
      
    public Rectangle(){                           //无参构造方法
        System.out.println("我是无参构造方法");      //当用无参构造方法创建对象时，就会执行这条语句
    }  
  
    public Rectangle(int width, int height) {         //带参构造方法
        this.width = width;  
        this.height = height;  
    }   
}

public class Demo{
	public static void main(String[] args) {  
		// 创建对象，使用对象，()指创建Rectangle类型的对象后，自动调用Rectangle类中的构造方法，来进行成员变量的初始化
		Rectangle r1 = new Rectangle();      //用无参构造方法创建对象
	    Rectangle r2 = new Rectangle(2, 3);    //用带参构造方法创建对象
	    System.out.println(r2.getArea());  
	}
}

---
我是无参构造方法
6
```

## 对象与引用
```java
Rectangle r1 = new Rectangle(); 
```

`new` 出一个对象之后，会把这个对象在内存中的地址返回，通过这个地址就可以找到这个对象，那么我们上面的写法，`Rectangle r1 = new Rectangle(); `，把这个对象在内存中的地址赋值给变量 `r1`，这个 `r1` 就叫做***引用***，或者叫引用变量。而 `new` 出来的东西才是对象

---

>[!hint] 构造方法 发生在<u>实例对象</u>赋值给<u>引用变</u>量之前

>[!hint] 最好把对象的初始化设置在构造函数中，不要设置在构造函数之外的方法里，防止用户忘记调用方法初始化。总的来说，就是不要让用户在没有初始化的情况下取得对象
# 封装
>将成员变量用private修饰，使得成员变量只能在本类被直接使用（其他类需要使用，需要本类提供get，set方法）

>[!question] 为什么要多此一举呢？
>因为这样可以有个方法对变量的赋值做判断（比如给年龄赋值不可能是负数，那就可以在set()方法里用if进行判断）

```java
public class student {
    String name;
    private int age;

    public void setAge(int a) {
        if (a < 0 | a > 100) {
            age = a;
        } else {
            System.out.println("你输入的年龄有误");
        }
    }

    public String getAge(){
        String a=age+"";       //把int转成String
        System.out.println(a);
        return a;
    }
}
```
```java
public class studentTest {
    public static void main(String[] args){
        student s=new student();
        s.name="大绿坦";
        s.setAge(30);
        s.getAge();
	}
}


30
```
## 好处
- 通过方法来控制成员变量的操作，提高了代码的安全性
- 把对象的实现细节隐藏起来，提高代码的可维护性

# 方法
>[!hint] 方法不能嵌套

## 方法的参数
### 形参
>方法定义中的参数

```
public static void isEven(int number){        //此处的number就是形参
	number++;                        
}  
```
### 实参
>方法调用中的参数

```
isEven(10);        //此处的10就是实参
```

>[!hint] 对于 ***基本数据类型*** 来说，形参的改变不影响实参
>因为基本数据类型在传递过程中是通过值传递的，函数会创建一个形参的副本来进行操作，而不是直接操作原始的实参

>[!hint] 对于***引用数类*** 来说，形参的改变会影响实参
>因为引用数据类型在传递过程中是通过引用传递的，函数操作的是实参的引用，所以对形参的修改会直接反映在原始的实参

## 方法的定义，调用
```java
// 定义方法
public static void 方法名(……方法参数) {
	// 方法体
}

public static void isEvenNumber(int i) {
	// 方法体
}

// 调用方法
方法名(方法参数);

psvm {
	isEvenNumber(1);
}
```


## 方法重载
>在***同一个类中***，有多个具有<u>不同参数</u>【不同类型，或不同数量】，***相同方法名***的方法

```java
public static int sum(int a, int b) {  
    return a + b;  
}  
  
public static double sum(double a, double b) {  
    return a + b;  
}
```

***Java会通过你所传入的参数来区分要调用的方法***





























