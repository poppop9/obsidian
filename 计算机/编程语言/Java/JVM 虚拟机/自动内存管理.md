# Java 内存区域与内存溢出异常
因为 Java 程序员把控制内存的权力交给了 JVM，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，将会难以排查错误，修正问题

>[!hint] Java 与 C++ 之间有一堵<u>由内存动态分配和垃圾收集技术所围成的</u>高墙，墙外面的人想进去，墙里面的人却想出来
>- 对于 C++的开发者来说，C++ 需要开发者手动地进行内存的分配和释放操作，如果操作不当可能会导致内存泄漏 …… ，而 Java 有自动的垃圾收集机制，开发者不需要过多操心内存管理的细节
>- Java 由于有垃圾收集器，所以也有一些局限性【在某些对性能要求极高，需要更精细控制内存的场景下，Java 的垃圾收集机制可能会带来一些不可预测的暂停，也无法做到极致的内存控制

介绍 Java 虚拟机内存的各个区域，讲解这些区域的作用、服务对象以及其中可能产生的问题

## 运行时的数据区域
![350](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202405160906418.png)

>[!quote] 程序计数器
>>当前线程所执行的字节码的行号指示器，每个线程有一个独立的程序计数器，这些程序计数器互不影响，独立存储，所以是<u>线程私有内存</u>
>
>- 字节码解释器工作时，就是通过改变程序计数器的值来选取下一条需要执行的字节码指令
>
>- 分支、循环、跳转、异常处理、线程恢复 ……基础功能都需要依赖程序计数器来完成

---

>[!quote] 虚拟机栈
>>一个线程对应一个虚拟机栈，在虚拟机栈中有很多个<u>栈帧</u>，一个方法对应一个栈帧【~~当方法被执行时，JVM 都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口~~】，所以虚拟机栈也是<u>线程私有内存</u>
>
>> [!quote] 局部变量表
>> 存放了 Java 中的基本数据类型，对象引用，returnAddress【指向了一条字节码指令的地址】
>> - 局部变量表中，存储空间由局部变量槽来表示。每个变量槽可以容纳一个数据项，对于 64 位长度的 `long` 和 `double`，占用两个变量槽，其余的数据类型只占用一个
>> - 局部变量表的内存空间【~~变量槽的数量~~】在编译期间就已经确定，并且不会再方法运行期间改变，<u>但是每个变量槽的大小由 JVM 判断架构和性能需求确定</u>

- `StackOverflowError` 线程请求的栈深度大于虚拟机所允许的深度
- `OutOfMemoryError` 线程申请栈空间失败了

---

>[!quote] 本地方法栈
>与虚拟机栈服务于 Java 方法不同，本地方法栈服务于本地方法

---

>[!quote] 堆
>>堆 的唯一目的就是存放对象实例【~~但是随着各种优化技术日渐发展，对象实例都分配在堆上也不是那么绝对~~】，在 JVM 启动时创建，<u>被所有线程共享</u>
>
>- 堆可以处于物理上不连续，逻辑上连续的内存空间中，~~但对于大对象【数组对象 ……】，出于实现简单、存储高效的考虑，很可能会要求连续的内存空间~~

---

>[!quote] 方法区
>>方法区 用于存储已被虚拟机加载的<u>类型信息</u>、常量、静态变量、即时编译器编译后的代码缓存 ……，<u>也被所有线程共享</u>
>
>- 方法区不需要连续的内存，还可扩展，甚至还可以选择不实现垃圾收集
>

相对而言，垃圾收集行为在这个区域的确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。

这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。

类型信息是指已加载的类、接口、枚举和注解的结构信息，包括类的字段、方法、父类、接口等。类型信息存储在方法区的运行时常量池中，它提供了对类的结构和行为的描述，可以被虚拟机和程序使用。虚拟机通过类型信息来实例化对象、执行方法调用 ……


- `OutOfMemoryError` 方法区无法满足新的内存分配需求



# 垃圾收集器与内存分配策略





# 虚拟机性能监控



# 故障处理工具


# 调优案例分析


