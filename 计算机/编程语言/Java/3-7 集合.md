
> [!hint] 为什么要引入集合 ?
> 因为数组的长度无法改变，所以我们用到了集合

# ❤ Collection
```
public interface Collection<E> extends Iterable<E>
```

- `add("hello");`    添加元素
- `remove("hello");`    删除元素
- `clear();`    清空集合中的元素
- 判断
	- `contains("hello");`    判断集合中是否有指定元素
	- `containAll(集合B)` 判断集合B的元素，集合A里是否都有
	- `isEmpty();`    判断集合是否为空
- `size();`     判断集合中元素的个数
- 交集，差集
	- `Boolean retainAll(集合2)` 返回集合和集合2的交集，如果集合因调用而更改，则返回 true
	- `removeAll(集合2)` 集合2中的元素，集合中都没有，如果集合因调用而更改，则返回 true

>[!hint] 创建 Collection 对象并使用
> ```java
> public class collection {  
>     public static void main(String[] args) {  
>         Collection\<String> c1 = new ArrayList\<>();  
>   
>         String s1 = "绿坦";  
>         String s2 = "kite";  
>   
>         c1.add(s1);  
>         c1.add(s2);  
>   
>         System.out.println(c1);  
>     }  
> }
> 
> ---
> [绿坦, kite]
> ```

>[!hint] Collection 集合的遍历
>>[!quote] Iterator 迭代器
>> - `next()`  返回迭代中的下一个元素
>> - `hasNext()`   判断 `next()` 之后是否还有元素
> ```java
> public static void main(String[] args) {  
> 	Collection\<String> c1 = new ArrayList<>();  
>   
> 	String s1 = "绿坦";  
> 	String s2 = "kite";  
>   
> 	c1.add(s1);  
> 	c1.add(s2);  
>   
> 	Iterator\<String> i1 = c1.iterator();  
>   
> 	while (i1.hasNext()) {  
> 		String s = i1.next();  
> 		System.out.println(s);  
> 	}  
> }
> 
> --
> 绿坦
> kite
> ```
> 
>>[!quote] 增强 for【原理也是一个迭代器】
> ```java
> int arr[] = {1, 2, 3};  
> for (int i : arr) {  
>     System.out.println(i);  
> }
> 
> --
> 1
> 2
> 3
> ```

## 💛 List
>[!quote] List
>List 集合的特点就是<u>索引</u>
> ```
> public interface List\<E> extends Collection\<E>
> ```

- **静态方法**
	- 【增】
		- `List.of(……)` 向集合中一次性添加元素，生成一个不可变集合

```java
List\<String> list = List.of("hello","world","!!!");
```

---

- **非静态方法**
	- 【增】
		- `add(索引,数值);`   在集合中指定位置添加元素
	- 【改】
		- `set(索引,数值);`   修改指定索引处的元素
	- 【查】
		- `get(索引);`   返回指定元素

```java
List<String> list = new ArrayList<>();  
  
list.add(0, "李白");  
  
list.set(0, "杜甫");  
String s1 = list.get(0);  
  
System.out.println(s1);

---
杜甫
```

---

>[!quote] ListIterator 迭代器
> ListIterator 可以实现双向遍历
> ```
> public interface ListIterator\<E> extends Iterator\<E>
> ```
> - 从后往前遍历
> 	- `hasPrevious()`   判断 `previous()` 是否遍历完成
> 	- `previous()`   从后向前一个一个遍历
>
> ```java
> public static void main(String[] args) {  
> 	List\<String> list = new ArrayList<>();  
> 
> 	list.add("李白");  
> 	list.add("杜甫");  
> 	list.add("王维");  
> 
> 	ListIterator lstitrt = list.listIterator();  
> 
> 	// 从前往后遍历
> 	while (lstitrt.hasNext()) {  
> 		System.out.print(lstitrt.next());  
> 	}  
> 
> 	System.out.println("");  
> 	System.out.println(" ");  
> 
> 	// 从后往前遍历
> 	while (lstitrt.hasPrevious()) {  
> 		System.out.print(lstitrt.previous());  
> 	}  
> }  
> 
> ——
> 李白杜甫王维
> 王维杜甫李白
> ```
> 
> ```java
> List\<String> list = new ArrayList<>();  
> 
> list.add("李白");  
> list.add("杜甫");  
> list.add("王维");  
> 
> ListIterator lstitrt = list.listIterator();  
> 
> while (lstitrt.hasPrevious()) {  
> 	System.out.print(lstitrt.previous());  
> }  
> 
> ——
> NULL
> ```
> 
>>[!warning] 如果不使用 next() 方法，直接使用 previous() 方法，会导致什么也不打印
>>因为实现遍历的背后原理是指针，没有向后遍历的基础，向前遍历指针指向集合的最开始，所以不会有结果

>[!warning] 如果一定要在迭代时改变集合元素，请使用 ListIterator 的 `add` 方法
>以下代码会报出异常，这是由于在迭代时使用 List 集合的 `add` 方法改变集合：
> ```java
> public static void main(String[] args) {  
>     List\<String> list = new ArrayList<>();  
>   
>     list.add("李白");  
>     list.add("杜甫");  
>   
>     ListIterator\<String> lstitrt = list.listIterator();  
>   
>     while (lstitrt.hasNext()) {  
>         String s = lstitrt.next();  
>         if (s.equals("杜甫")) {  
>             list.add("王安石");  
>         }  
>     }  
> }
> 
> ——
> Exception in thread "main" java.util.ConcurrentModificationException
> ```

### ArrayList
>[!quote] `ArrayList`
>ArrayList 是基于动态数组实现的 List
> ```
> public class ArrayList\<E> 
> extends AbstractList\<E>
> implements List\<E>, RandomAccess, Cloneable, Serializable
> ```

### LinkedList
>[!quote] `LinkedList`
>LinkedList 基于双向链表实现的 List
> ```
> public class LinkedList\<E> 
> extends AbstractSequentialList\<E>
> implements List\<E>, Deque\<E>, Cloneable, Serializable
> ```

- **增**
	- `addFirst(e)` 在该列表的开头插入 e 元素
	- `addLast(e)` 在该列表的末尾插入 e 元素
- **删**
	- `removeFirst()` 删除并返回第一个元素
	- `removeLast()` 删除并返回最后一个元素
- **查**
	- `getFirst()` 返回此列表中的第一个元素
	- `getLast()` 返回此列表中的最后一个元素

### Vector
>[!quote] Vector
>Vector 是一个线程安全集合，不过我们需要线程安全时也不常使用它，我们一般使用 `synchronizedList()` 方法
> ```
> public class Vector\<E>
> extends AbstractList\<E>
> implements List\<E>, RandomAccess, Cloneable, Serializable
> ```

- 使用 `synchronizedList()` 方法
```
List<String> list=Collections.synchronizedList(new ArrayList<>());
```

## 💛 Set
>[!quote] Set
>- <u>不能有重复元素</u>
>- 可以有 `NULL` 值
>- 无序
>- 没有索引
>
> ```
> public interface Set\<E> 
> extends Collection\<E>
> ```

- **静态方法**
	- `Set.of(……)` 生成一个不可变 Set 集合
- **非静态方法**
	- 【增】
		- `add(E e)` 添加元素
	- 【删】
		- `remove(E e)` 删除元素
		- `clear()` 清空集合
	- 【查】
		- `size()` 返回集合的元素数
		- `contains(E e)` 判断集合是否有指定元素 

### HashSet
>[!quote] `HashSet`
>`HashSet` 的底层数据结构是哈希表
>
> ```java
> public class HashSet\<E> 
> extends AbstractSet\<E> 
> implements Set\<E>, Cloneable, Serializable
> ```

>[!quote] 哈希值
>每一个对象都有属于自己的 `hashcode`，这个 `hashcode` 是区分不同对象的重要标识，无论对象自身的类型是什么，它们的 `hashcode` 都是一个**整型变量**【~~`hashcode` 不是内存地址~~】

>[!quote] `hashcode()`
>`hashcode()` 是定义在 Object 类里的方法，它将返回一个整型值
>
> ```java
> psvm {  
> 	students s1 = new students("李白");    
> 	students s2 = new students("李白");    
> 	students s3 = new students("辛弃疾");    
>   
> 	System.out.println(s1.hashCode());  //2093631819  
> 	System.out.println(s2.hashCode());  //2074407503  
> 	System.out.println(s3.hashCode());  //999966131  
>   
> 	System.out.println("java".hashCode());  //3254818  
> 	System.out.println("hello".hashCode());  //99162322  
> 	System.out.println("java".hashCode());  //3254818  
> }
> ```

>[!quote] Hash 容器
>Hash 容器可以根据 `hashcode` 定位到相应的对象【~~即 `hashcode` 不同，两个对象不同~~】，Hash 容器有：HashSet，HashMap，HashTable, ConcurrentHashMap

>[!quote] 哈希冲突
>哈希冲突 是在使用 `hashcode()` 时，不同的输入值经过 `hashcode()` 处理后产生了相同的 `hashcode`【~~哈希值~~】，<u>哈希冲突是不可避免的，因为哈希函数将无限的输入映射到有限的输出</u>
>
> ```java
> // "重地" 的 Unicode 编码是 37325 和 22320，计算哈希码得到 37325 * 31 + 22320 = 1179395。
> // "通话" 的 Unicode 编码是 36890 和 35805，计算哈希码得到 36890 * 31 + 35805 = 1179395。
> System.out.println("重地".hashCode());  //1179395  
> System.out.println("通话".hashCode());  //1179395
> ```

---

>[!hint]+ HashSet 对集合的迭代顺序没有保证
> ```java
> public static void main(String[] args) {  
> 	HashSet\<String> hxs = new HashSet<>();  
>   
> 	hxs.add("李白");  
> 	hxs.add("杜甫");  
> 	hxs.add("辛弃疾");  
>   
> 	for (String s : hxs) {  
> 		System.out.println(s);  
> 	}  
> }
> 
> --
> 辛弃疾
> 李白
> 杜甫
> ```

>[!hint]+ 为什么 HashSet 可以保证元素的唯一性 ？
>![700](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202403201515043.png)

>[!hint]+ 比较对象时，需要重写 `hashcode()` 和 `equals()` 方法
>- 没有重写时
>
> ```java
> public static void main(String[] args) {  
> 	HashSet\<students> hs = new HashSet\<students>();  
>   
> 	students s1 = new students(12, "吴彦祖");  
> 	students s2 = new students(12, "陈冠希");  
> 	students s3 = new students(12, "吴彦祖");  
> 	students s4 = new students(23, "刘德华");  
>   
> 	hs.add(s1);  
> 	hs.add(s2);  
> 	hs.add(s3);  
> 	hs.add(s4);  
>   
> 	for (students s : hs) {  
> 		System.out.println(s.getAge() + s.getName());  
> 	}  
> }
> 
> 
> 23刘德华
> 12吴彦祖
> 12吴彦祖  //打印了两个吴彦祖，说明哈希表认为s1和s3是不同对象
> 12陈冠希
> ```
> 
>- 重写后
>
> ```java
> @Data
> @NoArgsConstructor
> @AllArgsConstructor
> public class students {  
> 	private int age;  
> 	private String name;  
>   
> 	@Override  
> 	public boolean equals(Object o) {  
> 		if (this == o) return true;  
> 		if (o == null || getClass() != o.getClass()) return false;  
> 		students students = (students) o;  
>   
> 		if (age != students.age) return false;  
> 		return name != null ? name.equals(students.name) : students.name == null;  
> 	}  
>   
> 	@Override  
> 	public int hashCode() {  
> 		int result = age;  
> 		result = 31 * result + (name != null ? name.hashCode() : 0);  
> 		return result;  
> 	}  
> }
> 
> // 测试类
> public class collection {  
> 	public static void main(String[] args) {  
> 		HashSet\<students> hs = new HashSet\<students>();  
>   
> 		students s1 = new students(12, "吴彦祖");  
> 		students s2 = new students(12, "陈冠希");  
> 		students s3 = new students(12, "吴彦祖");  
> 		students s4 = new students(23, "刘德华");  
>   
> 		hs.add(s1);  
> 		hs.add(s2);  
> 		hs.add(s3);  
> 		hs.add(s4);  
>   
> 		for (students s : hs) {  
> 			System.out.println(s.getAge() + s.getName());  
> 		}  
> 	}  
> }
> 
> 
> 12吴彦祖
> 12陈冠希
> 23刘德华
> ```

#### LinkedHashSet
>[!quote] LinkedHashSet
>LinkedHashSet 底层是哈希表和链表，可以预测迭代顺序
> ```
> public class LinkedHashSet\<E> extends HashSet\<E>
> implements Set\<E>, Cloneable, Serializable
> ```

### TreeSet
>[!quote] TreeSet
>TreeSet 是一种有序集合，要求集合中的元素必须是可比较的，<u>所以 TreeSet 中的元素必须实现 Comparable 接口或者在创建 TreeSet 时提供一个 Comparator 比较器对象</u>
> ```
> public class TreeSet\<E> extends AbstractSet\<E>
> implements NavigableSet\<E>,Cloneable,Serializable
> ```

- `TreeSet()`   无参构造，**元素按照自然排序**
- `TreeSet(Comparator c)`   带参构造，**根据指定的比较器进行排序**

---

- 实现 Comparable 接口的无参构造
	- 元素为 Integer
		```java
		public static void main(String[] args) {  
		    TreeSet<Integer> ts = new TreeSet<Integer>();  //这里的元素用了Integer，而不是int
		                                            //是因为Integer实现了Comparable接口，int没有
		    ts.add(190);  
		    ts.add(33);  
		    ts.add(77);  
		  
		    for (Integer i : ts) {  
		        System.out.println(i);  
		    }  
		}
		
		
		33
		77
		190
		```
	- 元素为students，return 0;
		```java
		public class students implements Comparable<students>{  
		    private int age;  
		    private String name;  
		  
		    public students(int age, String name) {  
		        this.age = age;  
		        this.name = name;  
		    }  
		  
		    public int getAge() {return age;}  
		    public void setAge(int age) {this.age = age;}  
		    public String getName() {return name;}  
		    public void setName(String name) {this.name = name;}  
		  
		    @Override  
		    public int compareTo(students o) {  
		        return 0;  //首先添加s1，添加s2的时候返回0（表示s2的元素和s1相同），不存储
		    }  
		}
		```
		```java
		public class collection {  
		    public static void main(String[] args) {  
		        TreeSet<students> ts = new TreeSet<students>();  
		  
		        students s1 = new students(12, "吴彦祖");  
		        students s2 = new students(23, "陈冠希");  
		        students s3 = new students(42, "刘德华");  
		        students s4 = new students(12, "吴彦祖");  
		  
		        ts.add(s1);  
		        ts.add(s2);  
		        ts.add(s3);  
		        ts.add(s4);  
		  
		        for (students s : ts) {  
		            System.out.println(s.getAge() + s.getName());  
		        }  
		    }  
		}


		12吴彦祖
		```
	- 元素为students，return 1;
		```java
		public class students implements Comparable<students>{  
		    private int age;  
		    private String name;  
		  
		    public students(int age, String name) {  
		        this.age = age;  
		        this.name = name;  
		    }  
		  
		    public int getAge() {return age;}  
		    public void setAge(int age) {this.age = age;}  
		    public String getName() {return name;}  
		    public void setName(String name) {this.name = name;}  
		  
		    @Override  
		    public int compareTo(students o) {  
		        return 1;  //首先存s1，存s2时返回1（表示s2大于s1），s2存在s1之后
		    }  
		}


		12吴彦祖
		23陈冠希
		42刘德华
		12吴彦祖
		```
	- 元素是students，灵活return;
		```java
		public class students implements Comparable<students>{  
			private int age;  
			private String name;  
		  
			public students(int age, String name) {  
				this.age = age;  
				this.name = name;  
			}  
		  
			public int getAge() {return age;}  
			public void setAge(int age) {this.age = age;}  
			public String getName() {return name;}  
			public void setName(String name) {this.name = name;}  
		  
			@Override  
			public int compareTo(students o) {  
				int i = this.age - o.age;  
				return i;
			}  
		}
		
		
		12吴彦祖
		23陈冠希
		42刘德华
		```

- 提供 Comparator 比较器对象的带参构造
	```java
	public class collection {  
	    public static void main(String[] args) {  
	        TreeSet<students> ts = new TreeSet<students>(new Comparator<students>() {  
	            @Override  
	            public int compare(students o1, students o2) {  
	                int sum = o1.getAge() - o2.getAge();  
	                return sum;  
	            }  
	        });                        //此处为匿名内部类，是Comparator接口的实现类对象
	  
	        students s1 = new students(12, "吴彦祖");  
	        students s2 = new students(23, "陈冠希");  
	        students s3 = new students(42, "刘德华");  
	        students s4 = new students(12, "吴彦祖");  
	  
	        ts.add(s1);  
	        ts.add(s2);  
	        ts.add(s3);  
	        ts.add(s4);  
	  
	        for (students s : ts) {  
	            System.out.println(s.getAge() + s.getName());  
	        }  
	    }  
	}
	
	
	12吴彦祖
	23陈冠希
	42刘德华
	```

# ❤ Map
>[!quote] Map
>Map 集合 **不能有重复的 key，每个 key 最多映射到一个值**
> ```java
> public interface Map<K,V>  // K 表示 key，V 表示 value
> ```

- **静态方法**
	- 【增】
		- `Map.of(……)` 生成一个不可变的 map 集合【最多只能有 10 个键值对】
		- `Map.ofEntries` 传递无限个 Entry 对象

```java
Map<String, Integer> map = Map.of("one", 1, "two", 2, "three", 3);
```

---

- **非静态方法**
	- 【增】
		- `put(K key,V value)` 添加元素
		- `merge(key, value, 冲突处理方法)` 添加键值对，如果集合中存在相同 key，则会覆盖旧值，也可以自定义冲突处理方法
	- 【删】
		- `remove(Object key)` 根据键删除键值对元素
		- `clear()` 移除所有键值对元素
	- 【查】
		- `size()` 返回集合的长度
		- `V get(Object key)` 根据键获取值
		- `keySet()`   返回一个所有键的 Set 集合
		- `values()`   返回一个所有值的 Collection 集合
		- `entrySet()`   返回一个 Set 集合 Set\<Map.Entry\<String, Integer>>，其中每个 `Map.Entry` 表示一个键值对
		- **判断**
			- `boolean containsKey(Object key)` 判断集合是否包含指定的键
			- `boolean containsValue(Object value)` 判断集合是否包含指定的值
			- `boolean isEmpty()`   判断集合是否为空

>[!quote] `Map.Entry<K,V>` 
>- `getKey()` 返回 K
>- `getValue()` 返回 V

---

- 获取方法的具体实现
	```java
	public static void main(String[] args) {  
	    Map<Integer, String> m = new HashMap<Integer, String>();  
	    m.put(12, "吴彦祖");  
	    m.put(23, "彭于晏");  
	    m.put(12, "郭富城");  
	  
	    System.out.println(m.get(12));  
	    System.out.println(m.get(34));  
	    System.out.println(m.keySet());  
	    System.out.println(m.values());  
	    System.out.println(m.entrySet());  
	}
	
	
	郭富城
	null
	[23, 12]
	[彭于晏, 郭富城]
	[23=彭于晏, 12=郭富城]
	```

- 遍历的具体实现
	- 遍历所有key，再根据key找到对应的value
		```java
		public static void main(String[] args) {  
		    Map<Integer, String> m = new HashMap<Integer, String>();  
		    m.put(12, "吴彦祖");  
		    m.put(23, "彭于晏");  
		    m.put(34, "郭富城");  
		  
		    Set<Integer> set = m.keySet();  
		    for (int key : set) {  
		        String value = m.get(key);  
		        System.out.println(key + ":" + value);  
		    }  
		}
		
		
		34:郭富城
		23:彭于晏
		12:吴彦祖
		```

	- 获取所有键值对的对象集合，然后遍历集合里的每个对象
		```java
		public static void main(String[] args) {  
		    Map<Integer, String> m = new HashMap<Integer, String>();  
		    m.put(12, "吴彦祖");  
		    m.put(23, "彭于晏");  
		    m.put(34, "郭富城");  
		  
		    Set<Map.Entry<Integer, String>> set = m.entrySet();  
		    for (Map.Entry<Integer, String> me : set) {  
		        System.out.println(me);  
		    }  
		}
		
		
		34=郭富城
		23=彭于晏
		12=吴彦祖
		```

## 💛 HashMap
```
public class HashMap<K,V> extends AbstractMap<K,V>
implements Map<K,V>,Cloneable,Serializable
```

```java
HashMap<Integer, String> m = new HashMap<Integer, String>();  
m.put(12, "吴彦祖");  
m.put(23, "彭于晏");  
m.put(34, "郭富城");  
  
System.out.println(m);


{34=郭富城, 23=彭于晏, 12=吴彦祖}
```

## 💛 TreeMap
>[!quote] TreeMap
>TreeMap 可以对 key 进行排序
>  ```java
> public class TreeMap<K,V> extends AbstractMap<K,V>
> implements NavigableMap<K,V>,Cloneable,Serializable
> ```

## 💛 线程同步
>[!hint] 由于 `HashMap` 是非线程安全的，当多个线程并发访问和修改 `HashMap`，会造成数据不一致

---

>[!quote] 内部同步 和 外部同步
>- **内部同步**：在类或对象的实现内部进行的同步。通常，这是通过在方法上使用`synchronized`关键字或者在代码块上使用`synchronized`锁来实现的
>	- 使用简单，不需要编写额外的同步代码
>	- 由于方法都被加了 `synchronized` ，会导致性能损失
>- **外部同步**：使用者需要自己管理对共享资源的访问，以保证线程安全
>	- 灵活性高，可以更加细粒度
>	- 使用复杂，容易出错

>[!quote] 提供线程安全的方法
>- `HashTable` 内部同步，不推荐
>- `Collections.synchronizedMap()` 外部同步，不推荐
>	- 每次对 Map 的操作都需要同步，这会导致显著的性能开销
>	- 提供的是粗粒度的锁，任何时候只有一个线程可以访问 Map 的任何部分
>- `ConcurrentHashMap` 特殊的内部同步，**推荐**


### HashTable
>[!quote] `HashTable`
> - `HashTable` 不允许键和值为`null`
>- 迭代器是弱一致的


### Collections.synchronizedMap
```java
Map<Object,Object> map=Collections.synchronizedMap(new HashMap<>());
// 现在这个map集合就是线程安全集合了
```

### ConcurrentHashMap
>[!quote] `ConcurrentHashMap`
>`ConcurrentHashMap` 中用的是<u>分段锁</u>【~~将数据分成多个段，每个段可以独立地被锁定，不同的线程可以同时访问不同段的数据，从而提高了并发性能~~】
>- 由于是分段锁，细粒度更高，提高了并行度
>- 由于是内部同步，使用起来就像使用 `HashMap` 一样，简单方便
>- 性能高
>- 迭代器是弱一致的
> - `ConcurrentHashMap` 也允许键和值为 `null`，与 `HashMap` 相似

>[!quote] 弱一致的迭代器
>迭代器在迭代过程中可以容忍集合的并发修改【~~不会抛异常~~】，但不会保证迭代器能够实时反映这些修改

无锁设计：
在某些操作中，ConcurrentHashMap 采用了无锁编程技术，比如使用原子变量（如 AtomicInteger）来管理计数器等。
无锁设计可以减少线程争用和上下文切换的开销，提高性能。

# ❤ Collections工具
```java
public class Collections
extends Object
```

- 【排序】
	- `sort()`   将指定的列表升序排列
	- `reverse()`   反转指定列表中的元素顺序
	- `shuffle()`   把集合里的元素顺序重新随机排列
- 【空集合】
	- `emptyMap()` 返回一个不可变的空 Map

```java
public static void main(String[] args) {  
    List list = new ArrayList();  
    list.add(30);  
    list.add(10);  
    list.add(100);  
    list.add(70);  
  
    System.out.println(list);  
      
    Collections.sort(list);  
    System.out.println(list);  
      
    Collections.reverse(list);  
    System.out.println(list);  
      
    Collections.shuffle(list);  
    System.out.println(list);  
}


[30, 10, 100, 70]
[10, 30, 70, 100]
[100, 70, 30, 10]
[30, 70, 10, 100]
```


































