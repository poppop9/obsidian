>[!quote] Redis
>>Redis 是非关系性数据库，是<u>基于内存的</u>，<u>键值</u>数据存储系统，**所以性能非常高**，常用于数据库缓存，消息队列，会话存储 ……
>
>- **原子性操作**：Redis 的所有操作都是原子性的【意味着操作要么完全执行，要么完全不执行】，这种特性保证了数据的一致性和完整性
>- **持久化**：Redis 支持数据的持久化，可以将内存中的数据保存到磁盘中，以便在系统重启后恢复数据
>- **发布/订阅模式**：Redis 内置了发布/订阅模式，允许客户端之间通过消息传递进行通信
>- **主从复制**

>[!quote] 主从复制
> - **主节点**：主节点是原始的数据持有者，可以处理写操作和读操作。所有的写操作【新增，更新，删除】都会在主节点上执行，并且主节点会将这些写操作记录到一个日志中
> - **从节点**：从节点是主节点的复制品，它可以从主节点那里获取和复制数据。<u>从节点主要用于处理读操作，这样可以分担主节点的读取负载</u>。<u>从节点也可以作为数据的备份</u>，如果主节点出现问题，从节点可以立即接管主节点的角色，保证数据的可用性
> 
> >>从节点的复制过程是通过网络进行的：
> >- 首先，从节点会连接到主节点，并请求主节点发送其数据的副本
> >- 然后，主节点会将其数据发送给从节点
> > - 从节点接收并加载了主节点的数据后，就可以开始接收和处理读请求
> >- 后续，主节点会持续将其新的写操作日志发送给从节点，从节点会实时更新其数据

# 安装配置
- 使用 Docker 安装 
```
docker run --name redis -d -v /myredis/conf:/usr/local/etc/redis -p 6379:6379 redis
```

- 连接
	- 使用本地命令行，运行 `redis-cli` 即可使用命令行与 redis 进行通信
	- 使用 Redis 图形化界面工具 Redis InSight 连接
		- 添加数据库
		- 输入主机地址，端口号

![](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202404180051783.png)

# 基本命令
## SET，GET，DEL
>[!hint] 不同的数据结构，设置，获取命令会有差异

- `SET 键名 值名` 设置键值对
- `GET 键名` 根据键名，获取对应的值
- `DEL 键名` 根据键名，删除键值对

```bash
SET name redis
GET name
DEL name

---
"redis"
```

## CONFIG
- **永久改变配置项**

配置项通常在 Redis 的配置文件 `redis.conf` 中定义，我们可以编辑这个文件来改变 Redis 服务器的行为，一旦保存更改并重启 Redis 服务器，新的配置就会永久生效

---

- **临时改变配置项**【只对当前的 Redis 服务器进程有效，如果服务器重启，这些变更就会丢失】

我们也可以使用 `CONFIG` 来查看，或临时设置<u>配置项</u>【用来设置和控制 Redis 服务器本身行为的参数，比如服务器的运行模式，端口号，数据持久化的方式，连接的客户端数量上限，密码认证 ……】

```bash
redis-cli

# 获取某个配置项
CONFIG GET loglevel

# 获取所有配置项
CONFIG GET *

# 临时修改某个配置项
CONFIG SET loglevel "notice"


```

# 数据结构
>[!quote] Redis 支持的数据结构
>- 基本数据类型
> 	- `字符串 String`【**默认**】：可存储 512 MB
> 	- `列表 List`：字符串有序列表，<u>按照插入顺序排序</u>【可以把元素添加到列表的头部，或者尾部。可存储 40 多亿元素
> 	- `集合 Set`：字符串无序列表，集合中不允许有重复值，通过哈希表实现
> 	- `有序集合 ZSet`：字符串集合，且不允许重复的成员，每个元素都会关联一个 double 类型的分数，分数可以重复，redis 可以通过分数来为集合中的成员进行从小到大的排序
> 	- `哈希 Hash`：可存储 40 多亿个键值对，**适合存储对象**
> - 高级数据类型
> 	- 消息队列 Stream
> 	- 地理空间 Geospatial
> 	- HyperLogLog
> 	- 位图 Bitmap
> 	- 位域 Bitfield

- **字符串**【`SET` ，`GET` ，`DEL`】
```bash
SET name redis
GET name

---
"redis"
```

---

- **列表 List**
	- 左插入 `lpush 集合名 值` 
	- 右插入 `rpush 集合名 值` 
	- 按照索引遍历集合 `lrange 集合名 索引1 索引2` 

```bash
# 会返回列表的长度
127.0.0.1:6379> lpush list1 rerere
(integer) 1

127.0.0.1:6379> lpush list1 rere2
(integer) 2

127.0.0.1:6379> rpush list1 rere3
(integer) 3

127.0.0.1:6379> lrange list1 0 2
1) "rere2"
2) "rerere"
3) "rere3"
```

---

- **集合 Set**
	- 添加 `sadd 集合名 值` 
	- 遍历 `smembers 集合名` 

```bash
127.0.0.1:6379> sadd set1 green
(integer) 1

127.0.0.1:6379> sadd set1 red
(integer) 1

# 返回0，表示集合中已经有了相同的值
127.0.0.1:6379> sadd set1 red
(integer) 0

127.0.0.1:6379> sadd set1 black
(integer) 1

127.0.0.1:6379> SMEMBERS set1
1) "green"
2) "red"
3) "black"
```

---

- **有序集合 ZSet**
	- 添加元素，和分数 `zadd 集合名 分数 值` 
	- 根据分数范围遍历集合 `ZRANGEBYSCORE 集合名 分数1 分数2`

```bash
redis 127.0.0.1:6379> zadd runoob 0 redis
(integer) 1

redis 127.0.0.1:6379> zadd runoob 0 mongodb
(integer) 1

redis 127.0.0.1:6379> zadd runoob 0 rabbitmq
(integer) 1

redis 127.0.0.1:6379> ZRANGEBYSCORE runoob 0 1000
1) "mongodb"
2) "rabbitmq"
3) "redis"
```

---

- **哈希**
	- 创建并添加 `HMSET 集合名 键名1 值1 键名2 值2` 
	- 获取 `HGET 集合名 键名` 
	- `DEL`

```bash
redis 127.0.0.1:6379> HMSET runoob field1 "Hello" field2 "World"
"OK"

redis 127.0.0.1:6379> HGET runoob field1
"Hello"

redis 127.0.0.1:6379> HGET runoob field2
"World"

redis 127.0.0.1:6379> DEL runoob
(integer) 1
```







Redis是一个字典结构的存储服务器，而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。这与我们熟知的在一个关系数据库实例中可以创建多个数据库类似，所以可以将其中的每个字典都理解成一个独立的数据库。

每个数据库对外都是一个从0开始的递增数字命名，Redis默认支持16个数据库（可以通过配置文件支持更多，无上限），可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库，如要选择1号数据库：

redis> SELECT 1
OK
redis [1] > GET foo
(nil)

然而这些以数字命名的数据库又与我们理解的数据库有所区别。首先Redis不支持自定义数据库的名字，每个数据库都以编号命名，开发者必须自己记录哪些数据库存储了哪些数据。另外Redis也不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么连一个数据库也没有权限访问。最重要的一点是多个数据库之间并不是完全隔离的，比如FLUSHALL命令可以清空一个Redis实例中所有数据库中的数据。综上所述，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。比如可以使用0号数据库存储某个应用生产环境中的数据，使用1号数据库存储测试环境中的数据，但不适宜使用0号数据库存储A应用的数据而使用1号数据库B应用的数据，不同的应用应该使用不同的Redis实例存储数据。由于Redis非常轻量级，一个空Redis实例占用的内存只有1M左右，所以不用担心多个Redis实例会额外占用很多内存。

























