>[!quote] Redis 支持的数据结构
>- 基本数据类型
> 	- `字符串 String`【**默认**】：可存储 512 MB
> 	- `列表 List`：字符串有序列表，<u>按照插入顺序排序</u>【可以把元素添加到列表的头部，或者尾部。可存储 40 多亿元素
> 	- `集合 Set`：字符串无序列表，集合中不允许有重复值，通过哈希表实现
> 	- `有序集合 ZSet`：字符串集合，且不允许重复的成员，每个元素都会关联一个 double 类型的分数，分数可以重复，redis 可以通过分数来为集合中的成员进行<u>从小到大</u>的排序
> 	- `哈希 Hash`：可存储 40 多亿个键值对，**适合存储对象**
> - 高级数据类型
> 	- 消息队列 Stream
> 	- 地理空间 Geospatial
> 	- HyperLogLog
> 	- 位图 Bitmap
> 	- 位域 Bitfield

>[!hint] 使用 `type 键` 来查看 value 的数据类型

# 字符串
## 创建
- `SET 键 值` 设置键值对
- `GETSET 键 值` 设置键值对，并返回旧 value【~~如果没有，则返回 nil ~~】
- `mset 键1 值 键2 值 ……` 一次性设置多个键值对
- `msetnx 键1 值 键2 值 ……` 当 key 不存在时，一次性设置多个键值对

```bash
# mset
127.0.0.1:6379> mset name2 docker name3 mysql
OK
127.0.0.1:6379> get name2
docker
127.0.0.1:6379> get name3
mysql
```

## 获取
- `GET 键` 
- `GETRANGE 键 索引1 索引2` 获取 value 中的指定范围的字符
- `MSET 键1 键2 ……` 一次性获取多个 value【如果 key 不存在，则返回 nil】
- `Strlen 键` 获取 value 的字符长度

## 修改
- `SETRANGE 键 索引 值` 将 value 中，指定索引之后的值，进行替换
- `append 键 值` 向 value 后面添加字符
- `incr 键` 如果 value 为数字，则将 value 加 1
- `incrby 键 值` 如果 value 为数字，则将 value 加上指定的值
- `incrbyfloat 键 值`  如果 value 为数字，则将 value 加上指定的浮点数值
- `decr 键` 如果 value 为数字，则将 value 减 1
- `decrby 键` ……

```bash
redis 127.0.0.1:6379> SET key1 "Hello World"
OK
redis 127.0.0.1:6379> SETRANGE key1 6 "Redis"
(integer) 11
redis 127.0.0.1:6379> GET key1
"Hello Redis"
```

## 删除
- `DEL 键`

```bash
SET name redis
GET name
DEL name

---
"redis"
```

# 列表 List
- **添加**
	- 左插入 `lpush 集合名 值` 
	- 右插入 `rpush 集合名 值` 
- **删除**
	- 左删除几个元素 `lpop 集合名 [数字]` 【不加数字表示删除一个】
	- 右删除几个元素 `rpop 集合名 [数字]`
	- 只保留索引 1 到索引 2 之间的元素 `LTRIM 集合名 索引1 索引2`
- **查看**
	- 查看列表元素个数 `LLEN 集合名` 
	- 按照索引遍历集合 `lrange 集合名 索引1 索引2` 【索引 2 如果是 “-1”，表示最后一个元素】

```bash
# 会返回列表的长度
127.0.0.1:6379> lpush list1 rerere
(integer) 1

127.0.0.1:6379> lpush list1 rere2
(integer) 2

127.0.0.1:6379> rpush list1 rere3
(integer) 3

127.0.0.1:6379> lrange list1 0 2
1) "rere2"
2) "rerere"
3) "rere3"

# 从0开始遍历，知道最后一个元素
127.0.0.1:6379> lrange list1 0 -1
1) "rere2"
2) "rerere"
3) "rere3"
```

# 集合 Set
- **添加** `sadd 集合名 值` 
- **删除** `SREM 集合名 值`
- **查看**
	- 遍历 `smembers 集合名` 
	- 判断某个值是否在集合中 `SISMEMBER 集合名 值`

```bash
127.0.0.1:6379> sadd set1 green
(integer) 1

127.0.0.1:6379> sadd set1 red
(integer) 1

# 返回0，表示集合中已经有了相同的值
127.0.0.1:6379> sadd set1 red
(integer) 0

127.0.0.1:6379> sadd set1 black
(integer) 1

127.0.0.1:6379> SMEMBERS set1
1) "green"
2) "red"
3) "black"

127.0.0.1:6379> SISMEMBER red
(integer) 1
```

# 有序集合 ZSet
- **添加**元素，和分数 `zadd 集合名 分数 值` 
- **查看**
	- 获取某个分数 `ZSCORE 集合名 值` 
	- 获取排名 `ZRANK 集合名 值`
	- 反向获取排名 `ZREVRANK 集合名 值`
	- 遍历
		- 根据分数范围遍历集合 `ZRANGEBYSCORE 集合名 分数1 分数2` 
		- 根据索引遍历值 `ZRANGE 集合名 索引1 索引2`
		- 根据索引遍历值，和分数 `ZRANGE 集合名 索引1 索引2 WITHSCORES`

```bash
redis 127.0.0.1:6379> zadd runoob 0 redis
(integer) 1

redis 127.0.0.1:6379> zadd runoob 0 mongodb
(integer) 1

redis 127.0.0.1:6379> zadd runoob 0 rabbitmq
(integer) 1

redis 127.0.0.1:6379> ZRANGEBYSCORE runoob 0 1000
1) "mongodb"
2) "rabbitmq"
3) "redis"
```

# 哈希 Hash
- **创建**
	- `hset 集合名 键 值` 
	- `HMSET 集合名 键名1 值1 键名2 值2 ……` 一次设置多个键值对 

---

- **获取**
	- `HGET 集合名 键名` 查看某个 value
	- `hmget 集合名 键1 键2 ……` 
	- `hgetall 集合名` 查看所有的 key，和 value
	- `hexists 集合名 键` 查看键是否存在
	- `hkeys 集合名` 查看哈希表中所有的 key
	- `hvals 集合名` 查看哈希表中所有的 value
	- `hlen 集合名` 获取哈希表中 key 的数量

---

- **修改**
	- `hincrby 集合 键 增值`
	- `hincrbyfloat ……`

---

- **删除** `hdel 集合名 键1 键2 ……` 删除集合中，指定个键值对

---

```bash
redis 127.0.0.1:6379> HMSET runoob field1 "Hello" field2 "World"
"OK"

redis 127.0.0.1:6379> HGET runoob field1
"Hello"

redis 127.0.0.1:6379> HGET runoob field2
"World"

redis 127.0.0.1:6379> DEL runoob
(integer) 1
```
