
>[!quote] 事务
>>事务 是一组 SQL 语句
>
> - **原子性**：事务要么完全执行，要么完全不执行
> - **一致性**：事务完成时，必须使<u>所有数据都保持一致状态</u>【~~比如部门表中的某个部门被删除了，那员工表中就不会出现该部门下的员工~~】
> - **隔离性**：保证事务在不受并发操作影响的独立环境下运行，只要当前事务不 COMMIT，则别的事务看不到数据的变化【~~也就是加锁~~】
> - **持久性**：事务一旦 COMMIT / ROLLBACK，则数据永久改变

>[!hint] 事务处理可以回退 `INSERT`, `UPDATE`, `DALETE`。不能回退 `SELECT`, `CREATE`, `DROP`

# 事务控制机制
## 修改自动提交
- `@@autocommit = 1` 事务的提交方式是自动提交【默认】
- `@@autocommit = 0` 事务需要手动提交

```sql
SELECT @@autocommit;

---
1
```

```sql
SET @@autocommit = 0;

INSERT INTO test_work
VALUES (3, 'greenteck', '888');
-- 此时数据未更新

COMMIT;
-- 此时数据更新

-- 如果出错了可以使用 `ROLLBACK;` 回滚事务
```

## 显式事务
>[!hint] 基本思路
>如果执行过程中没有发生错误，则 COMMIT 整组 SQL 语句；如果发生错误，则 ROLLBACK，将数据库恢复到正常状态

- `START TRANSACTION;`  开始事务
- `COMMIT;`  结束事务并提交
- `ROLLBACK;`  回退到事务处理之前
- `SAVEPOINT 保留点名;`  设置保留点：允许在事务中的特定位置进行部分回滚，而不必回滚整个事务

```sql
START TRANSACTION;    //第一步先执行此语句

SAVEPOINT point1;    //设置一个保留点

UPDATE table SET id = 188;       //-------------------
UPDATE table SET name = Tom;      //然后执行这组语句体
UPDATE table SET age = 18;       //-------------------

---

COMMIT;      //如果这组语句体都执行成功，则可以执行COMMIT来提交

ROLLBACK;     //如果有语句执行失败了，则执行ROLLBACK来回退

ROLLBACK TO point1;  //返回到保留点point1
```

# 并发事务问题
- 脏读
- 不可重复读
- 幻读

## 脏读
>[!quote] 脏读
>脏读 就是事务 A 读到了 事务 B 还没有提交的数据

  
这种读取是可能发生的，因为不同的 DBMS 有不同的隔离级别来控制事务之间的隔离性

数据库的隔离级别通常有以下几种：
1. **读未提交（Read Uncommitted）**：这是最低的隔离级别，允许事务读取其他未提交事务的更改。在这种级别下，脏读是可能发生的。

2. **读已提交（Read Committed）**：在这种隔离级别下，事务只能读取其他事务已经提交的更改。这意味着脏读是被避免的，但可能发生不可重复读（Non-repeatable Read）。
    
3. **可重复读（Repeatable Read）**：在这种隔离级别下，事务在整个过程中可以看到一致的快照数据，即在事务开始时读取的数据，在事务结束时仍然可以读取到相同的数据。这避免了脏读和不可重复读，但可能导致幻读（Phantom Read）。
    
4. **串行化（Serializable）**：这是最高的隔离级别，它通过锁定涉及的所有数据来避免脏读、不可重复读和幻读。在这种级别下，事务将按顺序执行，就像它们是串行的一样。
    

脏读发生的原因是因为在某些隔离级别下，DBMS 允许事务读取到其他未提交事务的更改。这通常是为了提高并发性能，但在需要数据一致性的场景下，脏读可能会导致问题。因此，选择适当的隔离级别对于确保数据的一致性和完整性非常重要。


