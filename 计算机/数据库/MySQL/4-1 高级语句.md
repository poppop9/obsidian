# 🔗 联结表
>[!quote] 联结表
>联结表 是一种将<u>两个</u>或<u>多个表</u>中的数据**通过某些共同的值**关联起来的操作

>[!hint] 笛卡尔积
>如果在联结时，没有加上限制条件，则是把<u>表A</u>的每一行匹配<u>表B</u>的每一行，**所以如果此种情况***`SELECT *`***时，则查询的行数 = 表A行数 \* 表B行数**

>[!hint] 联结的好处
>大多数 DBMS，处理联结的速度 远大于 子查询

## 内联结
- **隐式内联结** `SELECT 字段 FROM 表1，表2 WHERE 条件;` 【表 1 和表 2 就通过了 `WHERE` 联结在了一起】

- **显示内联结** `SELECT 字段 FROM 表1 [INNER] JOIN 表2 ON 联结条件;`
```sql
select user.id, user.name, user.age, table_name.产品ID 
from user 
INNER JOIN table_name ON table_name.id = user.id;

---
|id|name|age|            
|:-:|:-:|:-:|
|123|陈冠希|45|
|11|刘诗诗|14|
|444|吴彦祖|4|
     +
|产品ID|id|
|:-:|:-:|
|乌鸦 |444|
|狗|11|
|老虎|123|
     ↓
|id|name|age|产品ID|
|:-:|:-:|:-:|:-:|
|123|陈冠希|45|老虎|
|444 |吴彦祖|4|乌鸦|
|11 |刘诗诗|14|狗|
```
## 自联结
```sql
//使用自联结的方式来实现
SELECT c1.id, c1.name, c1.contact
FROM customers AS c1,
     customers AS c2
WHERE c2.contact = 'jim'    //经过这个条件筛选过后，c2表中只剩下一条记录
  AND c1.name = c2.name;     //c1表中的name与c2表中的那一条记录进行比较

//如果使用子查询的方式来实现：
SELECT id, name, contact
FROM customers
WHERE name = (SELECT name FROM customers WHERE contact = 'Jim');

---

|id|name|contact|
|:-:|:-:|:-:|
|100|Fun123|Jim|
|101|Fun566|Tom|     × 2
|102|Fun123|Mike|
|103|Fun578|July|
       ↓
|100|Fun123|Jim|
|102|Fun123|Mike|
```
## 外联结
- **左外联结**  `SELECT 字段列表 FROM 表A LEFT JOIN 表B ON 联结条件;`：返回左表中所有的行，以及右表中满足条件的行

```sql
SELECT customers.id, orders.numbers
FROM customers
         LEFT JOIN orders ON customers.id = orders.id;

---
|id|name|contact|
|:-:|:-:|:-:|
|100|Fun123|Jim|
|101|Fun566|Tom|  
|102|Fun123|Mike|
|103|Fun578|July|
    +
|id|numbers|
|:-:|:-:|
|101|null|
|102 |9|
|103 |229|
	↓
|id|numbers|
|:-:|:-:|
|100|null|
|101|null|
|102|9|
|103|229|
```

- **右外联结**：返回右表中所有的行，以及左表中满足条件的行【~~一般不使用~~】

# 视图
>[!quote] 视图
>>视图 是一张虚拟的表，包含从一个/多个表中选择的行和列的数据
>
>我们可以使用视图封装某一组复杂的语句，进行重用，简化复杂的 SQL 操作

- 创建视图 `CREATE VIEW 视图名 AS 语句;` 
```sql
CREATE VIEW ProductCustomers AS ​​​​ 
SELECT cust_name, cust_contact, prod_id ​​​​ 
FROM Customers, Orders, OrderItems ​​​​
WHERE Customers.cust_id = Orders.cust_id ​​​​ 
	AND OrderItems.order_num = Orders.order_num;​​
```

- 删除视图 `DROP VIEW 视图名;`

- 使用视图 
```sql
​​​​​​SELECT cust_name, cust_contact ​​​​
FROM ProductCustomers ​​​​
WHERE prod_id = 'RGAN01';​​
```

>[!warning] 避免使用<u>多个联结创建复杂的视图</u>，<u>过滤创建复杂的视图</u>，或者<u>嵌套视图</u>，这样会导致性能下降

>[!warning] 视图的限制
>- **视图不能索引**：因为它们只是查询的结果集，而不是存储数据的实体
>- **视图不能有关联的触发器**：视图本身不能包含触发器，因为触发器是与表关联的
>- **视图不能有默认值**：视图无法定义列的默认值，因为它们只是查询的结果。默认值通常是在表的定义中指定的，而不是在视图中。

# 存储过程
>[!]

MySQL中的存储过程是一组预编译的SQL语句，存储在数据库中以便重复使用。存储过程可以接受参数、执行一系列SQL语句、进行逻辑处理，并返回结果。它们通常用于简化复杂的数据库操作、提高性能和安全性，并减少应用程序和数据库之间的通信量。

存储过程的主要用途包括：

1. **复杂逻辑处理：** 存储过程可以包含复杂的业务逻辑和控制流程，例如条件判断、循环、异常处理等，从而减少在应用程序中处理这些逻辑的复杂性。
    
2. **提高性能：** 存储过程在数据库服务器上执行，可以减少与数据库的通信次数，提高性能。此外，存储过程通常经过优化，可以更高效地执行查询和操作。
    
3. **权限控制：** 存储过程可以定义在数据库中执行的操作，而不是在应用程序中直接执行SQL语句。这样可以更好地控制用户对数据库的访问权限，并防止SQL注入等安全问题。
    
4. **减少网络流量：** 将一组SQL语句打包在一个存储过程中，可以减少应用程序和数据库之间的数据传输量，从而提高整体性能。
    

总的来说，存储过程是MySQL中一种强大的工具，可用于简化复杂的数据库操作、提高性能和安全性，并降低应用程序的复杂性。

# 事务
>[!quote] 事务
>>事务 是一组 SQL 语句
>
> - 原子性：事务要么完全执行，要么完全不执行
> - 一致性：事务完成时，必须使<u>所有数据都保持一致状态</u>【~~比如部门表中的某个部门被删除了，那员工表中就不会出现该部门下的员工~~】
> - 隔离性：只要不COMMIT，则别的窗口看不到数据的变化
> - 持久性：事务一旦COMMIT/ROLLBACK，则数据永久改变

>[!hint] 事务处理可以回退 `INSERT`, `UPDATE`, `DALETE`。不能回退 `SELECT`, `CREATE`, `DROP`

---

**如果执行过程中没有发生错误，则 COMMIT 整组 SQL 语句；如果发生错误，则 ROLLBACK，将数据库恢复到正常状态**

- `START TRANSACTION;`  开始事务
- `COMMIT;`  结束事务并提交
- `ROLLBACK;`  回退到事务处理之前
- `SAVEPOINT 保留点名;`  设置保留点：允许在事务中的特定位置进行部分回滚，而不必回滚整个事务

```sql
START TRANSACTION;    //第一步先执行此语句

SAVEPOINT point1;    //设置一个保留点

UPDATE table SET id = 188;       //-------------------
UPDATE table SET name = Tom;      //然后执行这组语句体
UPDATE table SET age = 18;       //-------------------

---

COMMIT;      //如果这组语句体都执行成功，则可以执行COMMIT来提交

ROLLBACK;     //如果有语句执行失败了，则执行ROLLBACK来回退

ROLLBACK TO point1;  //返回到保留点point1
```

# 游标






