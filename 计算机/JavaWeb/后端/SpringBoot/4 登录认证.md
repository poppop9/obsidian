# 🌕登录功能


# 🌕登录校验
>在用户未登录时，无法访问该网站的其他子页面

```mermaid
graph TB
	a[浏览器]--发起请求-->b[(统一拦截,根据登录标记判断是否登录成功)]
	b-->j[访问loginController层页面]
	j-->c[无论是否登录,都会访问成功]
	
	b---->d[访问其他页面]
	d---->f[登录成功]
	f--第一次登录成功-->g[(存登录标记)]-->h[正常访问]
	f--登录成功过-->h

	d---->e[登录失败]-->i[跳转到loginController层路径]
```
### 🌗登录标记
>[!quote] 会话
>一次会话从打开浏览器访问Web服务器开始，直到其中一方断开连接，一次会话结束。***一次会话可以包含多次请求和响应***

>[!quote] 会话跟踪
>服务器来识别多次请求是否来自同一个浏览器，以便在多次请求中共享数据
##### 🌑Cookie 客户端会话跟踪技术
>服务端会创建一个Cookie响应给浏览器，浏览器会把这个Cookie保存下来，之后再发起请求时浏览器会携带Cookie，服务端根据Cookie判断会话对象

- 优点
	- HTTP协议中支持的技术
- 缺点
	- 移动端无法使用
	- 不安全
	- 用户可以自行禁用Cookie
	- Cookies不能跨域【***意味着前后端分离的设计模式无法使用***】
##### 🌑Session 服务端会话跟踪技术
>基于Cookie技术实现

- 优点
	- 安全【数据存储在服务端】
- 缺点
	- 服务器集群部署下无法使用Session技术
	- Cookie的所有缺点

>[!hint] Cookie 与 Session 已经很少使用了，现在主流使用 JWT令牌
##### 🌑JWT令牌
>JWT令牌【Json Web Token】就是用户标识，对Json格式进行了 `Base 64编码` + 签名算法

- 优点
	- 支持多端【令牌可以存储在除Cookie以外的其他存储空间中】
	- 支持服务端集群部署
	- 减轻了服务端存储压力【无需在服务端存储数据】
- 缺点
	- 需要自己实现
	- 需要和前端配合
###### 🌙组成
![[Excalidraw/计算机/JavaWeb Draw.md#^group=MNBxap8H|870]]
###### 🌙实现流程
- 在用户登录成功之后，在服务端生成JWT令牌
- 将令牌下发给客户端
- 客户端把令牌存储起来
- 客户端在之后的每一次请求时携带该令牌
- 服务端接收请求之后进行统一拦截，获取到请求中携带的令牌，并校验令牌的真伪
	- 无效，响应错误结果
	- 有效，允许访问对应的业务接口
###### 🌙准备工作
- 引入依赖
```xml
<dependency>  
    <groupId>io.jsonwebtoken</groupId>  
    <artifactId>jjwt</artifactId>  
    <version>0.9.1</version>  
</dependency>
```
###### 🌙具体实现
- 生成令牌
```java
package com.example;

public class CreateJWT {
    public static void main(String[] args) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("jaygee", "scarecrow");
        claims.put("kin", "boogaloo");

        //链式编程
        String jwt = Jwts.builder()  //调用builder方法来构建令牌
                .signWith(SignatureAlgorithm.HS256, "greenteck")  //设置签名算法，密钥
                .setClaims(claims)  //设置自定义内容【这里用map集合表示json】
                .setExpiration(new Date(System.currentTimeMillis() + 3600 * 1000))  //设置令牌的有效期
                .compact();  //最后返回令牌

        System.out.println(jwt);
    }
}

---
eyJhbGciOiJIUzI1NiJ9.eyJraW4iOiJib29nYWxvbyIsImpheWdlZSI6InNjYXJlY3JvdyIsImV4cCI6MTcwMTM5NTI1Nn0.sUBF2FiPF7-cjKJBEN-2C_qKhLxQ3fACr24NhKsO8Ss
```

- 解析令牌
```java
public static void AnalysisJWT() {
	Claims claims = Jwts.parser()   //调用解析器
			.setSigningKey("greenteck")   //传入密钥
			.parseClaimsJws("eyJhbGciOiJIUzI1NiJ9.eyJraW4iOiJib29nYWxvbyIsImpheWdlZSI6InNjYXJlY3JvdyIsImV4cCI6MTcwMTM5NTQyMn0.5KdqiCxgr_Omy2vRj1_Yd3PouEPCiI-HeSvvDPVJtOU")  //声明令牌
			.getBody();  //获取第二部分

	System.out.println(claims);
}

---
{kin=boogaloo, jaygee=scarecrow, exp=1701396784}
```

>[!hint] 当篡改令牌


### 🌗统一拦截

##### 🌑过滤器Filter



##### 🌑拦截器Interceptor







# 🌕异常处理


