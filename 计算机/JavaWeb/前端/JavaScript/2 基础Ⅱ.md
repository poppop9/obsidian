# 🌕try…catch
`try`  能够测试代码块中的错误
`catch`  允许处理错误
`throw`  允许创建自定义错误
`finally`  在 try 和 catch 之后，无论结果如何，执行代码

```js
function myFunction() {
  var message, x;
  message = document.getElementById("p01");
  message.innerHTML = "";
  x = document.getElementById("demo").value;
  try { 
    if(x == "")  throw "是空的";   //throw自定义错误
    if(isNaN(x)) throw "不是数字";
    x = Number(x);
    if(x > 10)   throw "太大";
    if(x < 5)  throw "太小";
  }
  catch(err) {                          //err是js提供的错误对象
    message.innerHTML = "输入：" + err;
  }
  finally {
    document.getElementById("demo").value = "";    //在每次try执行完，清空输入框
  }
}
```
# 🌕严格模式
在脚本的开头定义 ：`"use strict";`
### 🌗为什么使用严格模式？
>严格模式使我们更容易编写“安全的” JavaScript，把之前可接受的“坏语法”转变为真实的错误

- 在普通的 JavaScript 中，错打变量名会创建新的全局变量。在严格模式中，此举将抛出错误，这样就不可能意外创建全局变量
- 在普通 JavaScript 中，如果向不可写属性赋值，开发者不会得到任何错误反馈。在严格模式中，向不可写的、只能读取的、不存在的属性赋值，或者向不存在的变量或对象赋值，将抛出错误

```js
// 声明严格模式
"use strict";
x = 3.14;       // 在不声明变量的情况下使用变量，是不允许的，这将引发错误

var x = \010;            // 避免错误的字符转义，这将引发错误

var obj = {};
Object.defineProperty(obj, "x", {value:0, writable:false});
obj.x = 3.14;            // 写入只读属性是不允许的，这将引发错误
```
# 🌕this
>`this` 关键词指的是它所属的对象

- 在方法中，`this` 指的是所有者对象
- 单独的情况下，`this` 指的是全局对象
- 在函数中，`this` 指的是全局对象
- 在函数中，严格模式下，`this` 是 undefined
- 在事件中，`this` 指的是接收事件的元素
















