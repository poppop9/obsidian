$$
SLF4J 是一个接口，它本身不具有输出日志的功能，输出日志还是由抽象类来实现【比如 log4j，logback】【~~类比 JDBC 只是一种规则~~】
$$

# 概述
## 介绍
我们在编写代码的时候，只会使用 SLF4J 里的 API，应用程序在运行时再去类路径下查找绑定的具体日志实现，并使用其进行实际的日志操作【~~如果在应用程序的类路径下面没有找到合适的绑定的话，默认使用一个没有任何操作的实现~~】

---

SLF4J 只做两件事：
- 提供日志接口
- 提供获取具体日志对象的方法

---

>[!hint] 为什么要选择抽象层的 SLF4J，而不是实现类【log4j，logback】？
>假设 A 开发了一个通用组件，他在程序中使用的是 log4j，B 之前开发的的业务模块使用的是 logback。突然有一天 B 要在自己的业务系统中使用 A 的通用组件，那就很麻烦了，<u>那么解决方案就是使用 SLF4J</u>

## 日志级别
- `fatal` 灾难级的，因为代码异常导致程序退出执行的事件；系统级别，程序无法打印
- `error` 错误信息
- `warn` 警告信息
- `info` 普通的打印信息
- `debug` 需要调试时候的关键信息
- `trace` 级别最低

>[!hint] 当某个项目目录设置了日志级别，我们只能得到`此级别及更高级别`的日志，SpringBoot 的默认级别是 `info`

## 日志格式
日志 = 日志打印时间 + 日志级别 + 线程 id + 线程名称 + 日志所在类 + 日志内容

# 配置
```properties
logging:
  # 指定不同包下使用不同的日志级别
  level:
    com.atguigu: trace
  # 以文件形式打印日志logging.file
  file:
    name: D:/boot.log	#指定日志文件的具体位置
  #日志输出格式：控制台，文件
  pattern: 
  	console: %d{yyyy-MM-dd} [%thread] %-5level %logger{50} - %msg%n
  	file: %d{yyyy-MM-dd} === [%thread] === %-5level === %logger{50} ==== %msg%n
  	
    #    %d 表示日期时间
    #    %thread 表示线程名
    #    %-5level 级别从左显示5个字符宽度
    #    %logger{50} 表示logger名字最长50个字符，否则按照句点分割
    #    %msg 日志消息
    #    %n 换行符
```

日志级别的显示宽度是5【无论实际的日志级别是什么，它都会在控制台上占用 5 个字符的宽度】

如果日志级别是ERROR，那么在控制台上，它会显示为"ERROR"，因为"ERROR"正好是5个字符，所以不需要添加空格。

为了使得不同的日志条目在控制台上对齐，看起来更整齐





























