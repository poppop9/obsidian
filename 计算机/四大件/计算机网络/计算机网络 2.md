---
tags:
  - 计算机/四大件
---
# 网络的全貌
浏览器和Web服务器之间的交互却很简单，概括如下：
(1)浏览器向Web服务器发送请求；
(2)Web服务器根据请求向浏览器发送响应；

要实现应用程序之间的交互，我们需要一个能够在浏览器和Web服务器之间传递请求和响应的机制。网络是由很多计算机等设备相互连接组成的，因此在通信的过程中需要确定正确的通信对象，并将请求和响应发送给它们。请求和响应在传递的过程中可能会丢失或损坏【请求和响应本质都是电信号和光信号，这些信号可能会因收到杂音等干扰而损坏】。所以需要一种机制，无论遇到任何情况都能够将请求和响应准确无误地发送给对方。
这种机制是由操作系统中的网络控制软件，以及交换机、路由器等设备分工合作来实现的，它的基本思路是将数字信息分割成一个一个的小块，然后装入一些被称为“包”(Packet)的容器中来运送。大家可以这样理解：包相当于信件或者包裹，而交换机和路由器则相当于邮局或快递公司的分拣处理区。包的头部存有目的地等控制信息，通过许多交换机和路由器的接力，就可以根据控制信息对这些包进行分拣，然后将它们一步一步地搬运到目的地。
无论是家庭和公司里的局域网，还是外面的互联网，它们只是在规模上有所不同，基本的机制都是相同的。

前面介绍的这个负责搬运数字信息的机制，再加上浏览器和Web服务器这些网络应用程序，这两部分就组成了网络。

# 网卡
```mermaid
graph LR
	a(协议栈)--带有0和1的数字信号的网络包-->b(网卡)--电信号/光信号-->c(网线/光纤)
	c-->d(路由器,集线器等转发设备)
	d-->e(接收方)
```
## 网卡将包转换成电信号通过网线发送出去
网卡驱动从IP模块获取包之后，会将其复制到网卡内的缓冲区中；
接下来MAC模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列；
***之后网卡的MAC模块生成电信号【通用信号】，然后由PHY(MAU)模块转换成可在网线中传输的格式，并通过网线发送出去***
![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=ZpB4IHEP|500]]
# 网线
## 传输电信号
>[!question] 怎么解决传输时电信号的衰减？
>![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=8iOnlDvg|500]]
>***使用双绞线【将两根信号线缠绕在一起形成一组】***
>![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=pZqxXexl|600]]

# 集线器，交换机，路由器
## 集线器收到来自网线的信号
当信号到达集线器后，会被广播到连接集线器的所有设备，这些设备收到信号之后会通过MAC地址判断是不是发给自己的【是则接收，否则忽略】
![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=fWnWn5MN|570]]
## 交换机收到来自集线器的信号
信号到达交换机之后的处理与网卡基本相同【==可以认为交换机的每个网线接口和后面的电路部分都是一块网卡==】：
- 信号到达网线接口，由PHY(MAU)模块进行接收，并将信号转换为通用格式传递给MAC模块
- MAC模块将信号转换为数字信息，之后校验FCS【没问题则放入缓冲区，否则丢弃】
- 包放入缓冲区后，则根据MAC表查询接收方的MAC地址应该通过哪个端口发送出去【有记录则发送，无记录则广播】
![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=Po3EOEWg|570]]
## 路由器收到来自交换机的信号
- 首先，根据对应的通信技术【以太网/无线局域网】将从端口发送过来的包接收进来
- 接下来，转发模块会根据包的 IP头部 在路由表中查询
>查询时只匹配网络号，忽略主机号，根据<u>子网掩码</u>来决定发送的优先级，无选项时选择<u>默认网关</u>：
>>例如，要发送一个包到`192.168.1.10`服务器：
>>- 首先根据子网掩码判断符合对象，第三行的子网掩码表示只判断前 24 个bit位，所以第三行符合要求；第四行也符合要求；第五行的子网掩码表示需要符合的bit位是0，所以也符合。
>>- 接着是确定优先级：子网掩码位数越多，优先级越高，因为范围越小。第四行的目标地址根据子网掩码可以判断是一个服务器的地址；第三行是一个子网地址；
>>- 把包发送给第四行的地址，如果符合则结束，否则发送给下一优先级的地址
>>- 如果前面的地址都不匹配，则发送给***默认网关***【第五行】
>>![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=fP0Bxd5i|500]]
- 更新<u>IP头部</u>的TTL有效期[^5]
>发送方在发送包时会将TTL设为 64/128，包每经过一个路由器的转发，TTL就会减 1，当TTL的值变成0时，这个包就会被丢弃【在互联网上发送包最多也就经过几十个路由器】

- 转发模块将包转移到对应端口，端口按照硬件的规则【以太网等】将包发送出去

如果输出端口为以太网，则发送出去的网络包会通过<u>交换机</u>到达下一个<u>路由器</u>。如果网络包的目标服务器位于家庭，公司网络中，那就不需要通过接入网路由器，也就不用进入互联网，而是直接转发给目标服务器；否则网络包会到达<u>接入网路由器</u>

[^5]:这个机制是为了防止包在一个地方陷入死循环
# 接入网，网络运营商
>接入网是指用户通过各种技术手段【如光纤、电缆、DSL等】将自己的设备连接到互联网的网络

>网络运营商是提供互联网接入和通信服务的公司或组织。

用户通过接入网将自己的设备接入到网络运营商的网络中，从而获取互联网服务
## 准备工作
- 首先，接入路由器会根据PPPoE的发现机制[^14]来寻找运营商端的BAS：
	- 用户询问：”BAS在不在？在的话报告MAC地址“
	- BAS回答：”我在这里，我的MAC地址是xx:xx:xx:xx:xx:xx“
- 接下来，是用户认证阶段
	- 用户名和密码通过***CHAP***[^15]方式发送给BAS
	- 用户名和密码通过***PAP***[^16]方式发送给BAS
- 然后，是BAS向用户下发配置信息[^17]
	- 路由器会根据这些信息配置自身的参数【路由器的BAS端口配置公有地址，路由表中配置默认网关】
- 接下来，互联网接入路由器进行地址转换
	- 如果不使用路由器来上网，BAS下发的配置信息就会直接配置在计算机上【相当于计算机有了公有地址】，这种情况下***无需地址转换***
	- 如果使用路由器来上网，BAS下发的参数就会被配置在路由器上【公有地址是分配给路由器的】。这时，***计算机会被分配一个私有地址，计算机发送的包需要通过路由器进行地址转换然后再转发到互联网中***。有些应用程序【网络电话、聊天、对战游戏等】会因为地址转换无法正常工作【因为有些应用程序需要将自己的IP地址告知通信对象或者告知控制服务器，但在有地址转换的情况下这些操作无法完成】，但现在已经有很多解决方案，因此不能说这些应用程序全都不能正常工作

==一对一连接的端口可以不分配IP地址==【因为网络包不管如何都会被送到另一端】

不用路由器上网会有危险【因为计算机拥有公有地址，这意味着来自互联网的包可以直接到达计算机，这可能导致计算 机被攻击】，因此，对于直接上网的客户端计算机，我们应该采取安装防火 墙软件等防御手段。

>[!faq] ***CHAP***与***PAP***的安全性？
>进行加密的CHAP安全性更高。但是也不是说使用PAP密码就立刻会被窃取。由于明文密码只在运营商端BAS和用户端路由器之间传输【从运营商端BAS向认证服务器发送密码时使用 RADIUS协议，无论用户拨入使用CHAP还是PAP，都是加密的】。
>
>所以如果要窃取密码，就要在路由器和 ADSL Modem 中间进行窃听

[^14]:基于广播来实现
[^15]:挑战握手认证协议
[^16]:密码认证协议
[^17]:配置信息包括分配给上网设备的 IP地址【公有地址】、DNS服务器的IP地址、默认网关的IP地址
## 发送网络包
### 使用ADSL接入网
>ADSL是一种利用架设在电线杆上的金属电话线来进行高速通信的技术

ADSL接入网的上行方向【用户到互联网】和下行方向【互联网到用户】的通信速率是不同的
![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=p215RiZm|900]]
- 首先，客户端生成的网络包到达互联网接入路由器后，在此处从以太网包中取出IP包并判断转发目标  ①~④
- 接下来，如果互联网接入路由器和 ADSL Modem 之间是通过以太网连接的，网络包会加上 MAC 头部、PPPoE 头部、PPP 头部总共 3 种头部[^8]，然后按照以太网规则发送出去  ⑤
- 接着，包就到达了 ADSL Modem 后，包会被拆分成很多小格子，每一个小格子称为一个信元【更小一号的包】，并将其转换为电信号  ⑥~⑧
- 然后，电信号会进入一个叫作<u>分离器</u>[^6]的设备与电话的语音信号混合起来
- 之后，从分离器出来，会通过室内电话线，然后到达外部电话线
- 接下来，信号会进入电线杆上架设的电话电缆【如果在电话局附近，电话电缆是埋在地下的】信号通过电话线到达电话局之后，会经过配线盘、分离器到达 DSLAM【多个 ADSL Modem 整合在一个外壳里的设备】
- ***DSLAM 会把电信号还原成信元，并发送给BAS***[^7]  ⑨~⑩
- 之后，BAS 将接收到的 ATM信元 还原成原始的网络包  ⑪~⑫
- 接下来，它会将收到的包前面的 MAC头部 和 PPPoE头部 丢弃，取出 PPP头部以及后面的数据  ⑬
- 接着，BAS 会在包的前面加上隧道专用头部，发送到隧道的出口  ⑭
- 然后，网络包到达隧道出口的隧道专用路由器后，会丢弃隧道头部，取出IP包，并被转发到互联网内部  ⑮~⑰

[^6]:分离器的作用是在信号从电话线传入的时候，负责将 电话 和 ADSL的信号 进行分离
[^7]:BAS：包转发设备
[^8]:MAC头部 和 PPPoE头部 的作用就是将包送达 BAS 的接口

![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=KVDJHycr|900]]
### 使用FTTH
>FTTH是一种宽带接入技术，叫作“光纤到户”

数字信息需要先转换成电信号，再转换成光信号【`1`为高电压表示发光，`0`为低电压表示发暗，将这样的电信号输入LED、激光二极管等光源后，它们就会根据电压的变化发光】

FTTH有直连和分路两种形态
#### 使用直连
>用一根光纤直接从用户端连接到最近的电话局，***通过不同的波长来区分上行/下行光信号***

![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=dSKmYsXg|900]]
- 首先，用户端的光纤收发器将以太网的电信号转换成光信号
- 接下来，光信号通过光纤直接到达<u>BAS</u>前面的多路光纤收发器
- 然后，多路光纤收发器将光信号-->电信号，BAS的端口接收之后，发送进隧道
- 经过运营商的网络后，到达互联网内部
#### 使用分路
>在用户附近的电线杆上安装***分光器***让光纤分路，同时连接多个用户

部分设备与直连不同，大体过程相同
![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=bzD79j7s|900]]
***用户端使用的ONU***：
- 可以将电信号转换成光信号
- 可以和电话局的OLT相互配合避免信号碰撞

终端盒 是<u>光纤收发器</u>和<u>ONU</u>等光纤终端设备的统称
## 网络包到达互联网的入口
网络包通过接入网，到达了网络运营商POP的路由器【这里是互联网的入口，网络包会从这里进入互联网内部】
![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=xKf3pd00|540]]
## 网络包进入互联网
![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=VMTBpvbT|520]]

>***NOC与POP：***
>NOC[^18]是运营商的核心设备，从POP[^19]传来的网络包都会集中到这里，并在这里被转发到离目的地更近的POP，或者是转发到其他的运营商。
>
>***NOC就是规模扩大后的POP***，NOC和POP没有非常严格的界定，NOC里面也可以配备连接接入网的路由器，很多情况下是和POP共用的

>[!question] POP与NOC是怎样连接的？
>由于运营商的网络中需要传输大量的包，已经超过了一般公司使用的双绞线能够容纳的极限，所以运营商一般使用***光纤***来连接POP与NOC
>
>>光纤需要在地下铺设，需要很大的工程费用，而且当线路发生中断时维护工作也需要费用。因此，只有有限的几家大型运营商才拥有光纤。而拥有光纤的公司一般都会提供光纤租用服务【通信线路服务】，其他运营商只要从拥有光纤的公司租借光纤就可以了

[^18]:网络运行中心
[^19]:“Point of Presense” 接入点
## 网络包跨运营商被转发
首先，如果最终目的地【某个Web服务器】和客户端是连接在同一个运营商中的，那么POP路由器根据路由表中的信息判断转发给<u>哪一个NOC/相邻的POP</u>，然后下一个路由器也同样 根据自己路由表中的信息继续转发。经过几次转发之后，网络包就到达了目的地所在的POP路由器

如果服务器的运营商和客户端的运营商不同，网络包需要先发到服务器所在的运营商，这些信息也可以在路由表中找到。这时网络包会被转发到对方运营商的路由器。
# 防火墙，缓存服务器
## 网络包通过防火墙
- 如果包被判断为允许通过，则该包会被转发出去
- 如果防火墙阻止包通过，那么这个包会被丢弃并被记录下来[^20]【这是因为这些被丢弃的包中通常含有非法入侵的痕迹，通过分析能够搞清楚入侵者使用的手法】

[^20]:如果将内置包过滤功能的路由器用作防火墙，由于路由器的内存容量小，则在丢弃包时基本上不会留下记录
## 网络包通过缓存服务器
>[!attention] 什么包不会通过缓存服务器？
>***对于客户端发送的数据包【POST请求中包含的数据或者上传的文件】，通常会直接发送到目标服务器，而不会经过缓存服务器***

***对于客户端发送的请求包：***
- 缓存服务器会检查请求消息的内容，看看请求的数据是否已经保存在缓存中
	- ***不存在缓存数据***
		- 缓存服务器会在HTTP头部字段中添加一个Via字段【表示这个消息经过缓存服务器转发】，然后将消息转发给Web服务器  ②
			- 如果一台缓存服务器只对应一台Web服务器，那么只要将Web服务器的域名和IP地址配置在缓存服务器上，让它无条件转发给这台服务器就可以了；
			- 如果一台缓存服务器对应多台Web服务器，就需要根据请求消息的`URI`中的目录名来进行判断；
		- 接着，缓存服务器会收到来自Web服务器的响应消息  ③
		- 接下来，缓存服务器会以Web服务器的身份向客户端发送响应消息  ④，响应消息中会加上`Via头部字段`【它表示这个消息是经过缓存服务器中转的】
		- 缓存服务器会将响应消息保存到缓存中，并记录保存的时间  ④’
	- ***存在缓存数据***
		- 缓存服务器会添加一个`If-Modified-Since头部字段`并将请求转发给Web服务器，询问Web服务器用户请求的数据是否发生变化  ②
		- 然后，Web服务器会根据`If-Modified-Since`的值与服务器上的页面数据的最后更新时间进行比较
			- 如果在指定时间内数据没有变化，就会返回一个没有变化的响应消息  ③
				- 接下来，返回消息到达缓存服务器，缓存服务器就会知道Web服务器上的数据和本地缓存中的数据是一样的，于是就会将缓存的数据返回给客户端  ④
			- 当Web服务器上的数据有变化时，Web服务器会返回最新版本的数据，然后缓存服务器加上`Via字段`发送给客户端，同时将数据保存在缓存中

![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=lV5zpHvG|550]]
![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=vPQdB7al|550]]

>[!hint] 优化缓存的更新方法，以优化性能
>缓存的更新方法会影响缓存服务器的效率【在第一次访问时不能发挥效果，而且后面的每次访问都需要向原始服务器查询数据是否变化】
>
>要改善这一点，我们可以***让Web服务器在原始数据发生更新时，立即通知缓存服务器***
# Web服务器
## 与客户端建立连接
我们将服务器程序分成***等待连接模块***和***负责与客户端通信的模块***

1. 服务器程序启动，并读取配置文件完成初始化
2. 运行等待连接模块    ==【创建套接字阶段】==
	- 创建套接字    
3. 等待连接模块进入等待连接的暂停状态    ==【等待连接阶段】==
4. 当客户端发起连接时，等待连接模块恢复运行，并接受连接    ==【接受连接阶段】==
	- 协议栈给等待连接的套接字复制一个副本，然后将控制信息写入到新的套接字中
	- 让客户端连接到新的副本套接字上
5. 等待连接模块启动客户端通信模块，并移交完成连接的套接字
![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=ebuoNrYm|500]]
6. 客户端通信模块与客户端进行通信    ==【数据收发阶段】==
7. 通信结束，模块退出    ==【断开阶段】==

>[!hint] 如果不创建新副本，而是直接让客户端连接到等待连接的套接字上，那就没有套接字在等待连接了，这时如果有其他客户端发起连接就会出现问题

>[!hint] 在复制出一个新的套接字之后，原来的那个处于等待连接状态的套接字还会以等待连接的状态继续存在，***这样，当客户端连接包再次到达时，它又可以再次执行接受连接操作***

>[!hint] 一个端口号会有多个套接字 
>端口号是用来识别套接字的，***一般来说，不同的套接字会有不同的端口号***。但如果这样做，会出现问题【比如客户端本来想要连接`80端口`的套接字，结果从另一个端口号返回了包，客户端就无法判断这个包是否是要连接的那个对象返回的】
>
>==因此，新创建的套接字副本和原来等待连接的套接字具有相同的端口号==
>
>但我们还需要***四种信息***来区分同一端口号下的不同套接字：
>客户端IP地址
>客户端端口号
>服务器IP地址
>服务器端口号
>![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=drzLD8sz|600]]

>[!faq] 既然可以通过这四种信息确定某个套接字，那为什么应用程序和协议栈之间是使用描述符来指代套接字的？
>- 在套接字刚刚创建好还未建立连接的状态下，这四种信息是不全的
>- 使用一种信息【描述符】比使用四种信息更简单

>[!hint] 我们可以事先启动几个客户端通信模块，这样当客户端发起连接需要启动新的程序时，可以马上从空闲的模块中挑选出一个来处理套接字，减少耗时
## 接收操作
### 网卡将接收到的信号转换为数字信息
1. 到达服务器的网络包是电信号/光信号，网卡会接收到信号，然后将其还原为数字信息
![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=BEOQVbiF|600]]
2. 接下来，需要根据包末尾的帧校验序列【FCS】来校验错误
	- 如果出错【可能因为噪声等影响导致信号失真，数据产生了错误】，接收的包需要丢弃
	- 当 FCS 一致时，需要检查MAC头部中的接收方MAC地址，看看这个包是不是发给自己的
3. 将还原后的数字信息保存在网卡内部的缓冲区
4. 网卡通过中断将网络包到达的事件通知给 CPU
5. CPU 就会暂停当前的工作，并切换到网卡的任务
6. 网卡驱动开始运行，从网卡缓冲区中将接收到的包读取出来，根据 MAC 头部的以太类型字段判断协议的种类，并调用负责处理该协议的软件
    - 如果以太类型的值是 IP 协议，会将包转交给TCP/IP 协议栈[^39]

>[!hint] 1-3操作都是由网卡的MAC模块来完成的

[^39]:大多数情况下，网卡驱动并不会直接调用协议栈，而是先切换回操作系统，然后再由操作系统去调用协议栈，由协议栈继续执行接收操作
### 网卡的IP模块接收信息
1. 当网络包转交到协议栈后，IP模块首先会检查IP头部的格式和接收方IP地址
    - 当服务器启用类似路由器的包转发功能时，对于不是发给自己的包，会像路由器一样根据路由表对包进行转发
    - 服务器也可以启用类似防火墙的包过滤功能，在包转发的过程中还会对包进行检查，并丢弃不符合规则的包
2. 接下来需要检查包有没有被分片
    - 如果是分片的包，则将包暂时存放在内存中，等所有分片全部到达之后将分片组装起来还原成原始包
    - 如果没有分片，则直接保留接收时的样子
3. 接下来需要检查IP头部的协议号字段，并将包转交给相应的模块
    - 如果协议号为`06`，则将包转交给TCP模块
    - 如果是`11`，则转交给UDP模块
### 网卡的TCP模块处理包
#### 处理连接包
>当TCP头部中的控制位`SYN为1时`，表示这是一个发起连接的包

1. 检查包的接收方端口号
    - 如果指定端口号没有等待连接的套接字，则向客户端返回错误通知的包 
    - 如果存在等待连接的套接字，则为这个套接字复制一个新的副本，并将必要参数[^40]写入这个套接字中
2. 分配用于发送缓冲区和接收缓冲区的内存空间
3. 生成代表接收确认的`ACK号`，生成用于从服务器向客户端发送数据的序号初始值，生成表示接收缓冲区剩余容量的窗口大小，***并用这些信息生成TCP头部***，委托IP模块发送给客户端【这个包只有TCP头部，没有数据】
4. 这个包到达客户端之后，客户端会返回表示接收确认的ACK号，当这个ACK号返回服务器后，连接操作就完成了
5. 当将新套接字的描述符转交给服务器程序之后，服务器程序就会恢复运行

[^40]:发送方IP地址、端口号、序号初始值、窗口大小等
#### 处理数据包
假设包中的数据为HTTP请求消息

1. 首先，TCP模块会检查收到的包对应哪一个套接字
2. 找到 4 种信息全部匹配的套接字之后，TCP模块会对比该套接字中保存的数据收发状态和收到的包的TCP头部中的信息是否匹配，以确定数据收发操作是否正常。
    - 如果正常，就说明包正常到达了服务器，没有丢失。这时，TCP 模块会从包中提出数据，并存放到接收缓冲区中，与上次收到的数据块连接起来
3. 当收到的数据进入接收缓冲区后，TCP模块就会生成确认应答的TCP头部，并根据接收包的序号和数据长度计算出ACK号，然后委托IP模块发送给客户端
4. 接下来，数据会被转交给应用程序
    - 如果应用程序不来获取数据，则数据会被一直保存在缓冲区中
    - 一般来说，应用程序会在数据到达之前等待数据到达

5. 然后，控制流程会转移到服务器程序，对收到的数据进行处理，也就是检查 HTTP 请求消息的内容，并根据请求的内容向浏览器返回相应的数据。这一部分已经超出了 TCP 模块的范围，我们将在稍后探索服务器程序 内部时进行介绍。









## 收到响应
![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=Abd79e9Y|600]]
### 状态码
![[Excalidraw/计算机/四大件/计算机网络 Draw.md#^group=XPJza8ki|600]]
- `200` OK：请求已正常处理，返回所需内容
- 201 Created：请求已成功处理，并创建了新的资源
- 204 No Content：请求已成功处理，但没有返回内容
- 301 Moved Permanently：请求的资源已永久移动到新位置。
- `302` Found：请求的资源已临时移动到新位置
- `304` Not Modified：客户端缓存的资源仍然有效，无需返回内容
- `400` Bad Request：客户端请求有语法错误，服务器不能理解
- 401 Unauthorized：未授权访问资源。
- `403` Forbidden：禁止访问资源，客户端没有权限
- `404` Not Found：请求的资源不存在
- `405` Method Not Allowed：请求方式有误
- `429` Too Many Requests：表示客户端发送的请求过多，在给定的时间内超出了服务器的限制
- `500` Internal Server Error：服务器内部错误，无法完成请求
- `503` Service Unavailable：服务器当前无法处理请求【过载/正在维护/正在初始化】


---

















