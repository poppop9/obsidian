>[!quote] 逻辑结构
>>逻辑结构的物理实现，既可以用数组，也可以用链表
>
>![](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202403140938588.png)

# 顺序表
>就是数组

# 栈
>栈（stack）是一种线性数据结构【它就像放入乒乓球的圆筒容器】，栈中的元素只能先入后出
>![300](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202403141444384.png)

## 数组实现
![](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202403141447497.png)

```java
public class ArrayStack {  
    private int[] stack; // 用数组模拟栈  
    private int top; // 栈顶指针  

	// 构造方法，初始化栈
    public ArrayStack(int size) {      
        stack = new int[size];  
        top = -1;  
    }
    
    // 判断栈是否为空 
    public boolean isEmpty() {  
	    return top == -1;  
	}  

	// 判断栈是否满  
	public boolean isFull() { 
	    return top == stack.length - 1;  
	}

	出栈，入栈，遍历……
}
```

### 入栈
![500](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202403141448967.png)

```java
public void push(int data) { // 入栈操作
	if (isFull()) {
		System.out.println("栈已满，无法入栈");
		return;  // 遇到则不在向下执行
	}
	top++;
	stack[top] = data;
}
```

### 出栈
>![[数据结构 Draw#^group=lFY24zil|440]]

>![[数据结构 Draw#^group=He9FI9L4|450]]

### 遍历
>![[数据结构 Draw#^group=jA2TmRpl|460]]

## 链表实现
>![[数据结构 Draw#^group=t0Z4n07OpeMShDpxo-uI2|560]]

### 入栈
>![[数据结构 Draw#^group=9hF4aVhw|500]]


### 出栈
>![[数据结构 Draw#^group=ONWRFei8|600]]


### 遍历
>![[数据结构 Draw#^group=XqbRWw01|600]]


### 具体实现
>![[数据结构 Draw#^group=OS8QJTia|580]]



## 栈的应用
### 用于面包屑导航
>![[数据结构 Draw#^group=pZmIIFSJ|600]]
>***可以使用户在浏览页面时更快的返回上一级***



# 队列
><mark style="background: #D2B3FFA6;">先入先出</mark>
>![[数据结构 Draw#^group=0FPiwZKa|490]]
>“假如公路上有一条单行隧道，所有通过隧道的车辆只允许从隧道入口驶入，从隧道出口驶出，不允许逆行”
>![[数据结构 Draw#^group=xAIZXY3A|520]]
>***因此，要想让车辆驶出隧道，只能按照它们驶入隧道的顺序。先驶入的车辆先驶出，后驶入的车辆后驶出，任何车辆都无法跳过它前面的车辆提前驶出



## 队列的数组实现
>![[数据结构 Draw#^group=1rQvWB03|500]]

### 入队
>![[数据结构 Draw#^group=SEPFQ5hM|440]]


### 出队
>![[数据结构 Draw#^group=dekwJLVi|490]]


### 遍历
>![[数据结构 Draw#^group=VXN0N3Iz|460]]


### 扩容
>参照数组扩容（使用System.arraycopy函数）


### 具体实现
>![[数据结构 Draw#^group=aCoXSBcT|440]]



## 队列的链表实现
>![[数据结构 Draw#^group=x8xylF2s|600]]



## 队列的应用
- [x] 在多线程中，争夺公平锁的等待队列


- [x] 网络爬虫实现网站抓取，把抓取的网站URL存入队列中，再按照存入队列的顺序来依次抓取和解析



# 双端队列
>![[数据结构 Draw#^group=m0kT3Vap|490]]
>***综合了 栈 和 队列 的优点的数据结构



# 优先队列
## 最大优先队列
>无论入队顺序如何，都是当前最大的元素优先出队





## 最小优先队列
>无论入队顺序如何，都是当前最小的元素优先出队






# 散列表（哈希表）


# 两栈共享空间


# 树
## 二叉树

### 满二叉树




### 完全二叉树

- [x] 二叉堆
	- 最大堆




	- 最小堆


### 二叉排序树（二叉查找树）


## 自平衡
### 红黑树
### AVL树
### 树堆



































