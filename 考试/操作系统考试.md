# 操作系统引论
>操作系统是<u>管理计算机系统硬件，软件资源</u>，<u>合理的对各类作业进行调度</u>，<u>方便用户使用的</u> ***程序的集合***
## 基本特征
- ***并发***：多个活动在给定的时间间隔【==时间段==】中进行
- ***共享***：计算机的资源是被多个进程所共用的
- 异步：进程以不可预知的速度向前推进【A不知道什么时候会被调度】
- 虚拟：把物理上的实体变成逻辑上的对应物

>[!hint] 并发 与 并行
>并行是在同一个时间点上执行多个活动
## 发展
- ***手工操作阶段***【==无操作系统==】
	- 人机速度矛盾
- ***批处理阶段***【==操作系统开始出现==】
	- ***单道批处理阶段***
		- 缓解人机速度矛盾
		- 系统资源利用率依旧很低
	- ***多道批处理阶段***【==操作系统正式诞生==】
		- 资源利用率高
		- 不提供人机交互能力
- ***分时操作系统***
	- 提供人机交互
	- 不能优先处理紧急事务【不能插队】
- ***实时操作系统***【可以插队】
## 两种指令，程序
- 特权指令：不允许用户程序使用，只允许操作系统使用【IO指令，中断指令】
- 非特权指令【普通的运算指令】
---
- 内核程序：可以执行一切指令，运行在***内核态***上
- 应用程序：只能执行非特权指令，运行在***用户态***上

![[Excalidraw/杂/草稿纸 Draw.md#^group=9teYO3aieP3l4HsTksjkX]]
## 其他
原语：是一种原子操作，它是应用程序或进程的***最基本的操作单位***

原语是不可分割的，要么完全执行，要么不执行

执行原语时不会响应任何中断
#####中断和异常
- 内中断
	- 自愿中断
		- 指令中断【需要申请系统资源】
	- 强迫中断
		- 硬件中断
		- 软件中断【0除以0】
- 外中断【外设请求】
#####系统调用
>系统给程序员提供唯一的接口，可获得OS服务，***在用户态发生，在内核态处理***
# 进程与线程
## 进程
>进程：是系统进行资源分配和调度的***基本单位***
#####组成
- PCB：保存进程运行期间的数据，是***进程存在的唯一标志***
- 程序段：被调度到CPU的代码
- 数据段：存放数据
#####🌑进程的状态
- 运行态：进程正在占用CPU
- 就绪态：处于准备运行的状态
- 阻塞态：由于等待某一事件不能享用CPU【==某种条件没满足，进程主动放弃==】
- 创建状态：进程正在被创建
- 结束状态：进程正在从系统消失

![[Excalidraw/杂/草稿纸 Draw.md#^group=iKBUfos2|790]]
#####🌑进程的创建
- ***系统初始化***：开机引导操作系统时，会创建很多前台进程【与用户交互】，后台进程【网络服务，内存交换……】，这些都叫做***守护进程***

- ***派生新进程***：操作系统应一个进程的显式请求而创建新进程

- ***用户请求创建新进程***：为了完成用户的请求，操作系统创建新进程

- ***调度新作业***：操作系统调度某个作业准备运行前，要把它调入内存，创建相应的进程

>[!hint] 创建进程时都要执行创建进程的系统调用【fork()】，主要过程为：
>- 申请一个空闲的PCB【指定进程的标识号】
>- 为新进程分配空间
>- 根据调用者的参数，初始化新进程的PCB
>- ***将新进程加入为就绪状态***
>
> ```
> int main()
> {
>     int pid;
>     pid = fork();  //创建子进程
>     if(pid < 0)      //创建失败
>     {
>         fprintf(stderr, "Fork Failed"); //输出错误消息
>         return 1;  //退出程序
>     }
>     else if(pid == 0)    //子进程
>     {
>         execlp("/bin/ls", "ls", NULL);  //执行ls命令
>     }
>     else   //父进程
>     {
>         wait(NULL);  //等待子进程结束
>         printf("Child Complete");  
>     }
>     return 0;
> }
> ```
## 线程
>线程：程序执行的最小单位

>[!hint] 程序，进程
>- 程序是有序代码的集合，是静态的
>- 进程是程序的执行，是动态的
## 🌗进程关系
管程定义了共享数据结构和各种进程在该数据结构上的全部操作，解决了进程同步
#####同步 - 直接制约关系
>同步是各进程通过对某一对象的共同存取来协调完成某项任务
#####互斥 - 间接制约关系
>互斥是各进程彼此不知道对方的存在，由于竞争同一临界资源[^1]而发生相互制约

临界区：进程中访问临界资源的***那段程序***

一个临界资源可以对应多个临界区

[^1]:一次仅允许一个进程使用的资源【打印机，共享缓冲区，共享变量，公用队列】

>[!hint] 临界区互斥 的四个原则
>- ***空闲让进***：空闲的临界区，一次只允许一个进程进入
>- ***忙则等待***：临界区内有进程，则不允许其他进程进入
>- ***有限等待***：进入临界区内的进程要在有限时间内退出
>- ***让权等待***：如果进程不能进入自己的临界区，则要让出CPU
######🌙信号量 - 解决临界区互斥
PV操作是低级通信原语

信号量S【***只能通过PV操作来改变***】：
- 大于0，表示可用资源数
- 小于0，表示等待的进程数

P操作：P操作一次，消耗一个资源，则S减1
- 如果S≥0，则进程继续执行
- 如果S<0，则进程为阻塞态

V操作：V操作一次，释放一个资源，则S加1

---

![[Excalidraw/杂/草稿纸 Draw.md#^group=LG0LVtMH|800]]
```
// 生产者
while(true) {
	P(empty);  // 可使用的缓冲区数-1
	P(mutex);   // 将互斥信号量减为0，阻止消费者进入
	buffer(in);  // 送入产品
	in = (in+1) mod N
	V(mutex);  // 还原mutex
	V(full);   // 增加产品数
}
```

>[!hint] 两个P操作不可对换，防止empty减为负数，生产者阻塞，消费者也进入不了，产生死锁

```
// 消费者
while(true) {
	P(full);
	P(mutex);
	buffer(out);
	out = (out+1) mod N
	V(mutex);
	V(empty);
}
```
## 🌗死锁
>死锁是多个进程因竞争资源而造成的僵局，***如果没有外力干预，无法破局***

***产生死锁的原因***：
- 不可剥夺资源的竞争
- 进程的不恰当推进顺序，导致请求释放资源不当
	- P<sub>1</sub>申请R<sub>1</sub>，P<sub>2</sub>申请R<sub>2</sub>，P<sub>1</sub>又要申请R<sub>2</sub>，那就出问题了
	- P<sub>1</sub>申请R<sub>1</sub>，P<sub>1</sub>继续申请R<sub>2</sub>，完成，再P<sub>2</sub>申请R<sub>2</sub>，那就没事了

***解决：***
- ***预防***【打破==四个必要条件==中的一个】
	- 破坏互斥条件【有难度】
	- 破坏不可剥夺条件
		- 进程需要的资源申请不到时，释放自己的资源
	- 破坏占有且等待条件【双方占有资源，但都需要对方的资源，而且双方都不释放自己的资源】
		- 让进程一次性申请它所需要的全部资源，不满则不运行【***会造成系统资源严重浪费***】
	- 破坏循环等待条件【P<sub>1</sub>等P<sub>2</sub>的资源，P<sub>2</sub>等P<sub>3</sub>，P<sub>3</sub>等P<sub>1</sub>】
		- 采用顺序资源分配法
- ***避免***
	- 安全状态
	- ==银行家算法==
- ***检测，解除***
	- 利用死锁定理检测 
	- 资源抢占法【拿掉资源，谁也别想要】
	- 撤销进程法【杀进程】
	- 进程回退法【回到上一状态】

![[Excalidraw/杂/草稿纸 Draw.md#^group=SH8nIZot|999]]
# 调度
***分类：***
- 抢占式
- 非抢占式

---

- FIFO
- 最短作业优先
- 优先级调度
- 高响应比优先调度
	- 响应比 = (T<sub>等待</sub> + T<sub>需要运行的时间</sub>) / T<sub>需要运行的时间</sub>
	- ==既兼顾了短作业，也兼顾了长作业==
- 轮转
- 多级反馈队列调度

>[!hint] 公式
>周转时间 = T<sub>完成</sub> - T<sub>到达</sub>
>带权周转时间 = T<sub>周转时间</sub> / T<sub>需要运行的时间</sub>

---

![[Excalidraw/杂/草稿纸 Draw.md#^group=cB0t9FWX|999]]
1. 10:00 A到达, 直接进入内存, 直接进入CPU
2. 10:20 B到达, 直接进入内存, B的优先数高, 所以抢占CPU【A剩余20分钟】
3. 10:30 C到达, B还剩余20分钟, 所以C无法进入内存, B继续运行
4. 10:50 D到达, ==B运行结束==, D进入内存, A的优先级高, 所以运行
5. 11:10 ==A运行结束==, C进入内存, C运行
6. 12:00 ==C运行结束==, D运行
7. 12:20 ==D运行结束==
# 内存管理
>更好地支持多道程序的并发执行，提高系统性能

功能：
- 内存空间的分配与回收
- 存储的保护和共享
	- 保证各道作业互不干扰
- 地址转换
	- 逻辑地址 与 物理地址 的互换
- 内存扩充
	- 使用虚拟存储技术，从逻辑上扩充内存

用户程序的主要处理阶段：
- 编辑阶段【创建源文件】
- 编译阶段【把源文件变成机器可以看懂的机器语言】
- 链接阶段【将库函数等链接在一起，生成可执行文件】
- 装入阶段【将装入模块装入内存】【==形成逻辑地址==】
	- 绝对装入【逻辑地址和实际的内存地址完全一样，***麻烦***】
	- 静态重定位【地址变换<u>在装入时</u>一次完成】
	- 动态重定位【地址变换<u>在执行程序时</u>再完成】
- 运行阶段【得到结果】

## 管理方式
#####连续分配管理方式
- 单一连续分配：分配到内存的固定的区域【==有内部碎片==】
- 固定分区分配：分配到内存的不同的固定区域【==有内部碎片==】
- 动态分区分配：按照程序需要动态分配
	- ***首次适应***：按顺序【==地址递增==】查找并将第一个满足大小的空闲块分配给用户
		- 增大查找开销
	- 最佳适应：遍历整个空闲列表【==容量递增==】，找到所有符合条件的空闲块，然后返回最小的一块
		- 会产生外部碎片
	- 最坏适应：遍历整个空闲列表【==容量递减==】，找到所有符合条件的空闲块，然后返回最大的一块给用户
		- 容易产生内部碎片，对大进程不利
	- 邻近适应：第一次请求为首次适应，后续从上一次分配的位置继续向后搜索，找到满足需求的第一个空闲内存块，将其分配给用户
#####🌑非连续分配管理方式
######分段式

######🌙分页式

######段页式


## 内存扩充
#####覆盖 - 针对同一进程
>比如有一个游戏 `100G` ，那玩的时候，用到那段程序，再加载那段程序，用不到的先不加载
#####交换 - 针对不同进程
>当运行某个大进程时，把内存中的其他进程先放到外存中
#####🌑虚拟内存 - 同一进程的不同页
- 组成部分
	- 页表机制
	- 中断机制
	- 地址交换机制
	- 内存与外存
######🌙页面淘汰算法
- FIFO【先进入内存的页面先出去】
- 最近最久未使用淘汰 LRU【淘汰最久未使用的】
- 最近最少使用淘汰【淘汰最少使用的】
- 最优页面淘汰 OPT【把未来最远使用到的页面淘汰】【==理想状态，很难实现==】

![[Excalidraw/杂/草稿纸 Draw.md#^group=anExIFJM|790]]
- 抖动：系统在频繁地进行页面交换，导致性能严重下降的情况。当系统中的活动页面的数量超过了物理内存的容量，而且操作系统不断地将这些页面从主存储器中换出到辅助存储器中，再换入到主存储器中，就会发生抖动
	- 原因：==分配给进程的进程块不足==

- 页面分配的策略
	- 固定分区局部置换【主存被划分为固定大小的分区，每个分区用于分配给一个特定的进程。如果进程需要更多页面，但没有足够的空闲空间，它必须等待空闲页面可用或进行页面置换】
	- 可变分配局部置换【主存被动态地划分为可变大小的分区，每个分区用于分配给进程。如果进程需要更多页面，但没有足够的空闲空间，它必须等待空闲页面可用或进行页面置换】
	- 可变分配全局置换【主存被动态地划分为可变大小的分区，每个分区用于分配给进程。如果进程需要更多页面，但没有足够的空闲空间，它==可以从其他进程中获取空闲页面==】
# 文件系统 - 外存
>文件：以计算机硬盘为载体存储在计算机上的信息集合

>文件控制块：与进程控制块PCB相同，用于描述文件，一一对应

>文件系统：负责操纵管理文件的设施【==按名存取==，==提高文件的存取速度==】

- ***文件的逻辑结构***
	- 无结构文件【流式文件】
	- 有结构文件【***记录式文件***】
		- 顺序文件【==磁带上的文件一定是顺序文件==】
		- 索引文件
		- 索引顺序文件

---

- ***目录结构***
	- 单级目录【不运行重名】
	- 二级目录【==解决了重名问题==，安全】
		- 主文件目录
		- 用户文件目录
	- 树形目录【方便分类，==不便于共享==】
		- 绝对路径
		- 相对路径
	- 图形目录【==共享==】

---

- 文件分配方式
	- 连续分配【有外部碎片】
	- 链接分配【解决了外部碎片，==不支持直接访问==】
	- 索引分配【加入FAT表也可以直接访问】
## 🌗磁盘调度算法
- 先到先服务算法 FCFS
- 最短查找时间优先算法 SSTF【==会有饥饿问题==】
- 扫描算法/电梯算法 SCAN【从前往后，从后往前】
- 循环扫描算法【从前往后，再从前往后】

![[Excalidraw/杂/草稿纸 Draw.md#^group=SlcIdYBd|790]]
# 设备管理
## IO设备
- 输入输出设备
- 存储设备

---

- 块设备
	- 比如磁盘……，可以寻址
- 字符设备
	- 打印机，中断机
#####控制方式
- 程序直接控制方式【传输以 `字节` 为单位】
>CPU一直都在探寻设备控制器是否将数据放到数据存储器中，==当完成后，CPU才能去干其他事情==

- 中断方式【CPU 与 IO设备 并行工作，传输以 `字节` 为单位】
>当CPU发出指令后就去干其他事情，当设备控制器把数据存在数据存储器后，==发出中断请求==，然后CPU再来处理数据
>
>***缺点***：中断次数过多，CPU利用率还是很低

- DMA方式【解决了中断方式的缺点】
>DMA控制器将设备中的数据以==数据块为单位==传输到内存中，传输结束后再向CPU发起中断
>
>***优点***：介于 `IO设备` 与 `主存` 之间，所以CPU利用率提高了
>***缺点***：只能处理多个连续的数据块

- IO通道控制方式
>CPU通过对IO通道【弱鸡版CPU】发出指令，让IO通道自己工作，等数据传输完才向CPU发出中断
>
>***优点***：介于内存与外设之间，解决了DMA方式的缺点

## 缓冲区
- ***引入缓冲区的目的***
>- 缓和CPU与外设之间速度不匹配的矛盾
>- 提高CPU与外设的并行性
>- 减少CPU的中断次数

---

- 缓冲区的设置方式【==缓冲区只有空时才能放数据，只有满时才能取数据==】
	- 单缓冲【在设备与CPU之间】
	- 双缓冲
	- 多缓冲

---

虚拟分配技术【将独占设备->共享设备】：SPOOLing技术【假脱机技术】，提高了IO速率

---
未学习：
- 第二章
	- p<sub>43</sub> 进程控制块
	- 2.4 线程

---
选择题4，填空题1，2，4















