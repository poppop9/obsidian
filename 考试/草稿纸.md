
# 第五章
这两个用例之间存在顺序关系，即"存款"用例必须在"取款"用例之前执行。
在执行取款操作之前，通常需要先进行余额查询，以确保账户中有足够的余额可供取款。因此，"取款"用例和"查余额"用例之间存在依赖关系，"取款"用例依赖于"查余额"用例的执行结果。

---
"创建新订单"和"更新订单"两个用例与"核查客户账户"用例之间存在依赖关系

---
n个

---
分解关系

---
1. 包图(Package Diagram)
描绘软件系统的组件和它们之间的依赖关系。体现系统的高层模块划分。

2. 组件图(Component Diagram)
显示软件系统各组件及它们之间的接口。说明组件的职责和依赖关系。

3. 部署图(Deployment Diagram)
显示系统如何映射到底层的节点和设备上的物理部署情况。

4. 结构图(Class Diagram)
显示系统各种类之间的依赖和关系,特别是聚合和组合关系。

5. 对象图(Object Diagram)
显示结构图在特定时间点的一个 possível实例。

6. 组合结构图(Composite Structure Diagram)
着重描述类的内部结构,展示类的属性和操作以及与其他类的通信接口。

7. 动态结构图(Sequence Diagram & Communication Diagram)
描述对象之间消息的发送顺序和沟通情景,用于描述系统运行时的协作关系。

---
类图
在为同一个软件系统建模的过程中,不需要将UML所有的图形都画出来
- 不同类型的图表现不同视角的设计信息。不必重复画同一个视角下的内容。
- 不同阶段需要关注的重点不同。初期可以只关注关键类和模块,忽略细节。
- 过多关系会增加图的复杂度,降低可读性。只画最相关的部分。
- 不同阶段需要表达的信息不一样。如需重点说明运行情况则用时序图。
- 过多图会增加维护成本。图之间应有合理的分割与关联。

---
一、M0层:实体层(Object Layer)
这个层面包含软件系统中具体的组件、模块、类等实体对象。

二、M1层:类型层(Type Layer)
这个层面描述M0层中的实体对象的数据类型,比如类的结构定义、接口定义等。

三、M2层:元层(Metamodel Layer)
这个层面定义M1层中数据类型的语法和约束。例如UML图中的类图、组件图等模型。

四、M3层:超元层(Metametamodel Layer)
这一层面定义M2层中的UML语言本身的语法规则,即UML元模型。

使用4层描述体系结构:
1. M0层包含实际运行的组件、对象实例等。
2. M1层描述这些组件、对象的抽象类型定义。
3. M2层使用UML描述M1层中的类型,如类图、组件图等。
4. M3层固定为UML自身的元模型规约。

---
留言本系统:
1. 用类图描述系统主要的类及其关系:
MessageBoard系统具有MessageBoard、User、Message这3个主要类:
- MessageBoard包含一个用户列表和留言列表
- User包含用户名和密码
- Message包含内容和发布用户

用户可以登陆和发布留言,留言归于某个留言板,这表现为聚合关系。

2. 用组件图描述系统的不同模块:
MessageBoard系统包含UserManagement、MessageManagement和Display两个主要组件:
- UserManagement负责用户注册登录等操作
- MessageManagement负责留言发布和管理
- Display组件负责前端页面展示

3. 用时序图描述一个典型的操作流程:
如用户登录后发布留言,涵盖了UserManagement和MessageManagement的交互

4. 用部署图描述系统在技术环境中的部署:
MessageBoard系统部署在三台服务器上,分别承担Web、App和DB三个层级功能

# 第六章
- SGML为HTML和XML提供了标准的定义基础。
- HTML继承了SGML的特点,专注于表示网页面。
- XML是SGML的一种简化应用版本,更易于使用。
- XHTML基于XML标准,是HTML的后继版本,需要严格按规范书写。

---
- CSS控制着页面元素的表现样式。
- XSL可以转换XML格式。
- DOM定义了一种程序与页面元素进行交互的标准方式。

---
1. 加载XML文档
通过DOM将XML文档加载为XMLDocument对象,读取整个XML文档内容到内存中。

2. 访问/选择元素
通过DOM提供的document.documentElement获取XML的根元素节点。
利用getElementByName或getElementsByTagName等方法,可以选择指定名称的元素节点。

3. 遍历元素树
通过节点的parentNode、childNodes、firstChild、lastChild属性等,可以递归遍历访问整个元素树的每个节点。

4. 接入节点属性
通过nodeName、nodeType等属性可以获取节点本身信息。通过getAttribute方法读取属性值。

5. 创建/修改元素
createElement方法创建新节点,appendChild加入子节点树。可以修改节点文本内容或属性值。

6. 保存XML文档
通过XMLSerializer将文档对象序列化为XML字符串,或者直接写入硬盘更新源文件。

7. 事件处理
DOM Level 2定义了事件处理接口,可以注册函数在节点位置相关事件发生时触发。

---
- DOM:
优点:标准接口,支持所有XML功能。兼容性好。
缺点:性能较低,内存消耗大。
应用:需要完整访问和修改XML文档结构。

- SAX:
优点:事件驱动,性能高,内存消耗小。
缅点:只支持解析,不方便修改文档。
应用:只需要解析而不修改XML的场景。

- JDOM:
优点:操作容易,性能好于DOM。支持选择和修改。
缺点:不太标准,兼容性差。
应用:需要修改XML的Java程序。

- DOM4J:
优点:性能和标准性好于JDOM。
缺点:较DOM4J难用一些。
应用:性能要求高的Java XML程序。

- XPath/XSLT:
优点:方便选择和转换XML文档。
缺点:转换后不利于后续操作。
应用:需要转换XML结构的场景。

---
1. 物联网通信。随着物联网的发展,XML极为适合用来定义设备间的通信协议格式。它结构清晰、可扩展性强,有利于各种设备之间的互操作。
2. 大数据分析。XML能很好地存储和传输结构化数据,有利于异构数据源之间信息的聚合和交换。它在大数据领域可能会有更广泛的应用。
3. 配置描述语言。隐私架构中,XML可能成为描述各种组件能力和限制的通用语言。它能彻底表达复杂系统各个部分的关系。
4. 生物医学信息交换。随着生命科学领域数据量激增,XML有望成为分享和融合各种生命科学数据的重要载体格式。
5. 可编程文档。随着智能语音识别等技术的发展,XML也许可以直接表达“可编程”文档,支持更高层次的语义理解和自动执行。
6. 数字出版物。XML可能取代PDF成为出版发行的主流格式,充分发挥其结构化和交互性能力。

---
1. 使用XADL2.0描述系统结构:
<xadl2:processArchitecture name="B/S系统">

<xadl2:layer name="表现层">  
<xadl2:component name="浏览器"/>  
</xadl2:layer>

<xadl2:layer name="业务层">  
<xadl2:component name="应用服务器">  
<xadl2:implementsInterface interface="用户功能"/>  
</xadl2:component>  
</xadl2:layer>

<xadl2:layer name="数据层">  
<xadl2:component name="数据库"/>  
</xadl2:layer>

</xadl2:processArchitecture>

2. 使用XBA描述用户功能:
<xba:usecase id="用户功能">

<xba:actor name="用户"/>

<xba:scenario name="注册">  
xba:step用户填写注册信息</xba:step>  
xba:step应用服务器验证并保存注册信息</xba:step>  
</xba:scenario>

<xba:scenario name="登录">  
xba:step用户输入用户名密码</xba:step>  
xba:step应用服务器验证用户信息</xba:step>  
</xba:scenario>

</xba:usecase>


|字段|帧1|帧2|
|:-:|:-:|:-:|
|协议|HTTP|TCP|
|目的MAC|90:23:b4:69:d8:02 |1c:69:7a:54:6d:e6|
|源MAC地址|1c:69:7a:54:6d:e6 |90:23:b4:69:d8:02|
|类型|IPv4|IPv4|
|帧总长 |780 bytes|1514 bytes|

%$ fdffsdfjskldjfksldj
`%$fdlsjlf%`

>[!hint] 以上的SQL语句用了“#{}”占位符，就是***预编译SQL语句***
>>=="#{}"不能放在***单引号***或***多引号***之间使用==
>>如果一定要在引号里进行占位符，要使用“${}”，`name$`
>
>预编译SQL语句有两个优点：
>- 性能高，因为不同参数的SQL语句只用编译一遍【MYSQL有缓存机制】
>- 安全：防止了SQL注入【用户使用输入数据来篡改SQL语句】

$$
Aaaasklfj
$$

$aaaaaaaaaaaaaaAAAAAAA$









本书的目的就是希望能够缩短新技术推广周期，使广大的程序员们可以迅速地获得软件开发的最新方法与手段。本书所面向的对象，本书中所收集的研究和编程经验，将有助于你编写出高质量的软件，并且使得开发周期缩短。通过阅读本书，同时，书中所收集的丰富的编程经验也将使你在控制大规模项目和按要求对软件进行修改和维护时感到得心应手。





香港大学

新加坡国立大学

斯坦福大学

中国科学技术大学

华南师范大学

香港科技大学

国立台湾大学

广轻工

深圳职业技术大学

东莞理工学院

广东财经大学

哈佛大学



类别一：国际知名大学

- 斯坦福大学
- 哈佛大学



斯坦福大学官网:

优点:

1. 设计clean简洁,视觉层次清晰,排版整齐。
2. 首页使用大图片展示校园风景,给人带来温馨舒适的感觉。
3. 导航条结构合理,主导航分类设置合理。
4. 搜索栏位置便利,功能强大。
5. 页面加载速度快。

缺点:

1. 部分内容设置得较密集,阅读体验可能不如哈佛网站。
2. 首页更新信息栏位置较偏,需要往下拉。
3. 个性化定制功能相对单一。

哈佛大学官网:

优点:

1. 设计风格经典大方,充满学术气息。
2. 首页主要信息区域设置开阔明亮,便于查阅。
3. 内容丰富层次分明,各类资源分类设置到位。
4. 个性化菜单设置周到,可以设置邮件提醒等。
5. 兼容性好,在不同设备上都有良好的显示效果。

缺点:

1. 初始加载速度略慢于斯坦福网站。
2. 个别次级页面分类设置不够清晰。
3. 界面较为复杂,对移动端浏览体验有待优化。

类别二：顶尖亚洲大学

- 香港大学
- 新加坡国立大学
- 中国科学技术大学
- 香港科技大学
- 国立台湾大学

类别三：地区知名大学

- 华南师范大学
- 广轻工
- 深圳职业技术大学
- 东莞理工学院
- 广东财经大学


$$
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.mapper.UserMapperXml">
    <!--resultType表示的是单条记录所封装的类型-->
    <select id="SelectAll" resultType="com.example.Pojo.user">
        select * from user
    </select>
</mapper>
$$

$$
中文
$$





0AC5H=101011000101，d=1011000101)，p=10。通过页表2得知，对应的物理块号是4。第4块的首址为4K，所以物理地址为1001011000101=12C5H，合成物理地址为12C5H

1AC5H=1101011000101，得d=101000101，p=110，页表中没有该页号，此时发生缺页中断，将根据当前的页面调度策略选择页表当中的一项调换出内存，假设选择第0页，则第6页获得内存物理块号8，所以物理地址为10001011000101=22C5H，合成物理地址为22C5H

3AC5H=11101011000101，得d=101000101，p=111，页表中没有该页号，根据页面调度策略选择页表当中的一项调换出内存，假设选择第1页，则第7页获得内存物理块号7，所以物理地址为 1111011000101=1EC5H，合成物理地址为1EC5H



1. cpu空闲时发生在100ms-150ms之间
2. B程序有等待cpu的情况，在180-220ms时


1. 
    - 作业A：进入内存时间为8:00，结束时间为8:40
    - 作业B：进入内存时间为8:20，结束时间为8:50
    - 作业C：进入内存时间为8:30，结束时间为9:20
    - 作业D：进入内存时间为8:50，结束时间为9:10
2. 计算平均周转时间和平均带权周转时间：
    - 作业A：周转时间 = 8:40 - 8:00 = 40分钟，带权周转时间 = 40 / 40 = 1
    - 作业B：周转时间 = 8:50 - 8:20 = 30分钟，带权周转时间 = 30 / 30 = 1
    - 作业C：周转时间 = 9:20 - 8:30 = 50分钟，带权周转时间 = 50 / 50 = 1
    - 作业D：周转时间 = 9:10 - 8:50 = 20分钟，带权周转时间 = 20 / 20 = 1
    
    平均周转时间 = (40 + 30 + 50 + 20) / 4 = 35分钟  
    平均带权周转时间 = (1 + 1 + 1 + 1) / 4 = 1
3. 结果将保持不变。由于作业的优先级已经在作业调度时确定，并且不会发生变化，因此作业的执行顺序和结束时间将保持不变，平均周转时间和平均带权周转时间也将保持不变







