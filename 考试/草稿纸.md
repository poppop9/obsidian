
# 第五章
这两个用例之间存在顺序关系，即"存款"用例必须在"取款"用例之前执行。
在执行取款操作之前，通常需要先进行余额查询，以确保账户中有足够的余额可供取款。因此，"取款"用例和"查余额"用例之间存在依赖关系，"取款"用例依赖于"查余额"用例的执行结果。

---
"创建新订单"和"更新订单"两个用例与"核查客户账户"用例之间存在依赖关系

---
n个

---
分解关系

---
1. 包图(Package Diagram)
描绘软件系统的组件和它们之间的依赖关系。体现系统的高层模块划分。

2. 组件图(Component Diagram)
显示软件系统各组件及它们之间的接口。说明组件的职责和依赖关系。

3. 部署图(Deployment Diagram)
显示系统如何映射到底层的节点和设备上的物理部署情况。

4. 结构图(Class Diagram)
显示系统各种类之间的依赖和关系,特别是聚合和组合关系。

5. 对象图(Object Diagram)
显示结构图在特定时间点的一个 possível实例。

6. 组合结构图(Composite Structure Diagram)
着重描述类的内部结构,展示类的属性和操作以及与其他类的通信接口。

7. 动态结构图(Sequence Diagram & Communication Diagram)
描述对象之间消息的发送顺序和沟通情景,用于描述系统运行时的协作关系。

---
类图
在为同一个软件系统建模的过程中,不需要将UML所有的图形都画出来
- 不同类型的图表现不同视角的设计信息。不必重复画同一个视角下的内容。
- 不同阶段需要关注的重点不同。初期可以只关注关键类和模块,忽略细节。
- 过多关系会增加图的复杂度,降低可读性。只画最相关的部分。
- 不同阶段需要表达的信息不一样。如需重点说明运行情况则用时序图。
- 过多图会增加维护成本。图之间应有合理的分割与关联。

---
一、M0层:实体层(Object Layer)
这个层面包含软件系统中具体的组件、模块、类等实体对象。

二、M1层:类型层(Type Layer)
这个层面描述M0层中的实体对象的数据类型,比如类的结构定义、接口定义等。

三、M2层:元层(Metamodel Layer)
这个层面定义M1层中数据类型的语法和约束。例如UML图中的类图、组件图等模型。

四、M3层:超元层(Metametamodel Layer)
这一层面定义M2层中的UML语言本身的语法规则,即UML元模型。

使用4层描述体系结构:
1. M0层包含实际运行的组件、对象实例等。
2. M1层描述这些组件、对象的抽象类型定义。
3. M2层使用UML描述M1层中的类型,如类图、组件图等。
4. M3层固定为UML自身的元模型规约。

---
留言本系统:
1. 用类图描述系统主要的类及其关系:
MessageBoard系统具有MessageBoard、User、Message这3个主要类:
- MessageBoard包含一个用户列表和留言列表
- User包含用户名和密码
- Message包含内容和发布用户

用户可以登陆和发布留言,留言归于某个留言板,这表现为聚合关系。

2. 用组件图描述系统的不同模块:
MessageBoard系统包含UserManagement、MessageManagement和Display两个主要组件:
- UserManagement负责用户注册登录等操作
- MessageManagement负责留言发布和管理
- Display组件负责前端页面展示

3. 用时序图描述一个典型的操作流程:
如用户登录后发布留言,涵盖了UserManagement和MessageManagement的交互

4. 用部署图描述系统在技术环境中的部署:
MessageBoard系统部署在三台服务器上,分别承担Web、App和DB三个层级功能

# 第六章
- SGML为HTML和XML提供了标准的定义基础。
- HTML继承了SGML的特点,专注于表示网页面。
- XML是SGML的一种简化应用版本,更易于使用。
- XHTML基于XML标准,是HTML的后继版本,需要严格按规范书写。

---
- CSS控制着页面元素的表现样式。
- XSL可以转换XML格式。
- DOM定义了一种程序与页面元素进行交互的标准方式。

---
1. 加载XML文档
通过DOM将XML文档加载为XMLDocument对象,读取整个XML文档内容到内存中。

2. 访问/选择元素
通过DOM提供的document.documentElement获取XML的根元素节点。
利用getElementByName或getElementsByTagName等方法,可以选择指定名称的元素节点。

3. 遍历元素树
通过节点的parentNode、childNodes、firstChild、lastChild属性等,可以递归遍历访问整个元素树的每个节点。

4. 接入节点属性
通过nodeName、nodeType等属性可以获取节点本身信息。通过getAttribute方法读取属性值。

5. 创建/修改元素
createElement方法创建新节点,appendChild加入子节点树。可以修改节点文本内容或属性值。

6. 保存XML文档
通过XMLSerializer将文档对象序列化为XML字符串,或者直接写入硬盘更新源文件。

7. 事件处理
DOM Level 2定义了事件处理接口,可以注册函数在节点位置相关事件发生时触发。

---
- DOM:
优点:标准接口,支持所有XML功能。兼容性好。
缺点:性能较低,内存消耗大。
应用:需要完整访问和修改XML文档结构。

- SAX:
优点:事件驱动,性能高,内存消耗小。
缅点:只支持解析,不方便修改文档。
应用:只需要解析而不修改XML的场景。

- JDOM:
优点:操作容易,性能好于DOM。支持选择和修改。
缺点:不太标准,兼容性差。
应用:需要修改XML的Java程序。

- DOM4J:
优点:性能和标准性好于JDOM。
缺点:较DOM4J难用一些。
应用:性能要求高的Java XML程序。

- XPath/XSLT:
优点:方便选择和转换XML文档。
缺点:转换后不利于后续操作。
应用:需要转换XML结构的场景。

---
1. 物联网通信。随着物联网的发展,XML极为适合用来定义设备间的通信协议格式。它结构清晰、可扩展性强,有利于各种设备之间的互操作。
2. 大数据分析。XML能很好地存储和传输结构化数据,有利于异构数据源之间信息的聚合和交换。它在大数据领域可能会有更广泛的应用。
3. 配置描述语言。隐私架构中,XML可能成为描述各种组件能力和限制的通用语言。它能彻底表达复杂系统各个部分的关系。
4. 生物医学信息交换。随着生命科学领域数据量激增,XML有望成为分享和融合各种生命科学数据的重要载体格式。
5. 可编程文档。随着智能语音识别等技术的发展,XML也许可以直接表达“可编程”文档,支持更高层次的语义理解和自动执行。
6. 数字出版物。XML可能取代PDF成为出版发行的主流格式,充分发挥其结构化和交互性能力。

---
1. 使用XADL2.0描述系统结构:
<xadl2:processArchitecture name="B/S系统">

<xadl2:layer name="表现层">  
<xadl2:component name="浏览器"/>  
</xadl2:layer>

<xadl2:layer name="业务层">  
<xadl2:component name="应用服务器">  
<xadl2:implementsInterface interface="用户功能"/>  
</xadl2:component>  
</xadl2:layer>

<xadl2:layer name="数据层">  
<xadl2:component name="数据库"/>  
</xadl2:layer>

</xadl2:processArchitecture>

2. 使用XBA描述用户功能:
<xba:usecase id="用户功能">

<xba:actor name="用户"/>

<xba:scenario name="注册">  
xba:step用户填写注册信息</xba:step>  
xba:step应用服务器验证并保存注册信息</xba:step>  
</xba:scenario>

<xba:scenario name="登录">  
xba:step用户输入用户名密码</xba:step>  
xba:step应用服务器验证用户信息</xba:step>  
</xba:scenario>

</xba:usecase>