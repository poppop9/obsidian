
# 第五章
这两个用例之间存在顺序关系，即"存款"用例必须在"取款"用例之前执行。
在执行取款操作之前，通常需要先进行余额查询，以确保账户中有足够的余额可供取款。因此，"取款"用例和"查余额"用例之间存在依赖关系，"取款"用例依赖于"查余额"用例的执行结果。

---
"创建新订单"和"更新订单"两个用例与"核查客户账户"用例之间存在依赖关系

---
n个

---
分解关系

---
1. 包图(Package Diagram)
描绘软件系统的组件和它们之间的依赖关系。体现系统的高层模块划分。

2. 组件图(Component Diagram)
显示软件系统各组件及它们之间的接口。说明组件的职责和依赖关系。

3. 部署图(Deployment Diagram)
显示系统如何映射到底层的节点和设备上的物理部署情况。

4. 结构图(Class Diagram)
显示系统各种类之间的依赖和关系,特别是聚合和组合关系。

5. 对象图(Object Diagram)
显示结构图在特定时间点的一个 possível实例。

6. 组合结构图(Composite Structure Diagram)
着重描述类的内部结构,展示类的属性和操作以及与其他类的通信接口。

7. 动态结构图(Sequence Diagram & Communication Diagram)
描述对象之间消息的发送顺序和沟通情景,用于描述系统运行时的协作关系。

---
类图
在为同一个软件系统建模的过程中,不需要将UML所有的图形都画出来
- 不同类型的图表现不同视角的设计信息。不必重复画同一个视角下的内容。
- 不同阶段需要关注的重点不同。初期可以只关注关键类和模块,忽略细节。
- 过多关系会增加图的复杂度,降低可读性。只画最相关的部分。
- 不同阶段需要表达的信息不一样。如需重点说明运行情况则用时序图。
- 过多图会增加维护成本。图之间应有合理的分割与关联。

---
一、M0层:实体层(Object Layer)
这个层面包含软件系统中具体的组件、模块、类等实体对象。

二、M1层:类型层(Type Layer)
这个层面描述M0层中的实体对象的数据类型,比如类的结构定义、接口定义等。

三、M2层:元层(Metamodel Layer)
这个层面定义M1层中数据类型的语法和约束。例如UML图中的类图、组件图等模型。

四、M3层:超元层(Metametamodel Layer)
这一层面定义M2层中的UML语言本身的语法规则,即UML元模型。

使用4层描述体系结构:
1. M0层包含实际运行的组件、对象实例等。
2. M1层描述这些组件、对象的抽象类型定义。
3. M2层使用UML描述M1层中的类型,如类图、组件图等。
4. M3层固定为UML自身的元模型规约。

---
留言本系统:
1. 用类图描述系统主要的类及其关系:
MessageBoard系统具有MessageBoard、User、Message这3个主要类:
- MessageBoard包含一个用户列表和留言列表
- User包含用户名和密码
- Message包含内容和发布用户

用户可以登陆和发布留言,留言归于某个留言板,这表现为聚合关系。

2. 用组件图描述系统的不同模块:
MessageBoard系统包含UserManagement、MessageManagement和Display两个主要组件:
- UserManagement负责用户注册登录等操作
- MessageManagement负责留言发布和管理
- Display组件负责前端页面展示

3. 用时序图描述一个典型的操作流程:
如用户登录后发布留言,涵盖了UserManagement和MessageManagement的交互

4. 用部署图描述系统在技术环境中的部署:
MessageBoard系统部署在三台服务器上,分别承担Web、App和DB三个层级功能

# 第六章
- SGML为HTML和XML提供了标准的定义基础。
- HTML继承了SGML的特点,专注于表示网页面。
- XML是SGML的一种简化应用版本,更易于使用。
- XHTML基于XML标准,是HTML的后继版本,需要严格按规范书写。

---
- CSS控制着页面元素的表现样式。
- XSL可以转换XML格式。
- DOM定义了一种程序与页面元素进行交互的标准方式。

---
1. 加载XML文档
通过DOM将XML文档加载为XMLDocument对象,读取整个XML文档内容到内存中。

2. 访问/选择元素
通过DOM提供的document.documentElement获取XML的根元素节点。
利用getElementByName或getElementsByTagName等方法,可以选择指定名称的元素节点。

3. 遍历元素树
通过节点的parentNode、childNodes、firstChild、lastChild属性等,可以递归遍历访问整个元素树的每个节点。

4. 接入节点属性
通过nodeName、nodeType等属性可以获取节点本身信息。通过getAttribute方法读取属性值。

5. 创建/修改元素
createElement方法创建新节点,appendChild加入子节点树。可以修改节点文本内容或属性值。

6. 保存XML文档
通过XMLSerializer将文档对象序列化为XML字符串,或者直接写入硬盘更新源文件。

7. 事件处理
DOM Level 2定义了事件处理接口,可以注册函数在节点位置相关事件发生时触发。

---
- DOM:
优点:标准接口,支持所有XML功能。兼容性好。
缺点:性能较低,内存消耗大。
应用:需要完整访问和修改XML文档结构。

- SAX:
优点:事件驱动,性能高,内存消耗小。
缅点:只支持解析,不方便修改文档。
应用:只需要解析而不修改XML的场景。

- JDOM:
优点:操作容易,性能好于DOM。支持选择和修改。
缺点:不太标准,兼容性差。
应用:需要修改XML的Java程序。

- DOM4J:
优点:性能和标准性好于JDOM。
缺点:较DOM4J难用一些。
应用:性能要求高的Java XML程序。

- XPath/XSLT:
优点:方便选择和转换XML文档。
缺点:转换后不利于后续操作。
应用:需要转换XML结构的场景。

---
1. 物联网通信。随着物联网的发展,XML极为适合用来定义设备间的通信协议格式。它结构清晰、可扩展性强,有利于各种设备之间的互操作。
2. 大数据分析。XML能很好地存储和传输结构化数据,有利于异构数据源之间信息的聚合和交换。它在大数据领域可能会有更广泛的应用。
3. 配置描述语言。隐私架构中,XML可能成为描述各种组件能力和限制的通用语言。它能彻底表达复杂系统各个部分的关系。
4. 生物医学信息交换。随着生命科学领域数据量激增,XML有望成为分享和融合各种生命科学数据的重要载体格式。
5. 可编程文档。随着智能语音识别等技术的发展,XML也许可以直接表达“可编程”文档,支持更高层次的语义理解和自动执行。
6. 数字出版物。XML可能取代PDF成为出版发行的主流格式,充分发挥其结构化和交互性能力。

---
1. 使用XADL2.0描述系统结构:
<xadl2:processArchitecture name="B/S系统">

<xadl2:layer name="表现层">  
<xadl2:component name="浏览器"/>  
</xadl2:layer>

<xadl2:layer name="业务层">  
<xadl2:component name="应用服务器">  
<xadl2:implementsInterface interface="用户功能"/>  
</xadl2:component>  
</xadl2:layer>

<xadl2:layer name="数据层">  
<xadl2:component name="数据库"/>  
</xadl2:layer>

</xadl2:processArchitecture>

2. 使用XBA描述用户功能:
<xba:usecase id="用户功能">

<xba:actor name="用户"/>

<xba:scenario name="注册">  
xba:step用户填写注册信息</xba:step>  
xba:step应用服务器验证并保存注册信息</xba:step>  
</xba:scenario>

<xba:scenario name="登录">  
xba:step用户输入用户名密码</xba:step>  
xba:step应用服务器验证用户信息</xba:step>  
</xba:scenario>

</xba:usecase>


|字段|帧1|帧2|
|:-:|:-:|:-:|
|协议|HTTP|TCP|
|目的MAC|90:23:b4:69:d8:02 |1c:69:7a:54:6d:e6|
|源MAC地址|1c:69:7a:54:6d:e6 |90:23:b4:69:d8:02|
|类型|IPv4|IPv4|
|帧总长 |780 bytes|1514 bytes|

%$ fdffsdfjskldjfksldj
`%$fdlsjlf%`

>[!hint] 以上的SQL语句用了“#{}”占位符，就是***预编译SQL语句***
>>=="#{}"不能放在***单引号***或***多引号***之间使用==
>>如果一定要在引号里进行占位符，要使用“${}”，`name$`
>
>预编译SQL语句有两个优点：
>- 性能高，因为不同参数的SQL语句只用编译一遍【MYSQL有缓存机制】
>- 安全：防止了SQL注入【用户使用输入数据来篡改SQL语句】

$$
Aaaasklfj
$$

$aaaaaaaaaaaaaaAAAAAAA$







关于软件开发的研究，进展是非常迅速的，但是开发实践却并非如此。许多程序仍然是错误百出，充斥着过时的技术，从而无法满足用户需要。软件工业界和学术界的研究者们，基本上已经解决了七十年代和八十年代在编程中遇到的问题，并发展了相应的技术。但是直到现在，这些技术中的大部分仍然没有在软件编程中广泛采用，其主要原因是这些研究成果主要发表在高度专业性的学术刊物中，普通的程序员们无心顾及。研究表明，一项新技术从诞生到被工业界广泛采用大约需要5 到15 年的时间。

本书的目的就是希望能够缩短新技术推广周期，使广大的程序员们可以迅速地获得软件开发的最新方法与手段。本书所面向的对象，本书中所收集的研究和编程经验，将有助于你编写出高质量的软件，并且使得开发周期缩短。通过阅读本书，同时，书中所收集的丰富的编程经验也将使你在控制大规模项目和按要求对软件进行修改和维护时感到得心应手。



本书的独特内容
事实上，卓有成效的优秀程序员们所使用的技术并不神秘，但由于日常事务的繁重和工作任务的重压，程序员们很少有互相交流切磋的时间，因而，他们往往缺乏有关编程技巧的有效信息来源。本书中所论述的技术不仅填补了初级与高级编程课本之间的空白，而且也为程序员们提供了一个有关编程技巧的信息来源。比如当你读过C 语言初级教程之后，你可以再读C 语言高级教程，然后再去读C 语言高级的高级教程，但读完这些书后，你还能再读什么书呢？

你可以再去读关于PC、Macintosh 或UNIX 等硬件或操作系统的书或者其它有关编程细节的书——因为你如果不了解实现环境详情的话是无法充分有效地使用语言和程序的。但这只是讨论了编程的一个方面，最有效的编程技术是那些不受实现环境及语言限制的技术。其它书往往忽略了这一点，但这恰恰是本书的重点。



浅读《代码大全》后我有几个点收获

首先，《代码大全》强调了代码质量的重要性。它提醒我们编写代码时要注重可读性、可维护性和可扩展性。书中介绍了很多提高代码质量的技术，例如模块化设计、良好的命名规范、合适的注释和文档编写等。通过遵循这些原则，我们可以编写出易于理解和维护的代码，减少后续开发和维护工作的难度。

其次，《代码大全》对软件开发过程中的一些常见问题给出了解决方案。例如，它介绍了如何进行需求分析和软件设计，如何进行错误处理和调试，以及如何进行性能优化等。这些问题在实际的软件开发中经常会遇到，而《代码大全》提供了一些实用的技巧和方法，帮助我们更好地应对这些挑战。

另外，《代码大全》还介绍了一些代码风格和编程实践的准则。它强调了一致性的重要性，建议我们在编写代码时遵循一定的规范和约定。这样可以使团队成员更容易理解彼此的代码，并且减少潜在的错误。此外，书中还提供了一些常见的编程陷阱和反模式，帮助我们避免一些常见的错误和陷阱。











