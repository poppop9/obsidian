数据结构是由一个/多个数据结构，或一个/多个<u>数据项</u>【不可再分的最小单位】

软件开发的6个步骤：
七个步骤：问题定义……
八个步骤：……维护

# 基础概述
>[!hint] 软件危机表现
>- 软件项目无法按期完成
>- 软件开发费用超出预算
>- 软件项目质量难以控制
>- 软件系统运行难以维护

---

>[!quote] bug / 软件错误 / 软件缺陷
>计算机系统或程序中存在的任何一种破坏正常运行能力的问题，错误，或隐藏的功能缺陷
>
>- 四个级别：
> 	- **致命的**：对整个系统产生了影响；高价值的用户数据丢失【~~因为数据丢失很难恢复~~】
> 	- **严重的**：主要功能模块里面有 bug，导致主要功能无法运行
> 	- **一般的**：次要功能不太理想
> 	- **微小的**：对功能基本没有影响

>[!quote] 软件测试
>- **目标**：发现错误
>- **定义**
>	- 狭义定义：软件测试是为了发现错误而执行程序的过程【~~在狭义定义里，软件测试只有执行程序~~】
>	- 广义定义：需求分析、设计评审、代码审查、配置管理、持续集成、性能监控、安全测试、用户验收测试，测试执行程序【~~在广义定义里，软件测试不仅仅只是执行程序~~】

>[!quote] 软件测试的辩证观
>- 正向思维：确保测试与业务目标和用户需求相一致，逐个验证功能的正确性
>- 反向思维：挑战现有的假设和测试策略，寻找可能被忽视的问题和风险，找出系统弱点

# 软件测试策略
## 软件测试的生命周期
- **软件测试顺序**：功能测试，性能测试，可靠性测试【~~麻烦~~】，安全性测试【~~麻烦~~】

## 测试用例
>[!quote] 测试用例
>测试用例 就是测试的输入数据，和预期结果的描述
>三要素：
>- 输入数据
>- 覆盖路径
>- 预期结果

# 黑盒测试
>[!quote] 黑盒测试 / 功能测试
>黑盒测试 就是把程序和测试对象看成一个黑盒子，验证输入和输出之间的关系，<u>不考虑程序内部的结构和特征</u>，目标是测试程序的功能和接口

## 等价类 - 大题
- **有效等价类**：对于软件规格来说，是合理的，有意义的输入数据的集合，<u>用于检查是否实现了规定的内容</u>
- **无效等价类**：对于软件规格来说，是不合理的，无意义的输入数据的集合，<u>用于检查软件对于异常情况的反应</u>

>[!hint] 等价类的划分原则
>- 在输入条件规定了取值范围的情况下，则可以确立一个有效等价类和两个无效等价类【~~一个在范围里，两个在范围外的两头~~】
>- 在输入条件规定了输入值的集合，可确立一个有效等价类和一个无效等价类【~~一个在集合里，一个在集合外~~】
>- 在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类
>- 输入条件有多个输入值，每个输入值有不同的输入条件，可确定 n 个有效等价类和一个无效等价类【~~一个值一个范围，一个有效等价类；其他的范围都是无效等价类~~】

# 白盒测试
>[!quote] 白盒测试 / 结构测试
>白盒测试 是根据程序的内部结构，对程序的每一行语句，每一个分支进行测试
>
>- **静态白盒测试**：<u>在不运行程序的情况下</u>，检查代码的规范性，可读性，逻辑性，正确性【走查，复审，评审】
>- **动态白盒测试**：需要实际执行程序，利用对程序内部结构的了解来设计测试用例，验证程序在执行时是否按照预期工作

## 覆盖要求 - 大题
```c
// m, n, p 表示输入参数
// A，B, C 表示判定条件，A是m>0，B是n>0，C是p>0
// X，Y，Z 表示语句块
void test(int m, int n, int p) {
	if(A && B) {
		X
	} else {
		Y
	}
	
	if(C) {
		Z
	}
}
```

程序流程图：
![300](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202406152118847.png)

---

- **语句覆盖**：使程序中每一条<u>可执行语句</u>至少被执行一次

图中的可执行语句有 5 个【~~绿色 + 橙色 的框~~】，所以只用两条路径即可达成语句覆盖：
- ① ② ④
- ① ③ ④

**测试用例**：

| 数据     | 路径    | P1  | P2  |
| ------ | ----- | --- | --- |
| 1,1,1  | ① ② ④ | Y   | Y   |
| -1,2,2 | ① ③ ④ | N   | Y   |

---

- **分支覆盖 / 判定覆盖**：使程序的每一个分支都执行一次【~~为真一次，为假一次~~】

图中有两个分支【P1，P2】，那只用两条路径即可达成分支覆盖：
- ① ② ④
- ① ③ ⑤

**测试用例**：

| 数据      | 路径    | P1  | P2  |
| ------- | ----- | --- | --- |
| 1,1,1   | ① ② ④ | Y   | Y   |
| -1,2,-1 | ① ③ ⑤ | N   | N   |

---

- **条件覆盖**：程序中的每个条件都为真一次，为假一次

图中有三个条件【~~A，B，C~~】，所有条件都为真一次，为假一次，那只用 2 条路径即可覆盖条件覆盖【~~A 也 有 0 有 1 了，B 也是 ……~~ 】：
- ① ② ④  所有条件都为真 1 1 1
- ① ③ ⑤  所有条件都为假 0 0 0 

**测试用例**：

| 数据       | 路径    | P1  | P2  |
| -------- | ----- | --- | --- |
| 1,1,1    | ① ② ④ | Y   | Y   |
| -1,-1,-1 | ① ③ ⑤ | N   | N   |

>[!hint] 条件覆盖不一定覆盖分支覆盖【也就是说满足了条件覆盖，也不一定满足分支覆盖】

---

- **判定条件覆盖 / 分支条件覆盖**：就是分支覆盖 + 条件覆盖，既满足分支覆盖，也满足条件覆盖

**测试用例**：

| 数据       | 路径    | P1  | P2  |
| -------- | ----- | --- | --- |
| 1,1,1    | ① ② ④ | Y   | Y   |
| -1,-1,-1 | ① ③ ⑤ | N   | N   |

---

- **条件组合覆盖**：使程序中每个判定的所有条件组合都至少出现过一次

图中有两个判定，P1 有两个条件【A，B】，那 A 和 B 的所有组合都出现一次，P2 有一个条件【C】，C 的所有组合都出现一次，所以只用 2 条路径即可覆盖条件组合覆盖的 4 种情况：
- A B C：0 0 0    ① ③ ⑤
- A B C：0 1 0    ① ③ ⑤
- A B C：1 0 0    ① ③ ⑤
- A B C：1 1 1    ① ② ④

**测试用例**：

| 数据       | 路径    | P1  | P2  |
| -------- | ----- | --- | --- |
| -1,-1,-1 | ① ③ ⑤ | N   | N   |
| -1,1,-1  | ① ③ ⑤ | N   | N   |
| 1,-1,-1  | ① ③ ⑤ | N   | N   |
| 1,1,1    | ① ② ④ | Y   | Y   |

---

- **路径覆盖**：比较复杂，我们给出做题的 4 个步骤
	- 画程序控制流图
	- 计算环路复杂度
		- 环路复杂度 V(G) = 区域个数
		- 环路复杂度 V(G) = 边数 - 节点数 +2
		- 环路复杂度 V(G) = 判定节点 + 1
	- 写基本路径
		- 基本路径条数 = V(G)
		- 基本路径组必须覆盖所有边
		- 寻找基本路径方法：想象从开始节点浇一盆水下去，流到每个边
	- 设计测试用例
		- 根据基本路径组来写
		- 测试用例包括：测试数据，预期结果，覆盖路径

```c
1. void Sort(int iRecordNum, int iType) {
2.     int x = 0;
3.     int y = 0;
4.     
5.     while (iRecordNum-- > 0) {
6.         if (0 == iType) {
7.             x = y + 2;
8.             break;
9.         } else {
10.             if (1 == iType) {
11.                 x = y + 10;
12.             } else {
13.                 x = y + 20;
14.             }
15.         }
16.     }
17. }
```

![](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202406152229039.png)

V(G) = 4 个区域 = 4
V(G) = 边数 - 节点数 + 2 = 10 - 8 + 2 = 4

基本路径组：
- 5 - 17
- 5 - 6 - 7,8 - 17
- 5 - 6 - 10 - 11 - 15 - 5 - 17
- 5 - 6 - 10 - 13 - 15 - 5 - 17

测试用例：


| 编号  | 测试数据                     | 预期结果  | 覆盖路径             |
| --- | ------------------------ | ----- | ---------------- |
| 1   | iRecordNum = 0，iType = 0 | x = 0 | 5 - 17           |
| 2   | iRecordNum = 1，iType = 0 | x = 2 | 5 - 6 - 7,8 - 17 |
| 3   |                          |       |                  |
| 4   |                          |       |                  |



## 路径计算
![](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202406121527736.png)

# 单元测试
>[!hint] 单元测试 通过/不通过的标准
>- **通过标准**
>	- 所有的测试用例都执行过
>	- 所有被测单元的语句覆盖率达 100%
>	- 所有被测单元的判定覆盖率达 100%
>	- 所有被测单元的条件覆盖率达 100%
>	- 所有被测单元的独立路径都运行过
>	- 所有发现的 bug 都被修正，并经过回归测试
>- **不通过标准**
>	- 严重 bug 密度大于 <u>15 个 bug / 1000 行代码</u>
>	- 存在重大结构设计问题，修改会导致 20% 以上的函数发生变化
>	- 关键功能没有设计，修改会导致 20% 以上的函数发生变化

>[!quote] 单元测试环境
> ```mermaid
> graph TB
> 	a[驱动程序] --> b[被测单元]
> 	b --> c[桩程序]
> ```
> 
>- 驱动程序：模拟被测单元的上一层程序
>- 桩程序：模拟被测单元调用的程序


# 集成测试
>[!quote] 集成测试的方法
>- **一次性集成测试**
>	- 适用场景
>		- 被测试系统曾经有稳定运行过
>		- 被测系统规模不大
>		- 各个模块之间联系紧密，分不开，只能一次性集成测试
>	- 优点：用例少，测试快
>	- 缺点：出现错误，定位难
>- **自顶向下集成测试**：从系统的顶层模块开始，逐步向下集成各个子模块，直到整个系统被测试
>	- 优点：无需开发驱动模块
>	- 缺点
>		- 桩程序开发工作量大
>		- 对最底层模块的测试不够充分
>- **自底向上集成测试**
>	- 适用场景：需要对最底层模块充分测试时
>- **混合渐增式集成测试**：从模块的开始，向上下增量测试
>- **协作集成测试**：如果多个模块完成一个特定的功能时，那协作集成测试就是把这多个模块看成一个整体进行测试

# 系统测试
>[!quote] 系统测试
>- 系统测试检查了软件在整体运行环境中的表现
>- 系统测试还对需求分析，概要设计，详细设计，用户使用说明 …… 等<u>文档进行审查</u>

## 性能测试
>[!quote] 负载压力测试 的衡量指标
>- 并发的用户数量
>- 事务处理指标
>	- 平均事务响应时间
>	- 1s 内处理事务的总数
>- Web 请求指标
>	- 每秒点击次数
>	- 每秒 HTTP 响应数量

- **负载测试**：确保系统能够在<u>预期的</u>用户数量 / 事务量下正常工作 【在性能曲线拐点之前】
- **压力测试**：确定系统在<u>极端条件下的</u>行为，系统会如何反应 【在性能曲线拐点之后】

## 兼容性测试
>[!quote] 兼容性测试
>兼容性测试 是确保系统能够在不同的硬件，软件，网络环境，设备上正常运行

## 易用性测试
- 界面美观
- 功能实用
- 处理有效

---

第一次：89页，1，2
第二次：55页，1，2
第三次：118页，1
第四次：第六章ppt-int IsLeap(int year)...
第五次：第六章ppt-输入的第一个字符必须是...













