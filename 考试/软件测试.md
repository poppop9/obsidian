第一次：89页，1，2
第二次：55页，1，2
第三次：118页，1
第四次：第六章ppt-int IsLeap(int year)...
第五次：第六章ppt-输入的第一个字符必须是...

# 基础概述
数据结构描述了数据值的集合，以及这些值之间的关系，数据项是数据结构中最基本的单元

数据流图：描述数据处理过程的工具，<u>是逻辑模型</u>

sc 图是<u>半逻辑半物理模型</u>

>[!quote] 软件生命周期
> - 可行性研究：用最小的代价在尽可能短的时间内确定问题是否能够解决
> 	- 任务：进行一次大的压缩简化了的系统分析和设计的过程
> 	- 分析：经济可行性、技术可行性、运行可行性、法律可行性，开发方案可行性
> - 需求分析
> - 总体设计
> - 详细设计
> - 编码
> - 测试

系统流程图 是描绘物理系统的传统工具，它的基本思想是<u>用图形符号以黑盒子形式描绘未来系统概貌的物理模型</u>

>[!hint] 各种模型的优缺点
>- 瀑布模型
> 	- 优点：开发过程便于管理和控制
> 	- 缺点：将软件开发的过程线性化，开发的产品只有到交付时才能和用户见面，如果不满意只能从头改
> - 快速原型化模型
> 	- 优点：能够开发出真正满足用户需要的软件
> 	- 缺点：由于比较简化，可能与实际产品存在差异
> - 螺旋模型
> 	- 将前两种模型进行结合，加入了风险分析

度量效益的三个名词：货币的时间价值，投资回收期，纯收入

>[!quote] 数据字典
>数据流，数据结构，数据项，数据存储，加工，外部实体

## BUG
>[!quote] bug / 软件错误
>计算机系统或程序中存在的一种破坏正常运行的问题
>
>- 五个级别：
> 	- **致命的**：对整个系统产生了影响；高价值的用户数据丢失【~~因为数据丢失很难恢复~~】
> 	- **严重的**：主要功能模块里面有 bug，导致主要功能无法运行
> 	- **一般的**：次要功能不太理想
> 	- **微小的**：对功能基本没有影响
> 	- **轻微的**
> - 状态：
> 	- 已提交
> 	- 待 / 已分配
> 	- 已处理
> 	- 已 / 未关闭

>[!hint] Bug 的生命周期
>生命周期中有 7 个状态
>![500](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202406171335307.png)

>[!quote] 软件缺陷
>软件缺陷 是指对软件产品预期属性的偏离现象

>[!quote] 软件故障
>软件运行过程中出现的一种不可接受的<u>内部状态</u>。当软件出现故障时，可能不会立即导致软件失效，但存在潜在的风险

>[!quote] 软件失效
>软件运行时产生的不可接受的<u>外部行为结果</u>，失效可能是由于软件故障直接引起的，也可能是由于外部环境变化【~~用户输入错误或其他非预期的交互导致的~~】

>[!quote] 每日构造 bug
>每日构造 Bug 是现实“零Bug”管理的一项具体措施，就是把每日的程序在组内公开，每个人都可以看到每天的进展，并能做出评估

# 软件测试策略
>[!quote] 软件测试
>- **目标**：尽可能多地找出 Bug
>- **定义**
>	- 狭义定义：软件测试是为了发现错误而执行程序的过程【~~在狭义定义里，软件测试只有执行程序~~】
>	- 广义定义：需求分析、设计评审、代码审查、配置管理、持续集成、性能监控、安全测试、用户验收测试，测试执行程序【~~在广义定义里，软件测试不仅仅只是执行程序~~】
>- **发展的四个阶段**
>	- 程序调试
>	- 验证软件系统的正确性
>	- 找出软件的 bug
>	- 对软件质量的度量
>- **四个阶段**：
>	- 单元测试：测代码
>	- 集成测试：测接口
>	- 确认测试：测需求
>	- 系统测试
>- **生命周期**：计划，分析，设计，构建，周期测试，测试与实施，实施后期

>[!quote] 软件测试的信息流
>![](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202406172246846.png)

>[!quote] 测试用例
>测试用例 就是测试的输入数据，和预期结果的描述
>三要素：
>- 输入数据
>- 覆盖路径
>- 预期结果

>[!quote] 软件测试的辩证观
>- 正向思维：确保测试与业务目标和用户需求相一致，逐个验证功能的正确性
>- 反向思维：挑战现有的假设和测试策略，寻找可能被忽视的问题和风险，找出系统弱点

# 黑盒测试
>[!quote] 黑盒测试 / 功能测试
>黑盒测试 就是把程序和测试对象看成一个黑盒子，验证输入和输出之间的关系，<u>不考虑程序内部的结构和特征</u>，目标是测试程序的功能和接口

## 等价类 - 大题
- **有效等价类**：对于软件规格来说，是合理的，有意义的输入数据的集合，<u>用于检查是否实现了规定的内容</u>
- **无效等价类**：对于软件规格来说，是不合理的，无意义的输入数据的集合，<u>用于检查软件对于异常情况的反应</u>

>[!hint] 写无效等价类时合适就好，不要太宽泛，也不要太细致
>比如有效等价类是字母开头，那无效等价类不要太宽泛：非字母开头；也不要太细致：1 开头，2 开头，3 开头 ……

---

**例题**：某个系统的注册用户名要求由字母开头，后跟字母或数字的任意组合构成，有效字符数不超过 6 个

从例题可以知道，有三个要求：
- 用户名前缀
- 用户名后缀
- 用户名长度

| 输入数据  | 有效等价类               | 无效等价类              |
| ----- | ------------------- | ------------------ |
| 用户名前缀 | 1.字母开头              | 2.数字开头 3.非法字符开头    |
| 用户名后缀 | 4.纯字母 5.纯数字 6.字母加数字 | 7. 包含非法字符          |
| 用户名长度 | 8.字符数大于 0 ，且小于等于 6  | 9.字符数为空 10.字符数大于 6 |

**测试用例**：测试用例分为有效测试用例【<u>需要覆盖所有有效等价类的条件，尽可能地少写</u>】，和无效测试用例【<u>需要覆盖所有无效等价类的条件，尽量多写</u>】

|       | 输入数据         | 输出数据 |
| ----- | ------------ | ---- |
| 有效等价类 | A00 (1 5 8)  | 正常注册 |
|       | A0A (1 6 8)  | 正常注册 |
|       | AAA (1 4 8)  | 正常注册 |
| 无效等价类 | 0AA (2)      | 输入错误 |
|       | @AA (3)      | 输入错误 |
|       | A@@ (7)      | 输入错误 |
|       | (9)          | 输入错误 |
|       | AAAAAAA (10) | 输入错误 |

## 决策表法
**例 1**：对功率大于 100 马力的机器，或维修记录不全，或已运行 6 年以上的机器，应给予优先的维修处理

- 写出条件桩
- 写出动作桩
- 画决策表

![](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202406170029046.png)

---

**例 2**：输入的第一个字符必须是#或*，第二个字符必须是数字，此情况下进行文件的修改；若第一个字符不是#或*，则给出信息 N，若第二个字符不是数字，则给出信息 M。根据上述描述画出因果图，以及给出决策表

![](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202406172056463.png)
![](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202406172127850.png)

# 白盒测试
>[!quote] 白盒测试 / 结构测试
>白盒测试 是根据程序的内部结构，对程序的每一行语句，每一个分支进行测试
>
>- **静态白盒测试**：<u>在不运行程序的情况下</u>，检查代码的规范性，可读性，逻辑性，正确性【走查，复审，评审】
>- **动态白盒测试**：需要实际执行程序，利用对程序内部结构的了解来设计测试用例，验证程序在执行时是否按照预期工作

## 覆盖要求 - 大题
```c
// m, n, p 表示输入参数
// A，B, C 表示判定条件，A是m>0，B是n>0，C是p>0
// X，Y，Z 表示语句块
void test(int m, int n, int p) {
	if(A && B) {
		X
	} else {
		Y
	}
	
	if(C) {
		Z
	}
}
```

程序流程图：
![300](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202406152118847.png)

---

- **语句覆盖**：使程序中每一条<u>可执行语句</u>至少被执行一次

图中的可执行语句有 5 个【~~绿色 + 橙色 的框~~】，所以只用两条路径即可达成语句覆盖：
- ① ② ④
- ① ③ ④

**测试用例**：

| 数据     | 路径    | P1  | P2  |
| ------ | ----- | --- | --- |
| 1,1,1  | ① ② ④ | Y   | Y   |
| -1,2,2 | ① ③ ④ | N   | Y   |

---

- **分支覆盖 / 判定覆盖**：使程序的每一个分支都执行一次【~~为真一次，为假一次~~】

图中有两个分支【P1，P2】，那只用两条路径即可达成分支覆盖：
- ① ② ④
- ① ③ ⑤

**测试用例**：

| 数据      | 路径    | P1  | P2  |
| ------- | ----- | --- | --- |
| 1,1,1   | ① ② ④ | Y   | Y   |
| -1,2,-1 | ① ③ ⑤ | N   | N   |

---

- **条件覆盖**：程序中的每个条件都为真一次，为假一次

图中有三个条件【~~A，B，C~~】，所有条件都为真一次，为假一次，那只用 2 条路径即可覆盖条件覆盖【~~A 也 有 0 有 1 了，B 也是 ……~~ 】：
- ① ② ④  所有条件都为真 1 1 1
- ① ③ ⑤  所有条件都为假 0 0 0 

**测试用例**：

| 数据       | 路径    | P1  | P2  |
| -------- | ----- | --- | --- |
| 1,1,1    | ① ② ④ | Y   | Y   |
| -1,-1,-1 | ① ③ ⑤ | N   | N   |

>[!hint] 条件覆盖不一定覆盖分支覆盖【也就是说满足了条件覆盖，也不一定满足分支覆盖】

---

- **判定条件覆盖 / 分支条件覆盖**：就是分支覆盖 + 条件覆盖，既满足分支覆盖，也满足条件覆盖

**测试用例**：

| 数据       | 路径    | P1  | P2  |
| -------- | ----- | --- | --- |
| 1,1,1    | ① ② ④ | Y   | Y   |
| -1,-1,-1 | ① ③ ⑤ | N   | N   |

---

- **条件组合覆盖**：使程序中每个判定的所有条件组合都至少出现过一次

图中有两个判定，P1 有两个条件【A，B】，那 A 和 B 的所有组合都出现一次，P2 有一个条件【C】，C 的所有组合都出现一次，所以只用 2 条路径即可覆盖条件组合覆盖的 4 种情况：
- A B C：0 0 0    ① ③ ⑤
- A B C：0 1 0    ① ③ ⑤
- A B C：1 0 0    ① ③ ⑤
- A B C：1 1 1    ① ② ④

**测试用例**：

| 数据       | 路径    | P1  | P2  |
| -------- | ----- | --- | --- |
| -1,-1,-1 | ① ③ ⑤ | N   | N   |
| -1,1,-1  | ① ③ ⑤ | N   | N   |
| 1,-1,-1  | ① ③ ⑤ | N   | N   |
| 1,1,1    | ① ② ④ | Y   | Y   |

## 路径覆盖
**路径覆盖**比较复杂，也是最全面的覆盖，我们给出做题的 4 个步骤
- 画程序控制流图
- 计算环路复杂度
	- 环路复杂度 V(G) = 区域个数
	- 环路复杂度 V(G) = 边数 - 节点数 +2
	- 环路复杂度 V(G) = 判定节点 + 1
- 写基本路径
	- 基本路径条数 = V(G)
	- 基本路径组必须覆盖所有边
	- 寻找基本路径方法：想象从开始节点浇一盆水下去，流到每个边
- 设计测试用例
	- 根据基本路径组来写
	- 测试用例包括：测试数据，预期结果，覆盖路径

```c
1. void Sort(int iRecordNum, int iType) {
2.     int x = 0;
3.     int y = 0;
4.     
5.     while (iRecordNum-- > 0) {
6.         if (0 == iType) {
7.             x = y + 2;
8.             break;
9.         } else {
10.             if (1 == iType) {
11.                 x = y + 10;
12.             } else {
13.                 x = y + 20;
14.             }
15.         }
16.     }
17. }
```

![](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202406152229039.png)

V(G) = 4 个区域 = 4
V(G) = 边数 - 节点数 + 2 = 10 - 8 + 2 = 4

基本路径组：
- 5 - 17
- 5 - 6 - 7,8 - 17
- 5 - 6 - 10 - 11 - 15 - 5 - 17
- 5 - 6 - 10 - 13 - 15 - 5 - 17

测试用例：

| 编号  | 测试数据                     | 预期结果   | 覆盖路径                          |
| --- | ------------------------ | ------ | ----------------------------- |
| 1   | iRecordNum = 0，iType = 0 | x = 0  | 5 - 17                        |
| 2   | iRecordNum = 1，iType = 0 | x = 2  | 5 - 6 - 7,8 - 17              |
| 3   | iRecordNum = 1，iType = 1 | x = 10 | 5 - 6 - 10 - 11 - 15 - 5 - 17 |
| 4   | iRecordNum = 1，iType = 2 | x = 20 | 5 - 6 - 10 - 13 - 15 - 5 - 17 |

### 复合条件的路径覆盖
```c
1. void Do(int X, int A, int B) {
2.     if ((A > 1) && (B == 0)) { 
3.         X = X / A;
4.     }
5.     if ((A == 2) || (X > 1)) { 
6.         X = X + 1;
7.     }
8. }
```

- 把第 2 步的条件拆解为 2.1 ，2.2
- 把第 5 步的条件拆解为 5.1，5.2

![](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202406160057117.png)

V(G) = 5
其实前四条路径已经可以完成路径覆盖了，但是由于 V(G) = 5，我们还是要再增加一条路径

| 编号  | 测试数据              | 预期结果 | 覆盖路径              |
| --- | ----------------- | ---- | ----------------- |
| 1   | X = 0，A = 0，B = 0 | 0    | 2.1 5.1 5.2 8     |
| 2   | X = 2，A = 0，B = 0 | 3    | 2.1 5.1 5.2 6 8   |
| 3   | X = 0，A = 2，B = 1 | 1    | 2.1 2.2 5.1 6 8   |
| 4   | X = 0，A = 2，B = 0 | 1    | 2.1 2.2 3 5.1 6 8 |
| 5   | ……                | ……   | ……                |

## 路径计算
![](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/202406121527736.png)

# 单元测试
单元测试以白盒测试为主，黑盒测试为辅

>[!hint] 单元测试 通过/不通过的标准
>- **通过标准**
>	- 所有的测试用例都执行过
>	- 所有被测单元的语句覆盖率达 100%
>	- 所有被测单元的判定覆盖率达 100%
>	- 所有被测单元的条件覆盖率达 100%
>	- 所有被测单元的独立路径都运行过
>	- 所有发现的 bug 都被修正，并经过回归测试
>- **不通过标准**
>	- 严重 bug 密度大于 <u>15 个 bug / 1000 行代码</u>
>	- 存在重大结构设计问题，修改会导致 20% 以上的函数发生变化
>	- 关键功能没有设计，修改会导致 20% 以上的函数发生变化

>[!quote] 单元测试环境
> ```mermaid
> graph TB
> 	a[驱动程序] --> b[被测单元]
> 	b --> c[桩程序]
> ```
> 
>- 驱动程序：模拟被测单元的上一层程序
>- 桩程序：模拟被测单元调用的程序


# 集成测试
集成测试 主要采用黑盒测试

>[!quote] 集成测试的方法
>- **一次性集成测试**
>	- 适用场景
>		- 被测试系统曾经有稳定运行过
>		- 被测系统规模不大
>		- 各个模块之间联系紧密，分不开，只能一次性集成测试
>	- 优点：用例少，测试快
>	- 缺点：出现错误，定位难
>- **自顶向下集成测试**：从系统的顶层模块开始，逐步向下集成各个子模块，直到整个系统被测试
>	- 优点：无需开发驱动模块
>	- 缺点
>		- 桩程序开发工作量大
>		- 对最底层模块的测试不够充分
>- **自底向上集成测试**
>	- 适用场景：需要对最底层模块充分测试时
>- **混合渐增式集成测试**：从模块的开始，向上下增量测试
>- **协作集成测试**：如果多个模块完成一个特定的功能时，那协作集成测试就是把这多个模块看成一个整体进行测试

# 系统测试
>[!quote] 系统测试
>- 系统测试检查了软件在整体运行环境中的表现
>- 系统测试还对需求分析，概要设计，详细设计，用户使用说明 …… 等<u>文档进行审查</u>

## 性能测试
>[!quote] 负载压力测试 的衡量指标
>- 并发的用户数量
>- 事务处理指标
>	- 平均事务响应时间
>	- 1s 内处理事务的总数
>- Web 请求指标
>	- 每秒点击次数
>	- 每秒 HTTP 响应数量

- **负载测试**：确保系统能够在<u>预期的</u>用户数量 / 事务量下正常工作 【在性能曲线拐点之前】
- **压力测试**：确定系统在<u>极端条件下的</u>行为，系统会如何反应 【在性能曲线拐点之后】

>[!tip] 测试强度估计
>某企业全年的业务量主要集中在 8 个月，每个月有 20 个工作日，每天工作 8 小时。假定全年业务量为 100 万笔，分别有如下不同的业务过程：
>- 15% 的业务处理中每一笔业务需向服务器提出 7 次请求；
>- 70% 的业务处理中每一笔业务需向服务器提出 5 次请求；
>- 15% 的业务处理中每一笔业务需向服务器提出 3 次请求；
>
>要求按 2 倍日常业务量、<u>80-20 原理</u>【~~80% 的业务，用 20% 的时间完成~~】进行测试，试估算测试强度【就是算出每秒多少次请求】：
>
> 一年：
> $$
> (100×0.15×7+100×0.70×5+100×0.15×3)×2=1000万
> $$
> 
> 一天：
> $$
> \frac{1000}{8 \times 20} = 6.25万
> $$
> 
> 一秒：
> $$
> \frac{62500 \times 0.8}{8 \times 60 \times 60 \times 0.2} = 8.68
> $$
> 
















