# 选择题

<span style="background:#d2cbff">FrameLayout可以设置多种对齐方式</span>

线性默认是横向排列子控件的

<span style="background:#d2cbff">Fragment的使用必须依赖Activity</span>
<span style="background:#d2cbff">Fragment可以调用AddToBackStack()方法返回上一个页面</span>

Get方式提交的数据是拼接在URL上的，所以它不能无限长，而且提交的数据少
POST方式提交的数据是在请求体内的，<span style="background:#d2cbff">所以它比Get提交的数据更多</span>

SharedPreferences
创建SharedPreferences对象是调用getSharedPreferences方法
SharedPreferences存储的数据本质上是一个xml文件

主线程的Handle里会自带一个Looper,<span style="background:#d2cbff">但是子线程没有</span>

<span style="background:#d2cbff">通过向Activity发送广播</span>,Service才能实现更改Activity界面元素

JSON对比XML数据体积更小,解析更快

通过startService方法启动Service：
第一次启动时，<span style="background:#d2cbff">会调用onCreate和onStart方法。</span>
如果Service已经启动，那么只会调用onStart方法

<span style="background:#d2cbff">SQLiteOpenHelper方法中的参数没有path</span>

编程中R文件找不到，有可能是<span style="background:#d2cbff">xml文件有语法错误</span>

<span style="background:#d2cbff">select * from person limit 3,5  的含义是从person表中获取5条记录,跳过前面3条</span>

BaseAdapter中getView做的事情:
加载布局
查找控件
给控件加载数据
<span style="background:#d2cbff">没有对于线程的调度</span>

ViewPager的两个适配器:FragmentPagerAdapter , FragmentStatePagerAdapter
FragmentPagerAdapter:应用在加载页面较少,体验更加顺畅
FragmentStatePagerAdapter:<span style="background:#d2cbff">应用在加载页面多(需要内存多)</span>

覆写RecyclerView适配器的方法:
onCreateViewHolder
onBindViewHolder
getItemCount
<span style="background:#d2cbff">不包括getCount</span>


# 填空题

margin设置的是控件与<u>控件</u>之间的距离
padding设置的是控件与<u>子控件</u>之间的距离

堆里存储是<u>实例变量,对象,数组</u>
栈里存储<u>局部变量,成员方法,对象的引用</u>

android 9 以上,谷歌限制了APP内的HTTP请求,我们可以在application节点下,配置<u>usesClearTextTraffic</u>属性,规避这个问题

Activity向Fragment传递数据,使用<u>setArguments</u>和<u>getArguments</u>来设置和获取数据

Android中网络编程有哪四步:
<u>网络接口封装</u>
选择网络请求工具发起请求
<u>数据解析</u>
<u>工程回调</u>

XML文件解析方式有<u>DOM,SAX,PULL</u>
<u>DOM</u>方式会将整个文档存入内存中

SharedPreference以<u>键值对</u>的形式存储数据,本质是一个<u>XML文件</u>

RecyclerView可以实现列表的<u>横向,纵向,瀑布流</u>效果

非功能性需求分析中,我们需要考虑的指标有<u>可用性,安全性,兼容性,性能,可维护性</u>

# 判断题

layout-gravity是指控件相对控件的对齐方式   

使用注解类框架标注成员变量/方法时,==不能声明为private==(因为如果声明为private,那么框架就访问不到了)

内存泄露指的是==垃圾对象没有回收==



# 小知识点题(只需要简要回答)

##### Android系统的5种数据存储方式
```
Shared Preferences
网络存储
文件存储
SQLite数据库
Content Provider
```

备注(说明每种方式如何存储):
Shared Preferences:以键值对方式存储数据
网络存储:用服务器等网络存储介质存储数据
文件存储:以文件格式存储
SQLite数据库:建表方式存储数据
Content Provider:多个应用程序之间实现数据共享


##### Android中4层系统架构：
应用层
应用框架层
系统运行库层
Linux内核层

##### Android中的4大运行组件：
Activity
Service
Broadcast Receiver(广播接收机)
Content Provider

##### Android中的4种常见布局方式：
LinearLayout
RelativeLayout
FrameLayout
ConstraintLayout

##### SP文件以键值对形式存储Map类型数据，本质是XML文件

##### drawableTop的含义，margin和padding的区别
drawableTop是一个ImageView或TextView的属性，用于在View的顶部绘制一个Drawable

margin指的是View的外边距。
padding指的是View的内边距。

##### 4大组件必须在配置文件中注册，生命周期/覆写方法默认执行在UI/主线程中

##### 广播的分类，根据注册类型（2）、传播范围（2）、传播方式（2）
动态注册
静态注册

系统广播
自定义广播

普通广播
有序广播

##### Activity的4种启动模式
Standard
SingleTop
SingleTask
SingleInstance

##### 常见的运行时异常（5个）
NullPointerException`空指针`
IndexOutOfBoundsException`索引越界`
IllegalArgumentException`非法数据异常`
IllegalStateException`非法状态异常`
ClassCastException`类型转换异常`

##### new Thread形式的2种创建线程方式的概念？启动线程的方法？
继承Thread类并重写run()方法
实现Runnable接口，再传递给Thread类

##### 多线程的实现方式有哪些（4）？
继承Thread类并重写run()方法
实现Runnable接口，再传递给Thread类
实现Callable接口并使用FutureTask类
使用线程池

##### SDK自带的线程池工具可以创建哪4种？
newFixedThreadPool`新建固定线程池`
newCachedThreadPool`新建缓存线程池`
newScheduledThreadPool`新调度线程池`
newSingleThreadExecutor`新单线程执行器`

##### Handler的作用（2个）？
消息传递
线程间通信

##### 线程调度有哪些方式（4）？
抢占式调度
协作式调度
时间片轮转调度
短作业优先调度

##### Android中动画类型有哪些（3）？
帧动画、补间动画和属性动画的区别。
```
帧动画：使用一系列连续的静态图片来组成动画。

补间动画：通过在两个状态之间进行计算来实现动画效果。属性不改变

属性动画：通过改变对象的属性值来实现动画效果。实际属性会发生变化
```

##### ANR产生的三个必要条件（3）
主线程被阻塞
输入事件无法被处理
ANR对话框弹出

##### 数据结构设计 – 哪种存储技术更适合存储哪些类型的数据
关系型数据库：关系型数据
非关系型数据库：非结构化数据
分布式文件系统：非结构化数据
内存数据库：缓存数据
缓存：缓存数据

##### app\build.gradle的作用
定义应用程序的依赖库
定义资源文件，构建类型，运行渠道
配置编译选项，签名证书

##### AndroidManifest.xml文件有哪些作用
描述应用程序的组件
定义应用程序的权限，启动方式，版本信息，元数据

##### Android系统中颜色值的定义（4）。
RGB值
ARGB值
颜色资源ID
系统颜色

##### FragmentPagerAdapter的覆写方法（2）
getItem()
getCount()

##### 适配器的覆写方法（3）？
getItem()
getCount()
getView()

##### JSON和GSON？解析JSON数据，{}对应什么？[]对应什么？
JSON是一种轻量级的数据交换格式。
GSON是用于解析JSON的工具。

{}对应着JSONObject对象  ，[]JSONArray

##### 序列化和反序列化是什么过程？对应的GSON的2个方法？
```
序列化过程将对象转换为字节流。
反序列化过程则是将字节流还原为对象。

toJson(Object src)
fromJson(String json, Class<T> classOfT)
```


##### HTTP协议常见的几个状态码含义。
200 OK
201 Created
204 No Content
400 Bad Request
401 Unauthorized
403 Forbidden
404 Not Found
500 Internal Server Error
503 Service Unavailable

##### Volley的应用场景
网络图片加载
网络数据请求
网络数据解析
网络文件传输

##### RxJava框架原理（基于什么模式）
观察者模式，迭代器模式

##### ButterKnife框架的原理。（1.编译期间 2.注解技术）；它的2个注解及作用？
ButterKnife框架是基于注解技术的Android视图注入框架，在编译期间自动绑定视图和事件

它的两个常用注解是@BindView和@OnClick，分别用于绑定视图和绑定事件。

##### RecyclerView可以实现哪些效果（3）？
瀑布流布局
多种布局类型
滑动删除
拖拽排序

##### 控件复用的容器名称？
RecyclerView








# 重点简答题

##### 什么是ANR?ANR发生场景有哪些?

全称为Application not responding

当用户触发了事件没有处理完毕,系统判定无响应,便弹出ANR

发生场景:
①键盘输入事件和触摸无响应5s
②BroadCast Reciver 的onReceive()方法无响应
③Service生命周期方法无响应


##### 内存溢出和内存泄漏分别是什么?他们是异常还是错误?

①内存泄漏:是指程序在申请内存后,无法释放已申请的内存空间。
②内存溢出:指程序申请内存时,没有足够的内存可供申请。

它们都属于error,而非exception。

##### 编译过程出错一般是指什么，如何解决？
编译过程出错：在编译过程中，出现语法错误。
可以查看build窗口的打印信息，信息中会指出报错的具体信息。

##### 运行过程出错一般是指什么，如何解决？
运行出错：在运行中，出现逻辑错误。
可以使用Logcat工具，查看报错的具体信息。


##### 请用图形+文字的方式，描述SmartHome项目主框架的UI是如何搭建的。

[![1.png|500](https://i.postimg.cc/tgWpYSxN/1.png)](https://postimg.cc/4Kfr01wY)


```
ViewPager用来装载上面的四个视图。
RadioGroup用来管理导航栏的四个单选按钮。
单选按钮为RadioButton。
```

##### 请列举Android中进程间的通信方式，并描述使用场景。
①Intent：组件间跳转使用。
②AIDL：实现Service和组件的通信
③Messenger：结合Service使用
④ContentProvider：应用间的数据共享
⑤BroadcastReceiver：系统广播可跨进程通信
⑥Socket：程序端与端之间的网络通信


##### 请用流程图或文字描述,Handler、Message、MessageQueue、Looper的作用或执行过程。
Handler：消息传递,线程间通信
Message:  携带数据的消息对象
MessageQueue:  存储Message的消息队列
Looper：负责循环读取MessageQueue中的消息


##### MVC架构和MVP架构中各层的含义，MVP相比MVC架构优点是什么？
MVP：
   M：Model，数据处理相关的类
   V：View，对应Activity
   P：Presenter，负责逻辑处理的类

MVC：
   M：Model，数据处理相关的类
   V：View，对应布局
   C：Controller，对应Activity

减轻了Activity的负担


##### 简述你对Retrofit框架的理解，它是如何实现网络编程中的四个过程的
Retrofit是一个网络请求的适配器,，它让网络请求的过程更加简单和方便。

1. 创建 Retrofit 实例
2. 定义接口 API
3. 发起网络请求
4. 处理响应数据


##### 应用程序开发中，要考虑哪些兼容性问题？如何处理？
①分辨率适配：
定义适配不同分辨率设备的文件夹,放置同名但不同像素大小的图标。

②系统版本适配：
用if语句来分隔不同系统版本号执行的代码。




# 计算题

已知App中有两个Activity：LoginActivity和MainActivity。
LoginActivity的布局文件是activity_login.xml，里面有个登录按钮，id为bt_login。
功能逻辑：
点击登录按钮，跳转到MainActivity，并传递参数，参数名为“username”,值为“zhangsan”，同时，关闭LoginActivity。
### 请根据以上描述，补充下面的代码，以实现功能。

// 继承自Activity，并实现点击事件的监听器接口
public class LoginActivity extends Activity implements  <u>OnClickListener</u>  { // 点击事件的监听器 √

protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
       <u> setContentView</u>(R.layout.activitylogin) ;                          // 加载布局 
        Button button = (Button) <u>findViewById</u>(R.id.btlogin);             // 查找控件 
        button.setOnClickListener(this);
}  

public void onClick(View v) {
    switch (<u> v.getId()</u>){                            // 匹配条件 id 
        case  <u>R.id.bt_login</u> :                            // 如果是点击了登录按钮 
           Intent intent = new Intent( <u>this</u>, MainActivity.class);            // 当前对象跳转到目标对象 
           intent.putExtra(<u>"username", "zhangsan"</u>);                          //捆绑数据key-value 
           startActivity(<u>intent</u>);                                             // 开启跳转 
           finish();                                  //关闭当前Activity 
           break;
   }
}}



### 以下为两个子线程间，使用Handler通信的案例，请补全代码。

/*线程1 - 接收线程2发送过来的数据*/
        new Thread(new Runnable() {
            public void run() {
                Looper.<u>prepare</u>();                                  // 创建Looper工具 
                mHandler = new Handler(Looper.myLooper()) {
                    public void <u>handleMessage</u>(Message msg) {                      // 接收消息数据 
                        String content = (String) msg.obj;
                        Log.i("TAG", "线程2发送过来的消息是：" + content);
                    }
                };
                Looper.<u>loop</u>();                             // 开启循环读取消息队列 
            }
        }).<u>start</u>();                                       // 起一个新线程 
        
/*线程2 - 通过Handler向线程1发送数据*/
        new Thread() {
            public void run() {
                  Message msg = mHandler.obtainMessage();
                   msg.obj = "我来自线程2..." ;
                   mHandler.<u>sendMessage(msg)</u>;                      // 发送消息数据 
                 }
            }
        }.start();



### 请完善以下代码，使用Gson实现对Json数据和JavaBean对象之间的序列化和反序列化过程。

①生成JSON字符串（序列化，对象->数据流）：
Gson gson = <u>new Gson()</u>;                           // 实例化一个Gson对象
User user = new User("张三",24);
String jsonObject = gson.<u>toJson</u>(user);                          //序列化

②解析JSON字符串（反序列化，数据流->对象）：
Gson gson = new Gson(); // 实例化一个Gson对象
String jsonString = "{\"name\":\"张三\",\"age\":24}";
User user = gson.<u>fromJson</u>(jsonString, User.class);                       //反序列化

③将以下[]类型的字符串，解析成List对象
解析：
Gson gson = new Gson();
Type userListType = new <u>TypeToken</u><ArrayList<`User`>>(){}.<u>getType</u>();       //告诉JSON框架需要的类型
List<`User`> userList = gson.from(userJson, userListType);        // 反序列化



















