#计算机/四大件 
# 🌕程序
>[!question]
>什么是程序？

***程序 = 指令 + 数据***
`System.out.println(s);`  这个程序中System.out.println是指令，s是数据

### 🌗程序运行的大体流程
![[计算机组成原理 Draw#^group=NbbuWaYJ]]

### 🌗调用函数的执行流程
![[计算机组成原理 Draw#^group=BOsvuAFO|950]]
***入栈***：call指令会把调用函数后要执行的指令地址（0154）存储在名为”栈“的主存内
***出栈***：return指令的功能是把保存在栈中的地址设定到程序计数器中

### 🌗加载到内存中的程序
当程序加载到内存后，会额外生成两个组，那就是栈和堆
![[计算机组成原理 Draw#^group=ve4wje8g|793]]
栈中的代码，是由编译器自动生成的，因此不需要程序员得参与。但是堆的内存空间，则要根据程序员编写的程序，<u>来明确进行申请分配或释放</u>[^1]。

[^1]:垃圾收集器

### 🌗可执行文件的生成流程
![[计算机组成原理 Draw#^group=nqPOuqir|625]]

>本地代码：由一系列机器语言指令组成的二进制代码

>链接：链接器可以指定库文件，指定之后可以把从中需要的目标文件抽取出来，然后和其他的目标文件结合生成<mark style="background: #D2B3FFA6;">.exe</mark>


### 🌗BIOS
##### 🌗BIOS在哪里？
>BIOS存储在***ROM***[^2]中

[^2]:通常位于主板上

##### 🌗BIOS能干什么？
>BIOS除了键盘，磁盘，显卡等基本控制程序外，还有***启动引导程序*** 的功能

引导程序：存储在<u>启动驱动器</u>[^3]起始区域的小程序，可以把硬盘等记录的OS加载到内存中运行

[^3]:操作系统的启动驱动器一般是硬盘，不过有时也可以是CD-ROM或软盘

##### 🌗BIOS的工作流程
>开机后，BIOS会确认硬件是否正常运行，没有问题的话就会启动引导程序，引导程序启动OS，OS启动应用程序


# 🌕汇编与编译
### 🌗什么是汇编，反汇编
>汇编：汇编语言编写的程序转化成机器语言程序

>反汇编：机器语言程序转化成汇编语言程序


### 🌗什么是编译，反编译
>编译：将使用高级语言编写的程序<u>转换</u>[^4]成机器语言的过程

>反编译：将二进制代码转换为高级语言代码的过程

[^4]:用于转换的程序被称为”编译器“

### 🌗编译的特点
>一行C语言程序在编译后通常会变成多行机器语言

### 🌗反编译，反汇编的难度
><u>本地代码变换成高级语言源代码</u>的反编译，要比反汇编困难。
>因为在编译的时候，编译器对代码进行了优化和变换

### 🌗汇编语言
>***汇编语言由<u>助记符</u>和<u>对应的机器语言指令</u>[^5]组成***

汇编语言的源文件为<mark style="background: #D2B3FFA6;">.asm</mark>

[^5]:原来机器语言的少部分

##### 🌗汇编语言与本地代码的关系
>用汇编语言编写的源代码中的每一条指令都对应着本地代码中的一条指令
![[计算机组成原理 Draw#^group=JOvYoMRB|700]]

##### 🌗汇编语言中的指令
>汇编语言指令的语法结构是***操作码***[^6]+***操作数***

- [x] 汇编语言指令怎么写？
![Pasted Image 20230627125709_925.jpg|700](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/Pasted%20Image%2020230627125709_925.jpg)

[^6]:由CPU的种类决定


# 🌕计算机中的数据
### 🌗什么是数字IC？
>![Pasted Image 20230627230043_118.jpg|575](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/Pasted%20Image%2020230627230043_118.jpg)

### 🌗计算机中二进制位数的特点
>二进制数的位数一般是8的倍数（8，16，32），因为计算机处理信息的基本单位是1Byte（8bit）

### 🌗整数运算
##### 🌗什么是补码？
>补码就是用正数来表示负数

>[!example]
>1. 例如，用 8 位二进制数表示 - 1 时，只需求得 1（00000001）的补码即可。将 00000001 的各位数的 0 取反成 1，1 取反成 0，然后再将取反结果 + 1，最后就转换成了 - 1（11111111）
>2. 再例如，表示 - 5，5 的二进制数为 0101，吧 0101 取反 + 1，转换成了 1011（-5）

##### 🌗那为什么要用补码来表示负数呢？
>因为所有的十进制计算在计算机里都是二进制的运算，所有的减法在计算机里都是加法。如果不用补码，那么 1-1 会等于 - 2

```
比如  
0001-------------（1）  
1001-------------（-1）  
0001+1001=  
1010-------------（-2）
```
***所以我们要用补码来表示负数***
```
0001-------------（1）  
1111-------------（-1）  
0001+1111=  
10000------0000-------（0）
```

##### 🌗补码为什么叫补码？
>可能是因为一个数和它的补码相加为 0。其实你想想就知道，表示 -5 的时候是用 5 来表示的，那 - 5 与 5 本来就互为相反数。

>[!tip]
>其实你真的不用管什么老师教你的概念：  
>	~~正数的原反补都相同，负数的原反补要计算  ~~
>	~~还有什么，计算机里存的都是补码，不是原码~~
>	
***其实计算机里存的就是这样一些数字，只不过是用补码来表示负数而已***

> [!attention] 
> 用4位二进制数表示，1000表示的是-8，而不是0。因为1000所有位取反+1是1000，1000是8，那么反过来原来的就是-8

>[!tip]
>***由于一个数和它的补码互为相反数，所以补码 ---> 取反 + 1---> 转换之前的数***  
-5（1011）------ 取反 + 1-------5（0101）


### 🌗移位运算
##### 🌗移位运算能干嘛？
>移位运算能代替乘法运算和除法运算[^39]
```
例如，将00100111左移两位的结果是10011100，左移两位后数值变成了原来的4倍。用十进制数表示的话，39（00100111）变成了156（10011100），也正好是4倍（39×4=156）
```

[^39]:十进制数左移后会变成原来的10倍，100倍，1000倍…… 同样，二进制数左移后就会变成原来的2倍，4倍，8倍……


##### 🌗移位操作时的补位
- [x] 左移操作
>直接溢出丢弃，在低位处补0


- [x] 右移操作
	- <mark style="background: #ADCCFFA6;">逻辑右移</mark>[^40]
		>高位补0

	- <mark style="background: #ADCCFFA6;">算术右移</mark>
		>负数高位补1，正数高位补0


[^40]:逻辑运算（逻辑非，与，或，异或）就是不把二进制数的值当值，而是把它当成是一种开关（on / off）


### 🌗小数运算
##### 🌗计算机可以精确地转换任何数字吗？
>***计算机是功能有限的机器设备，是无法计算无限循环小数的***
>
>实际上，十进制数 0.1 转换成二进制后，会变成0.00011001100……（1100循环）。这和无法用十进制数来表示1/3是一样的道理


##### 🌗如何解决小数的运算出错
- [x] 回避策略
>由于误差很小，所以可以无视

- [x] 把小数转换成整数进行运算

- [x] 采用BCD方法
#问题/什么是BCD？ 


##### 🌗浮点数怎样表示？
- [x] IEE754
>***(-1)^S * M * 2^E***
>
>***(-1)^S*** : 代表符号位。S为0表示正数，S为1表示负数
>***M*** : 类似科学计数法的有效数字。M大于等于1，小于2
>***2^E*** : 指数位
```
十进制：5.5
二进制：101.1  ------->(-1)^0 * 1.011 * 2^2
```


##### 🌗浮点数的空间划分
- [x] Float
	>![[计算机组成原理 Draw#^group=3r7dnfuus1uMLReXOA-5D|775]]

- [x] Double
	>1+11+52


##### 🌗浮点数的具体存储
- [x] 有效数字M
>它一定是 1.几 这样的数，既然小数点前面总是1，那我们就直接不存了，省下 1 bit 。等到最后要读取时，再把这个1加上

- [x] E
>E是一个无符号数（unsigned int），所以E的取值范围是0-255（8 bit）。但是在计数的时候E有可能出现负数（1.0 * 2^(-1)），所以规定在存入E的时候要加上中间数127（Float）或1023（Double）再存入

```
(-1)^0 * 1.011 * 2^2
S :0
M :011
E :129
实际存储：0 10000001 01100000000000000000000
```



# 🌕CPU
***CPU能够直接识别和执行的只有机器语言***。使用C，Java等语言编写的程序，最后都会转化成机器语言


### 🌗CPU由哪几个部分组成？
>CPU内部由***寄存器，控制器，运算器，时钟***四个部分构成

### 🌗CPU的四大部分是怎么协同工作的？
程序启动后，根据时钟信号，<u>控制器会从内存中读取指令和数据</u>[^7]。<u>通过对这些指令加以解释和运行</u>[^8]，<u>运算器就会对数据进行运算</u>[^9]，<u>控制器根据该运算结果来控制计算机</u>[^10]

[^7]:取指阶段
[^8]:译码阶段
[^9]:执行阶段+访存阶段
[^10]:写回阶段



对程序员来说，***CPU是具有各种功能的寄存器的集合体***


### 🌗机器语言指令的分类
![Pasted Image 20230627231403_095.jpg|750](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/Pasted%20Image%2020230627231403_095.jpg)
程序中的比较指令，就是在CPU内部做减法运算


### 🌗寄存器
##### 🌗什么是寄存器？
>寄存器可用来暂存指令，数据等处理对象，可以将其看作是内存的一种。（也有运算功能）

##### 🌗寄存器里有哪些数据？
>用于运算的数值，表示内存地址的数值

##### 🌗寄存器的分类
![[计算机组成原理 Draw#^group=xuxi6a8e|675]]
***程序计数器，累加寄存器，标志寄存器，指令寄存器，栈寄存器***都只有一个，其他的寄存器一般有多个

- [x] 程序计数器
	- <mark style="background: #ADCCFFA6;">顺序执行时，是如何工作的</mark>
		![Pasted Image 20230628105649_696.jpg|625](https://obsidian-1307744200.cos.ap-guangzhou.myqcloud.com/%E5%9B%BE%E7%89%87/Pasted%20Image%2020230628105649_696.jpg)

		实际上，一个命令和数据通常被存储在多个地址上，但为了便于说明，把指令，数据分配到了一个地址

		Windows等操作系统把程序从硬盘复制到内存后，会将程序计数器设定为0100，然后程序便开始运行。CPU每执行一个指令，程序计数器的值就会自动+1。然后，CPU的控制器就会参照程序计数器的数值，从内存中读取命令并执行。

		***程序计数器决定着程序的流程***
		
	- <mark style="background: #ADCCFFA6;">分支执行时，是如何工作的</mark>
		![[计算机组成原理 Draw#^group=RpZcmZgu|589]]


- [x] 标志寄存器
	- <mark style="background: #ADCCFFA6;">标志寄存器里面存什么？</mark>
		
		>存储CPU的一些<u>状态信息</u>[^11]，存放<u>溢出</u>[^12]和<u>奇偶校验</u>[^13]
		
		>标志寄存器的数值会根据运算结果自动设定
		>
		>![[计算机组成原理 Draw#^group=YyiQAoCkhFzwn5jKVu98q|670]]
		>
		>后3个位用来存储比较运算的结果
		
	- <mark style="background: #ADCCFFA6;">什么情况下会用到标志寄存器？</mark>
		
		```
		1.条件分支结构里的条件判断通常涉及到标志寄存器中的一些标志位
		2.循环结构中，在每次循环时，CPU都会检查标志寄存器的值，以确定是否需要继续执行循环代码段
		```
		
		


[^11]:零标志，进位标志，符号标志等
[^12]:运算的结果超出了寄存器的长度范围
[^13]:检查运算结果的值是偶数还是奇数





- [x] 基址寄存器，变址寄存器

  - <mark style="background: #ADCCFFA6;">为什么CPU会有两个关于地址的寄存器？</mark>

	```
	我们用十六进制数将计算机内存上00000000-FFFFFFFF的地址划分出来，想查看某个范围的内存区域，只要有一个32位的寄存器，即可查看全部的内存地址
	```
>但如果想要像数组那样分割特定的内存区域以达到连续查看的目的，使用两个寄存器会更方便些
>
>例如查看10000000地址-1000FFFF地址时，可以将10000000存入基址寄存器，并使变址寄存器的值在00000000-0000FFFF变化。CPU则会把基址寄存器+变址寄存器的值解释为***实际查看的内存地址***。变址寄存器的值就相当于高级编程语言程序中数组的索引功能。
>![[计算机组成原理 Draw#^group=2YFIKxHC9vKSeVUrqhH2w|630]]



- [x] 累加寄存器
>存储运算的结果(加减乘除，位运算的结果)






### 🌗控制器
##### 🌗控制器是干嘛的?
>负责把内存上的指令，数据等读入寄存器，并根据指令的执行结果来控制整个计算机



##### 🌗什么是控制？
>数据运算以外的处理（主要是数据输入输出的时机控制[^14]）

[^14]:比如内存和磁盘等媒介的输入输出，键盘和鼠标的输入，显示器和打印机的输出



### 🌗运算器
##### 🌗运算器是干嘛的？
>负责运算从内存读入寄存器的数据



### 🌗时钟
##### 🌗时钟是干嘛的？
>负责发出CPU开始计时的时钟信号

有些计算机的时钟位于CPU的外部



# 🌕内存

### 🌗CPU和内存的关系
![[计算机组成原理 Draw#^group=tijZAKqsMaVLstlyVJkDv]]

>本地代码加载到内存后才能运行。内存中存储着构成本地代码的指令和数据

>程序运行时，CPU会从内存中把指令和数据读出，然后再将其存储在CPU内部的寄存器中进行处理



### 🌗什么是主存？
>通常所说的内存指的是计算机的主存储器，简称“主存”



### 🌗主存是干嘛的？
>主存主要负责存储指令和数据。主存由可读写的元素（可读写的存储单元）构成，每个字节都带有一个地址编号[^15]

[^15]:CPU可以通过该地址读取主存中的指令和数据，当然也可以写入数据



### 🌗解读内存IC
![[计算机组成原理 Draw#^group=r8MnQVxk26r2dxbumuoQy|630]]
>因此我们可以得出这个内存IC中可以存储1024个1字节的数据

![[计算机组成原理 Draw#^group=gFTg00vdFfL-OOQK8Ta31|580]]
![[计算机组成原理 Draw#^group=TUC4jEh584-cwUBq0U51K|580]]



### 🌗显地址，隐地址
![[计算机组成原理 Draw#^group=_6JViZwYWJogXrcbz1Vo4|590]]
***显示内存地址***：在一些低级语言或汇编语言中，程序员需要显式地指定内存地址（例如指针操作，内存分配，释放等）
>程序员可以直接控制内存地址的分配和管理

***隐式内存地址***：在高级语言中，程序员是使用变量和数据结构等抽象概念来描述内存中的数据
>由编译器和操作系统自动完成内存地址的分配



### 🌗什么是内存映射？
>操作系统负责将进程中的虚拟地址映射到物理内存地址上

当程序需要访问某个变量或数据结构时，会进行内存映射，然后将数据从内存中读取到处理器中进行操作



### 🌗为什么要有栈和队列？
>如果只有数组，每次保存临时数据都需要指定地址和索引，程序就会变得很麻烦。如果我们用栈和队列提前确定好了写入和读出的顺序，就不用在指定地址和索引了



### 🌗指针
##### 🌗指针的内存大小
>指针也是一种变量，它所表示的不是数据的值，而是存储着数据的内存的地址。在windows计算机上使用的程序通常都是32位（4字节）的内存地址。这种情况下，指针变量的长度也是32位，所以它的内存大小是4个字节
![[计算机组成原理 Draw#^group=Xq554fVfD9sWvZ9tvNDd8|670]]
![[计算机组成原理 Draw#^group=tSc3BUgENzUcWiAnWA-TM|680]]



# 🌕磁盘
### 🌗什么是扇区？
>扇区是磁盘保存数据的物理单位



### 🌗硬盘
>硬盘通常安装在计算机的机箱内部

***硬盘更加可靠，因为它们使用的存储介质较为坚固，不容易出现损坏或数据丢失的情况***



### 🌗软盘
>软盘通常使用在旧式计算机或一些便携式设备上

***软盘的存储容量通常较小[^16]，读写速度也慢得多[^17]，可靠性也比较低[^18]

[^16]:常见的有1.44MB，720KB，360KB等
[^17]:通常只能达到 几十KB/s 的速度
[^18]:因为它们使用的存储介质较为脆弱，容易受到磁场，温度等外界因素的影响，导致数据损坏或丢失



***存储程序方式***：程序保存在存储设备中，通过有序地被读出来实现运行的机制



### 🌗磁盘与内存的关系
>磁盘中存储的程序，必须加载到内存后才能运行[^19]
>![[计算机组成原理 Draw#^group=w-8oXldSgZGC2zwKPdg7A]]



[^19]:因为负责解析和运行程序内容的CPU，需要通过内部程序计数器来指定内存地址，然后才能读出程序



### 🌗磁盘缓存机制
>把从磁盘中读出的数据存储到内存空间中
>![[计算机组成原理 Draw#^group=m0QNHCzgwGF7t7W4IfmXU|550]]
***当接下来需要读取同一数据时，就不用通过实际的磁盘，而是从磁盘缓存中把内容读出***



### 🌗虚拟内存
>把磁盘的一部分作为假想的内存来使用[^20]

[^20]:虚拟内存虽说是把磁盘作为内存的一部分来使用，但实际上正在运行的程序部分，在这个时间点上是必须存在内存中的（为了实现虚拟内存，就必须把实际内存的内容，和磁盘上的虚拟内存的内容进行部分置换）

***虚拟内存地址使得系统可以在有限的物理内存下运行更多的程序***。当系统中运行的程序需要的内存超出了物理内存的限制时，操作系统会将一部分程序数据暂时保存到硬盘上的虚拟内存中，以便给其他程序腾出更多的物理内存。这样就可以让更多的程序同时运行，提高了系统的内存利用率

***虚拟内存地址可以提高系统的安全性***。由于每个程序都被分配了独立的虚拟内存地址空间，因此一个程序无法直接访问另一个程序的内存空间。防止了程序之间的干扰和恶意攻击



- [ ] <mark style="background: #FFFF00;">分页式虚拟内存</mark>[^21]
![[计算机组成原理 Draw#^group=Y833_lGJI2qW5m6W3c0dn|530]]

[^21]:windows使用的

>在不考虑程序构造的情况下，把运行的程序按照一定大小的页进行分割，并以页为单位在内存和磁盘间进行置换。（一般情况下，windows计算机的页的大小是 4KB ）



### 🌗节约内存的编程方法
##### 🌗通过DLL文件实现函数共有
>假设我们编写了一个具有某些功能的函数MyFunc()。应用A和应用B都会使用这个函数。在两个应用上的运行文件中内置函数MyFunc()（***这个称为Static Link 静态链接***）后同时运行这两个应用，内存中就存在了具有同一函数的两个程序。<mark style="background: #D2B3FFA6;">这就会内存的利用效率降低</mark>
>![[计算机组成原理 Draw#^group=nRX9AQ4W7XLLr65zsS9f7]]

>同一个DLL文件的内容在运行时可以被多个应用共有，***因此内存中存在的函数MyFunc()的程序就只有一个***
>![[计算机组成原理 Draw#^group=eZR91kR6wGAae6DaVQQEZ]]



##### 🌗通过调用_stdcall
![[计算机组成原理 Draw#^group=GTfAbdaMphrRNkuw5IIsg|570]]

window提供的DLL文件内的函数，基本上都是_stdcall调用方式 

#问题/不知道在讲什么  



### 🌗物理结构
##### 🌗扇区方式
>固定长度的空间
>![[计算机组成原理 Draw#^group=KmqSGph68uuqQx2oQ5bca|670]]
一般windows使用的，windows中使用的磁盘，一般 1个扇区 是 <u>512字节</u>

- [x] 什么是扇区？
扇区是对磁盘进行***物理读写的最小单位***

- [x] 什么是簇？
>簇是文件系统中的基本存储单位

***在逻辑方面（软件方面）对磁盘进行读写上的单位是***<mark style="background: #D2B3FFA6;">扇区整数倍簇</mark>[^22][^23]

[^22]:1簇可以是512字节（此时1簇=1扇区），也可以是1KB（此时1簇=2扇区）
[^23]:在软盘中，1簇恒=1扇区，簇和扇区的大小是相等的

- [x] 簇的容量和数量的权衡
>不管是多么小的文件，都会占用1簇的空间。[^24]
![[计算机组成原理 Draw#^group=JKWI4jUnX-ZwhK2zYB_Yi|700]]

[^24]:例如，当文件大小未达到512个半角文字（512字节）时，已用空间一直是512字节。一旦达到513个文字，已用空间就会一下子变成1024字节（2簇）

<mark style="background: #D2B3FFA6;">所以文件系统需要在簇的容量和数量之间进行权衡</mark>

##### 🌗可变长方式
>长度可变的空间


# 🌕文件
>文件是字节数据的集合体[^25]

[^25]:在任何情况下，文件中的字节数据都是连续存储的

### 🌗文件与文件系统
***文件***存储的基本单位是***1字节***

***文件系统***存储的基本单位是***簇***

### 🌗压缩
##### 🌗压缩机制
- [x] RLE算法
>把文件内容用 “数据×重复次数” 的形式来表示
>![[计算机组成原理 Draw#^group=cEqko4Y7McXlInjvpmjrL|660]]




***经常被用于压缩传真的图像，但它并不适合文本文件的压缩***
![[计算机组成原理 Draw#^group=UoILdwRRgr8umMFl7RX7d|660]]

- [x] 哈夫曼算法
>多次出现的数据用小于8位的字节数来表示，不常用的数据则可以用超过8位的字节数来表示
>![[计算机组成原理 Draw#^group=sld_kDPT-CS4Y1UPyBEL4|660]]
>***不同文件的哈夫曼编码信息是不同的***，因为有可能A文件字符m的出现频率很高，这时我们给m的编码长度就最短。但是B文件字符m出现的频率很低，那这时对应的哈夫曼编码又不同了
```
例如，在某一个文本文件中，A出现了100次，Q出现了3次
--默认时，A和Q都用8位（1字节）来表示时，源文件的大小就是100次×8位 + 3次×8位 = 824位
--假设使用哈夫曼算法，A用2位，Q用10位来表示，压缩后的大小就是100次×2位 + 3次×10位 = 230位
```

>[!example]
>再例如，压缩AAAAAABBCDDEEEEEF
>![[计算机组成原理 Draw#^group=OmJpdKKGZFGdwbNUJoT9M|500]]
>这时候会出现一个问题，100这个3位的编码，它的意思是用1，0，0这3个编码来表示E，A，A呢？还是用10，0这两个编码来表示B，A呢？亦或是用100来表示C呢？
>
>***解决办法***：
>1.加入用来区分字符的符号
>2.借助哈夫曼树构造编码体系
>![[计算机组成原理 Draw#^group=0bs94R3hoSddNEVsAmfAI|750]]

![[计算机组成原理 Draw#^group=qB7W5jHzgktR4xZA74dZC|660]]



##### 🌗压缩方式
- [x] 可逆压缩
![[计算机组成原理 Draw#^group=GDm1WxkSH41Up7cAqJ6p5|450]]
- [x] 非可逆压缩
![[计算机组成原理 Draw#^group=LnGl82fwZfNn2L8ubScel|450]]

##### 🌗图像的压缩
![[计算机组成原理 Draw#^group=zXnoMj_6ftiC2bPjI5WFI|288]]
>***BMP形式***：Windows的标准图像数据形式
>***JPEG形式***：1、把构成图像的点阵的颜色信息由RGB（红绿蓝）形式转化成YCbCr（亮度，蓝色色度，红色                     色度）形式。人眼对亮度很敏感，但对颜色的变化却有些迟钝。因此，亮度Y就是一个很重要的                    参数，而表示颜色的Cb，Cr则没有那么重要。于是我们通过减少Cb和Cr的信息间距来缩小图像                     数据的大小，然后再哈夫曼编码。                                                                                                                     2、将每个点的色素变化看作是波形的信号变化，进行<u>傅里叶变换</u>[^26]。照片等图像文件的特点                      是低频率（柔和的颜色变化）的部分较多，高频率（强烈的颜色变化）的部分较少。因此，我                      们把高频率的部分剪切掉（人眼分辨不出来什么差别）。这样一来，图像数据也就会缩小。再                      哈夫曼编码。
>***TIFF形式***：通过在文件头中包含”标签“就能够显示出数据性质的图像数据形式
>***GIF形式***：要求色数不超过256色

[^26]:傅里叶变换是指将波形按照频率分量进行分解。


### 🌗可执行文件（.exe）
![[计算机组成原理 Draw#^group=t__w3I8w60sMzuKGo8xvL|770]]
***Dump***：把文件的内容，每个字节用2位十六进制数来表示的方式

>当一个程序被编译和链接为可执行文件（.EXE文件）后，其中的变量和函数都被分配了***虚拟内存地址***
>
>为了实现虚拟内存地址到物理内存地址的转换，链接器会在.EXE文件的开头添加一些必要的信息，这些信息被称为<mark style="background: #D2B3FFA6;">再配置信息</mark>（relocation information）
>
>每当程序被加载到内存中时，操作系统会根据再配置信息来对程序进行地址转换，将程序中的虚拟内存地址映射到实际的物理内存地址上。这样，程序就可以正常地访问变量和函数了


### 🌗库文件
***<mark style="background: #D2B3FFA6;">库文件可以增加链接器在链接时的效率</mark>***[^27]

[^27]:比如本来要链接100个目标文件，使用库文件后可能只需要链接几个库文件即可

##### 🌗静态链接库（.lib）
>静态链接库是包含可重用代码和数据的文件

静态链接库***在编译时被链接到程序中***，链接后的可执行文件中包含了静态链接库中的代码和数据（这意味着，当程序运行时，所需的函数和代码已经被完全复制到可执行文件中，程序不需要再依赖于外部的库文件）

<mark style="background: #D2B3FFA6;">静态链接库的优点是方便移植和分发</mark>[^28]，<mark style="background: #D2B3FFA6;">但是每个可执行文件的大小可能会很大</mark>

[^28]:因为可以将所有代码和数据打包在一个可执行文件中



##### 🌗动态链接库（.dll）
>动态链接库是一种特殊的库文件，它是在程序运行时动态加载到内存中的

动态链接库***在程序运行时被加载到内存中***，程序通过调用动态链接库中的函数来使用其功能（这意味着，当程序运行时，它需要依赖于外部的库文件）

<mark style="background: #D2B3FFA6;">动态链接库的优点是可以在多个应用程序之间共享代码和数据</mark>[^29]，<mark style="background: #D2B3FFA6;">动态链接库的更新也相对容易</mark>[^30]
<mark style="background: #D2B3FFA6;">但是会增加程序启动时间和运行时的开销</mark>[^31]

[^29]:因为多个应用程序可以同时使用同一个动态链接库
[^30]:因为只需要将库文件替换为新版本即可，而不需要重新编译整个应用程序
[^31]:因为程序需要在运行时动态加载和链接库文件

Windows中，API的目标文件，就是存储在DLL中



##### 🌗导入库
>导入库[^32]是在编译可执行文件时使用的特殊库文件，其中包含了程序需要使用的一个或多个dll文件中的<u>函数的名称</u>和<u>入口点地址</u>

[^32]:函数的实体（在dll文件中）不在导入库中，他只是在编译时确定函数的位置，以便调用

***导入库的作用是告诉编译器程序需要使用哪些动态链接库的函数，以便在程序运行时能够正确地链接到这些函数***

![[计算机组成原理 Draw#^group=xRvbkPgzE9owf_F4wVDao|460]]



# 🌕运行环境
>运行环境 = 操作系统 + 硬件

>![[计算机组成原理 Draw#^group=pZAGY0RDV9fV7SO2OBWmY|660]]
在MS-DOS上，不同机型的应用是不同的；在Windows上，则可以使用同一个应用
在MS-DOS上，应用大多都是不经过操作系统而直接控制硬件的；在Windows上，应用则基本上由Windows来完成对硬件的控制

![[计算机组成原理 Draw#^group=_83VKpBtB3iH5NPRppwKo|550]]
***应用程序必须根据不同的操作系统类型来专门开发。因为操作系统的类型不同，API[^33]也是不同的；同样的道理，CPU的类型不同，所对应的机器语言也不同***  
#问题/不知所云 

[^33]:API（系统调用）：应用程序向操作系统传递指令的途径



### 🌗有没有能够克服CPU在内的所有硬件差异的系统
##### 🌗FreeBSD
![[计算机组成原理 Draw#^group=WhQ6aX4h_RCqibUGk8EVW|570]]



##### 🌗Java虚拟机
>![[计算机组成原理 Draw#^group=tGOiaS8QgiwMz9LqDIY4w|700]]
Java虚拟机是一边把Java字节代码逐一转换成本地代码一边运行的


- [ ] ***Java虚拟机的缺点：***
- 想让所有字节代码在任意Java虚拟机上运行是比较困难的[^34]
- 当我们使用只适用于某些特定硬件的功能时，就会出现在其他Java虚拟机上无法运行，或者功能使用受限等情况
- Java虚拟机每次运行时都要把字节代码变换为本机代码，这就导致了运行速度慢


[^34]:虽然Java虚拟机规范定义了一些标准的字节码指令集，但不同的Java虚拟机实现可能存在一些差异（例如对一些细节的处理方式、性能优化等不同的策略）。这些差异可能会导致相同的字节码在不同的Java虚拟机上执行结果不同。因此，为了确保字节码在各种不同的Java虚拟机上都能够正确地运行，需要注意一些细节问题（例如API的使用、字节码的生成方式、特定的虚拟机实现等等）。这些细节问题的处理，会因为Java虚拟机的厂商和版本的不同而有所变化。



# 🌕输入、输出设备
### 🌗应用与IN，OUT硬件之间的关系
![[计算机组成原理 Draw#^group=0oJTyBKxutTF6hRfgYB8o|400]]

假设要在窗口中显示字符串，就可以使用Windows API中的<u>TextOut函数</u>[^35]

[^35]:printf()函数是用来在命令提示符中显示字符串的函数，无法在窗口和打印机输出字符串


### 🌗识别外围设备的三大组合
##### 🌗I/O端口号
##### 🌗IRQ
##### 🌗DMA通道

>后两者不是所有外围设备都具备，因为有些外围设备不需要


### 🌗IO控制器
>交换计算机主机和外围设备之间电流特性的IC

>![[计算机组成原理 Draw#^group=wUaa7HgtCkFkZcVhdD2D2|500]]
***除了显卡，网卡等特殊IO，其他IO都是在主板上的***
***显示器，键盘等外围设备都有各自专用的IO控制器***

>IO控制器中也有寄存器，它无法运算处理数据，只能存储数据
>![[计算机组成原理 Draw#^group=vN2WwP9NLQMRd9WxhHexH|560]]
一个IO控制器有多个端口（一个端口有一个端口号），可以控制多个外围设备，但是每个端口都有一个特定的用途   

#问题/搞不清端口号和这张图和文字 


### 🌗IRQ
>Interrupt Request

>![[计算机组成原理 Draw#^group=07KE1SqPc-FV_4brOcx_L|590]]
>***请求中断处理程序：IO控制器***
>***实施中断处理程序：CPU***

当有多个外围设备同时发送中断请求时，CPU也会为难，所以在IO控制器和CPU之间加入了***中断控制器***[^36]

[^36]:可以把多个请求有序地传递给CPU

##### 🌗中断请求处理有什么用？
- [ ] 比如主程序正在调查是否有鼠标输入，就在这时发生了键盘输入，如果没有中断处理请求，那就会导致键盘输入的内容无法实时显示。

- [ ] **在没有中断处理请求时**，计算机主机会不断地向打印机发送数据以进行打印。如果打印机出现问题（例如缺纸，卡纸），计算机主机不得不等待打印机解决问题并恢复正常工作，然后才能继续向打印机发送数据。这样会浪费大量的计算机主机处理时间，并且会导致整个系统变得非常缓慢。**在有中断处理请求时**，如果打印机出现问题，计算机主机会向打印机发送一个中断请求。然后<mark style="background: #D2B3FFA6;">计算机主机就可以在等待期间执行其他任务</mark>，在打印机解决问题并准备好接收数据时，它会向计算机主机发送一个中断响应，以便计算机主机可以继续向打印机发送数据。***这个过程会不断重复，直到所有数据都已经被打印出来为止***

### 🌗DMA
>direct memory access
>***在不通过CPU的情况下，外围设备直接和主内存进行数据传送

![[计算机组成原理 Draw#^group=zJfV4nXijPU3482UvoGRu]]

### 🌗显示器
>显示器中显示的信息一直存储在<u>某内存中</u>（VRAM）[^37]

><u>在程序中</u>[^38]，只要往VRAM中写入数据，该数据就会在显示器中显示出来
>![[计算机组成原理 Draw#^group=yOV86peGbFg4n_za-85a9|530]]

[^37]:video RAM
[^38]:该程序由操作系统或BIOS提供，并借助中断来进行处理





























