#计算机/编程语言/Java 
# 类加载
>如果程序要使用某个类，该类还未被加载到内存中，则系统会通过***类的加载***，***类的连接***，***类的初始化***这三个步骤来对类进行初始化
### 类加载的三个步骤
##### 类的加载
>将class文件读入内存，并为之创建一个java.lang.Class对象
##### 类的连接
- 验证阶段
	- 检验被加载的类是否有正确的内部结构，并和其他类协调一致
- 准备阶段
	- 为类变量分配内存，并设置默认初始化值
- 解析阶段
	- 将类的二进制数据中的符号引用替换为直接引用
##### 类的初始化
>主要对类变量进行初始化
###### 特点
- 如果该类未被加载/连接，则先加载/连接
- 如果该类的父类还未被初始化，则先初始化其父类[^1]
- 如果类中有初始化语句，则系统依次执行这些初始化语句
###### 什么时候类会初始化？
- 创建类的实例
- 调用类的<u>类方法</u>[^2]
- 访问类/接口的<u>类变量</u>[^3]
- 为类变量赋值
- 初始化某个类的子类
- 直接使用`java.exe`命令来运行某个<u>主类</u>[^4]
- 使用反射方式来强制创建某个类/接口对应的`java.lang.Class`对象

[^1]:所以被最先初始化的类一定是Object类
[^2]:也就是静态方法
[^3]:也就是静态变量
[^4]:包含main方法的类

### 类加载器
```
public abstract class ClassLoader extends Object
```

>[!summary] ***方法***
>static ClassLoader getSystemClassLoader()  ------
>final ClassLoader getParent()  ------
##### 作用
>负责将`.class`文件加载到内存中，并为之生成对应的`java.lang.Class`对象
##### Java运行时具有以下内置类加载器
###### Bootstrap class loader
>是虚拟机的内置类加载器，通常表示为`null`，并且没有父类
###### Platform class loader
>平台类加载器负责加载平台类（ Java SE 平台 API、其实现类和特定于 JDK 的运行时类）

System class loader
>被称为应用程序类加载器，通常用于定义应用程序类路径、模块路径和特定于 JDK 的工具上的类

```java
public static void main(String[] args) {  
    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();  
    System.out.println(systemClassLoader);  
  
    ClassLoader parent = systemClassLoader.getParent();  
    System.out.println(parent);  
  
    ClassLoader parentParent = parent.getParent();  //默认为null
    System.out.println(parentParent);  
}


jdk.internal.loader.ClassLoaders$AppClassLoader@63947c6b
jdk.internal.loader.ClassLoaders$PlatformClassLoader@448139f0
null
```

### JVM的类加载机制
##### 全盘负责
>当一个类加载器负责加载某个Class时，该Class所依赖和引用的其他Class也将由该类加载器负责载入（除非显式使用另一个类加载器来载入）                 #问题 

##### 父类委托
>当一个类加载器负责加载某个Class时，先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时，才尝试从自己的类路径中加载该类            #问题 

##### 缓存机制
>保证所有加载过的Class都会被缓存，当程序需要使用某个Class对象时，类加载器先从缓存区中搜索该Class。只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换为Class对象，存储到缓存区


# 反射
>在运行时获取类的信息（类的名称、属性、方法、构造方法等），并且可以在运行时动态地创建对象、调用方法、访问属性等

### 优缺点
##### 优点
>可以使Java程序更加灵活，具有更高的可扩展性和可重用性

##### 缺点
>会带来一定的性能开销和安全问题

### 获取字节码文件对象
##### 使用类的class属性


##### 调用对象的getClass()方法


##### 使用Class类中的静态方法forName(String className)
































